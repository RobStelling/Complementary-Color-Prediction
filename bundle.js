(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearn_1 = require("deeplearn");
var ComplementaryColorModel = (function () {
    function ComplementaryColorModel() {
        this.math = new deeplearn_1.NDArrayMathGPU();
        this.initialLearningRate = 0.042;
        this.momentum = 0.9;
        this.batchSize = 300;
        this.optimizer = new deeplearn_1.MomentumOptimizer(this.initialLearningRate, this.momentum);
    }
    ComplementaryColorModel.prototype.setupSession = function () {
        var graph = new deeplearn_1.Graph();
        this.inputTensor = graph.placeholder('input RGB value', [3]);
        this.targetTensor = graph.placeholder('output RGB value', [3]);
        var fullyConnectedLayer = this.createFullyConnectedLayer(graph, this.inputTensor, 0, 64);
        fullyConnectedLayer =
            this.createFullyConnectedLayer(graph, fullyConnectedLayer, 1, 32);
        fullyConnectedLayer =
            this.createFullyConnectedLayer(graph, fullyConnectedLayer, 2, 16);
        this.predictionTensor =
            this.createFullyConnectedLayer(graph, fullyConnectedLayer, 3, 3);
        this.costTensor =
            graph.meanSquaredCost(this.targetTensor, this.predictionTensor);
        this.session = new deeplearn_1.Session(graph, this.math);
        this.generateTrainingData(1e4);
    };
    ComplementaryColorModel.prototype.train1Batch = function (shouldFetchCost) {
        var _this = this;
        var learningRate = this.initialLearningRate * Math.pow(0.85, Math.floor(step / 42));
        this.optimizer.setLearningRate(learningRate);
        var costValue = -1;
        this.math.scope(function () {
            var cost = _this.session.train(_this.costTensor, _this.feedEntries, _this.batchSize, _this.optimizer, shouldFetchCost ? deeplearn_1.CostReduction.MEAN : deeplearn_1.CostReduction.NONE);
            if (!shouldFetchCost) {
                return;
            }
            costValue = cost.get();
        });
        return costValue;
    };
    ComplementaryColorModel.prototype.normalizeColor = function (rgbColor) {
        return rgbColor.map(function (v) { return v / 255; });
    };
    ComplementaryColorModel.prototype.denormalizeColor = function (normalizedRgbColor) {
        return normalizedRgbColor.map(function (v) { return v * 255; });
    };
    ComplementaryColorModel.prototype.predict = function (rgbColor) {
        var _this = this;
        var complementColor = [];
        this.math.scope(function (keep, track) {
            var mapping = [{
                    tensor: _this.inputTensor,
                    data: deeplearn_1.Array1D.new(_this.normalizeColor(rgbColor)),
                }];
            var evalOutput = _this.session.eval(_this.predictionTensor, mapping);
            var values = evalOutput.getValues();
            var colors = _this.denormalizeColor(Array.prototype.slice.call(values));
            complementColor =
                colors.map(function (v) { return Math.round(Math.max(Math.min(v, 255), 0)); });
        });
        return complementColor;
    };
    ComplementaryColorModel.prototype.createFullyConnectedLayer = function (graph, inputLayer, layerIndex, sizeOfThisLayer) {
        return graph.layers.dense("fully_connected_" + layerIndex, inputLayer, sizeOfThisLayer, function (x) { return graph.leakyRelu(x, 0.001); });
    };
    ComplementaryColorModel.prototype.generateTrainingData = function (exampleCount) {
        var _this = this;
        this.math.scope(function () {
            var rawInputs = new Array(exampleCount);
            for (var i = 0; i < exampleCount; i++) {
                rawInputs[i] = [
                    _this.generateRandomChannelValue(), _this.generateRandomChannelValue(),
                    _this.generateRandomChannelValue()
                ];
            }
            var inputArray = rawInputs.map(function (c) { return deeplearn_1.Array1D.new(_this.normalizeColor(c)); });
            var targetArray = rawInputs.map(function (c) { return deeplearn_1.Array1D.new(_this.normalizeColor(_this.computeComplementaryColor(c))); });
            var shuffledInputProviderBuilder = new deeplearn_1.InCPUMemoryShuffledInputProviderBuilder([inputArray, targetArray]);
            var _a = shuffledInputProviderBuilder.getInputProviders(), inputProvider = _a[0], targetProvider = _a[1];
            _this.feedEntries = [
                { tensor: _this.inputTensor, data: inputProvider },
                { tensor: _this.targetTensor, data: targetProvider }
            ];
        });
    };
    ComplementaryColorModel.prototype.generateRandomChannelValue = function () {
        return Math.floor(Math.random() * 256);
    };
    ComplementaryColorModel.prototype.computeComplementaryColor = function (rgbColor) {
        var r = rgbColor[0];
        var g = rgbColor[1];
        var b = rgbColor[2];
        r /= 255.0;
        g /= 255.0;
        b /= 255.0;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = (max + min) / 2.0;
        var s = h;
        var l = h;
        if (max === min) {
            h = s = 0;
        }
        else {
            var d = max - min;
            s = (l > 0.5 ? d / (2.0 - max - min) : d / (max + min));
            if (max === r && g >= b) {
                h = 1.0472 * (g - b) / d;
            }
            else if (max === r && g < b) {
                h = 1.0472 * (g - b) / d + 6.2832;
            }
            else if (max === g) {
                h = 1.0472 * (b - r) / d + 2.0944;
            }
            else if (max === b) {
                h = 1.0472 * (r - g) / d + 4.1888;
            }
        }
        h = h / 6.2832 * 360.0 + 0;
        h += 180;
        if (h > 360) {
            h -= 360;
        }
        h /= 360;
        if (s === 0) {
            r = g = b = l;
        }
        else {
            var hue2rgb = function (p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r, g, b].map(function (v) { return Math.round(v * 255); });
    };
    return ComplementaryColorModel;
}());
var complementaryColorModel = new ComplementaryColorModel();
complementaryColorModel.setupSession();
var step = 0;
var cost = +Infinity;
function trainAndMaybeRender() {
    var stepLimit = 4242;
    var costTarget = 1.2e-4;
    if (step >= stepLimit) {
        finishTrainingAndRendering("Reached step limit (" + stepLimit + ")");
        return;
    }
    if (cost <= costTarget) {
        finishTrainingAndRendering("Reached cost target (" + costTarget + ")\nCost: " + cost + " Step:" + step);
        return;
    }
    function finishTrainingAndRendering(message) {
        console.log(message);
        console.log(totalTime());
    }
    requestAnimationFrame(trainAndMaybeRender);
    var localStepsToRun = 5;
    for (var i = 0; i < localStepsToRun; i++) {
        cost = complementaryColorModel.train1Batch(i === localStepsToRun - 1);
        step++;
    }
    console.log('step', step, 'cost', cost);
    var colorRows = document.querySelectorAll('tr[data-original-color]');
    for (var i = 0; i < colorRows.length; i++) {
        var rowElement = colorRows[i];
        var tds = rowElement.querySelectorAll('td');
        var originalColor = rowElement.getAttribute('data-original-color')
            .split(',')
            .map(function (v) { return parseInt(v, 10); });
        var predictedColor = complementaryColorModel.predict(originalColor);
        populateContainerWithColor(tds[2], predictedColor[0], predictedColor[1], predictedColor[2]);
    }
    d3.selectAll(".predicted")
        .style("fill", function (d) {
        var originalColor = [parseInt(d.data.color.slice(1, 3), 16), parseInt(d.data.color.slice(3, 5), 16), parseInt(d.data.color.slice(5, 7), 16)];
        var predicted = complementaryColorModel.predict(originalColor);
        d.data.cost = colorCost(originalColor, predicted);
        return sharpRGBColor(predicted);
    });
    d3.select("svg").selectAll(".tempText").remove();
    d3.select("svg")
        .append("text")
        .attr("x", -120)
        .attr("y", -30)
        .attr("class", "tempText")
        .attr("font-size", "36px")
        .style("fill", "black")
        .text("Step " + step);
    d3.select("svg")
        .append("text")
        .attr("x", -120)
        .attr("y", 20)
        .attr("class", "tempText")
        .attr("font-size", "36px")
        .style("fill", "black")
        .text("Cost " + cost.toLocaleString("en", { maximumFractionDigits: 8 }));
    d3.select("svg")
        .append("text")
        .attr("x", -120)
        .attr("y", 70)
        .attr("class", "tempText")
        .attr("font-size", "36px")
        .style("fill", "black")
        .text("Time " + totalTime().toLocaleString("en", { maximumFractionDigits: 8 }));
    d3.selectAll(".predicted")
        .each(function (d, i) {
        d3.select("svg")
            .append("text")
            .attr("class", "tempText txPr")
            .append("textPath")
            .attr("xlink:href", "#pr" + i)
            .append("tspan")
            .attr("dy", -10)
            .attr("dx", 95)
            .attr("text-anchor", "middle")
            .text(function (d) { return d3.select("#pr" + i).style("fill").slice(4, -1); });
        return false;
    });
    function colorCost(a, b) {
        return Math.pow((Math.pow((a[0] - b[0]) / 255, 2) + Math.pow((a[1] - b[1]) / 255, 2) + Math.pow((a[2] - b[2]) / 255, 2)), 0.5) / 3;
    }
}
function sharpRGBColor(color) {
    return "#" + ("0" + color[0].toString(16)).slice(-2)
        + ("0" + color[1].toString(16)).slice(-2)
        + ("0" + color[2].toString(16)).slice(-2);
}
function populateContainerWithColor(container, r, g, b) {
    var originalColorString = 'rgb(' + [r, g, b].join(',') + ')';
    container.textContent = originalColorString;
    var colorBox = document.createElement('div');
    colorBox.classList.add('color-box');
    colorBox.style.background = originalColorString;
    container.appendChild(colorBox);
}
function initializeUi() {
    var testColors = [];
    var colorRows = document.querySelectorAll('tr[data-original-color]');
    for (var i = 0; i < colorRows.length; i++) {
        var rowElement = colorRows[i];
        var tds = rowElement.querySelectorAll('td');
        var originalColor = rowElement.getAttribute('data-original-color')
            .split(',')
            .map(function (v) { return parseInt(v, 10); });
        populateContainerWithColor(tds[0], originalColor[0], originalColor[1], originalColor[2]);
        var complement = complementaryColorModel.computeComplementaryColor(originalColor);
        populateContainerWithColor(tds[1], complement[0], complement[1], complement[2]);
        testColors.push({ color: sharpRGBColor(originalColor), value: 42 });
    }
    var svg = d3.select("svg");
    var arc = [d3.arc().innerRadius(250).outerRadius(320),
        d3.arc().innerRadius(350).outerRadius(420),
        d3.arc().innerRadius(450).outerRadius(520)];
    var pie = d3.pie().value(function (d) { return d.value; }).sort(null);
    var widthHeight = Math.min(window.innerHeight, window.innerWidth);
    svg.attr("width", widthHeight).attr("height", widthHeight);
    svg.selectAll("original")
        .data(pie(testColors))
        .enter()
        .append("path")
        .attr("d", arc[0])
        .style("fill", function (d) { return d.data.color; })
        .attr("id", function (d, i) { return "or" + i; })
        .attr("class", "original");
    svg.selectAll("complement")
        .data(pie(testColors))
        .enter()
        .append("path")
        .attr("d", arc[1])
        .style("fill", function (d) { return actualComplement(d.data.color); })
        .attr("id", function (d, i) { return "co" + i; })
        .attr("class", "complement");
    svg.selectAll("predicted")
        .data(pie(testColors))
        .enter()
        .append("path")
        .attr("d", arc[2])
        .style("fill", sharpRGBColor([255, 255, 255]))
        .attr("id", function (d, i) { return "pr" + i; })
        .attr("class", "predicted");
    d3.selectAll(".original")
        .each(function (d, i) {
        svg.append("text")
            .attr("class", "txOr")
            .append("textPath")
            .attr("xlink:href", "#or" + i)
            .append("tspan")
            .attr("dy", -10)
            .attr("dx", 58)
            .attr("text-anchor", "middle")
            .text(function (d) { return d3.select("#or" + i).style("fill").slice(4, -1); });
        return false;
    });
    d3.selectAll(".complement")
        .each(function (d, i) {
        svg.append("text")
            .attr("class", "txCo")
            .append("textPath")
            .attr("xlink:href", "#co" + i)
            .append("tspan")
            .attr("dy", -10)
            .attr("dx", 78)
            .attr("text-anchor", "middle")
            .text(function (d) { return d3.select("#co" + i).style("fill").slice(4, -1); });
        return false;
    });
    var annotations = [{
            note: { label: "Original colors (RGB)" },
            x: 272, y: -212,
            dy: -235, dx: 105
        }, {
            note: { label: "Computed complementary colors (RGB)" },
            x: 425, y: -130,
            dy: -160, dx: 55
        }];
    var makeAnnotations = d3.annotation().annotations(annotations);
    d3.select("svg").append("g").attr("class", "annotation-group").call(makeAnnotations);
    setTimeout(function () {
        var annotationG = [{
                note: { label: "Generated colors (RGB)" },
                x: 438, y: -328,
                dy: -80, dx: 65
            }], makeAnnotationG = d3.annotation().annotations(annotationG);
        d3.select("svg").append("g").attr("class", "annotation-group").call(makeAnnotationG);
    }, 1);
    function actualComplement(color) {
        var originalColor = [parseInt(color.slice(1, 3), 16), parseInt(color.slice(3, 5), 16), parseInt(color.slice(5, 7), 16)];
        var complement = complementaryColorModel.computeComplementaryColor(originalColor);
        return sharpRGBColor(complement);
    }
}
var startTrainingTime = new Date();
function totalTime() {
    var now = new Date;
    return (now.getTime() - startTrainingTime.getTime()) / 60000;
}
initializeUi();
setTimeout(function () { requestAnimationFrame(trainAndMaybeRender); });

},{"deeplearn":44}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error("Could not fetch variable " + varName + ": " + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"../math/ndarray":56}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].getValues();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.getValues();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.getValues();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"../math/ndarray":56,"../util":89}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"../math/ndarray":56,"../util":89}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var dataset_1 = require("./dataset");
var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
function getXhrDatasetConfig(jsonConfigPath) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', jsonConfigPath);
        xhr.onload = function () {
            resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function (error) {
            reject(error);
        };
        xhr.send();
    });
}
exports.getXhrDatasetConfig = getXhrDatasetConfig;
var XhrDataset = (function (_super) {
    __extends(XhrDataset, _super);
    function XhrDataset(xhrDatasetConfig) {
        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
        _this.xhrDatasetConfig = xhrDatasetConfig;
        return _this;
    }
    XhrDataset.prototype.getNDArray = function (info) {
        var dataPromise = info.dataType === 'png' ?
            parseTypedArrayFromPng(info, info.shape) :
            parseTypedArrayFromBinary(info);
        return dataPromise.then(function (data) {
            var inputSize = util.sizeFromShape(info.shape);
            var ndarrays = [];
            for (var i = 0; i < data.length / inputSize; i++) {
                var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                var ndarray = ndarray_1.NDArray.make(info.shape, { values: new Float32Array(values) });
                ndarrays.push(ndarray);
            }
            return ndarrays;
        });
    };
    XhrDataset.prototype.fetchData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });
            Promise.all(promises).then(function (data) {
                _this.dataset = data;
                resolve();
            });
        });
    };
    return XhrDataset;
}(dataset_1.InMemoryDataset));
exports.XhrDataset = XhrDataset;
function parseTypedArrayFromBinary(info) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', info.path);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function (event) {
            var data = (info.dataType === 'float32') ?
                new Float32Array(xhr.response) :
                new Uint8Array(xhr.response);
            resolve(data);
        };
        xhr.onerror = function (err) { return reject(err); };
        xhr.send();
    });
}
function parseGrayscaleImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx++] = data[i];
    }
}
function parseRGBImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx] = data[i];
        result[idx + 1] = data[i + 1];
        result[idx + 2] = data[i + 2];
        idx += 3;
    }
}
function parseImage(img, shape) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var N = img.height;
    var inputSize = util.sizeFromShape(shape);
    var result = new Uint8Array(N * inputSize);
    if (img.width !== shape[0] * shape[1]) {
        throw new Error("Image width (" + img.width + ") must be multiple of " +
            ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the ndarray"));
    }
    canvas.width = img.width;
    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
    var sx = 0;
    var sWidth = canvas.width;
    var sHeight = canvas.height;
    var dx = 0;
    var dy = 0;
    var dWidth = sWidth;
    var dHeight = sHeight;
    var depth = shape[2];
    var offset = 0;
    var numPasses = Math.ceil(N / canvas.height);
    for (var pass = 0; pass < numPasses; ++pass) {
        var sy = pass * canvas.height;
        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
            canvas.height = N % canvas.height;
            sHeight = canvas.height;
            dHeight = sHeight;
        }
        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
            parseRGBImageData(data, result, offset);
        offset += canvas.height * inputSize;
    }
    return result;
}
function parseTypedArrayFromPng(info, shape) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.setAttribute('crossOrigin', '');
        img.onload = function () {
            var result = parseImage(img, shape);
            img.src = '';
            img = null;
            resolve(result);
        };
        img.src = info.path;
    });
}

},{"../math/ndarray":56,"../util":89,"./dataset":4}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    }
];
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :
        'EXT_disjoint_timer_query_webgl2';
    var ext = gl.getExtension(extensionName);
    var isExtEnabled = ext != null;
    if (gl != null) {
        loseContext(gl);
    }
    return isExtEnabled;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (gl.getExtension('OES_texture_float') == null) {
            return false;
        }
    }
    else {
        if (gl.getExtension('EXT_color_buffer_float') == null) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var ext = gl.getExtension('WEBGL_get_buffer_sub_data_async');
    var isEnabled = ext != null;
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        if (features != null) {
            this.features = features;
        }
    }
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return false;
            }
            return isWebGLDisjointQueryTimerEnabled(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    return Environment;
}());
exports.Environment = Environment;
var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
exports.ENV = new Environment(getFeaturesFromURL());
function setEnvironment(environment) {
    exports.ENV = environment;
}
exports.setEnvironment = setEnvironment;

},{"./device_util":7,"./util":89}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("../initializers");
var concat_util = require("../math/concat_util");
var conv_util = require("../math/conv_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var flatValues = util.flatten(value);
            var vals = new Float32Array(flatValues);
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.leakyRelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
            (" of shape (" + this.x.shape + ") does not match size of ") +
            ("requested shape " + this.shape + "."));
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                ("shape: " + this.c1.shape));
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                ("shape: " + this.c2.shape));
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                (this.x1.shape + " and " + this.x2.shape + " must match."));
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape.toString() +
                (" must match size of vector with shape " + this.x2.shape + "."));
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                " must match first dimension of matrix with " +
                ("shape " + this.x2.shape + "."));
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            (this.w.shape + "."));
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            (this.b.shape + "."));
        util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
            ("must match input depth for weights (" + this.w.shape[2] + ")."));
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var LeakyReLUNode = (function (_super) {
    __extends(LeakyReLUNode, _super);
    function LeakyReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'LeakyReLU', { x: x }, new Tensor(x.shape)) || this;
        _this.alpha = alpha;
        return _this;
    }
    LeakyReLUNode.prototype.validate = function () { };
    LeakyReLUNode.X = 'x';
    return LeakyReLUNode;
}(Node));
exports.LeakyReLUNode = LeakyReLUNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
            ("must match target shape (" + this.target.shape + ")."));
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
            ("must match prediction shape (" + this.prediction.shape + ")."));
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
            ("must match x2 shape (" + this.x2.shape + ")."));
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;

},{"../initializers":45,"../math/concat_util":49,"../math/conv_util":50,"../math/ndarray":56,"../util":89}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":9,"./priority_queue":39}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat3d_1 = require("./ops/concat3d");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.LeakyReLUNode) {
        return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error("Unsupported node type: " + node.constructor.name);
    }
}

},{"./graph":9,"./graph_util":10,"./ops/add":12,"./ops/argmax":13,"./ops/argmaxequals":14,"./ops/concat3d":15,"./ops/convolution":16,"./ops/divide":17,"./ops/element_wise_activation":18,"./ops/element_wise_cost":19,"./ops/exp":20,"./ops/linear_combination":21,"./ops/log":22,"./ops/matmul":23,"./ops/max_pool":24,"./ops/multiply":25,"./ops/reduce_sum":27,"./ops/reshape":28,"./ops/softmax":29,"./ops/subtract":30}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x1Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x2Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.clone(dy));
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../../math/ndarray":56,"../../util":89,"../graph_util":10,"./op":26}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"./op":26}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"./op":26}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../math/concat_util");
var op_1 = require("./op");
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Concat3D backprop not implemented.');
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;

},{"../../math/concat_util":49,"./op":26}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
            gradientArrays.add(_this.wTensor, dw);
            gradientArrays.add(_this.bTensor, db);
            gradientArrays.add(_this.xTensor, dx);
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../../math/conv_util":50,"../../util":89,"./op":26}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(div));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../../util":89,"../graph_util":10,"./op":26}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = require("../../math/activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
            dydx.dispose();
        });
    };
    ElementWiseActivation.prototype.dispose = function () {
        this.func.dispose();
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(xTensor, yTensor, alpha) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
    }
    return LeakyReLU;
}(ElementWiseActivation));
exports.LeakyReLU = LeakyReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;

},{"../../math/activation_functions":46,"./op":26}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var cost_functions_1 = require("../../math/cost_functions");
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../../math/cost_functions":52,"../../math/ndarray":56,"../../util":89,"../graph_util":10,"./op":26}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../graph_util":10,"./op":26}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../graph_util":10,"./op":26}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.divide(dy, x));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../graph_util":10,"./op":26}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../../math/math");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../../math/math":53,"../graph_util":10,"./op":26}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../../math/conv_util":50,"../../util":89,"./op":26}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.add(_this.x2Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../../util":89,"../graph_util":10,"./op":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function () {
            var dy = gradientArrays.get(_this.outTensor);
            if (_this.ones == null) {
                var xArray = inferenceArrays.get(_this.x);
                _this.ones = ndarray_1.NDArray.zerosLike(xArray);
                _this.ones.fill(1);
            }
            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
        });
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../../math/ndarray":56,"../../util":89,"../graph_util":10,"./op":26}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var clone = math.clone(x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        var clone = math.clone(dy);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../../util":89,"./op":26}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_1 = require("../graph");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function () {
        throw Error('Softmax backprop is not yet implemented');
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.epsilon = ndarray_1.Scalar.new(1e-5);
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function () {
            gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../../math/ndarray":56,"../../util":89,"../graph":9,"./op":26}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.subtract(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t1, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t1, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t2, math.divide(negSum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t2, math.neg(dy));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../../math/ndarray":56,"../../util":89,"../graph_util":10,"./op":26}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var oldUpdates = _this.accumulatedUpdates.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
                var variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);
                var updateSquare = math.multiply(updates, updates);
                var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                _this.accumulatedUpdates.set(node.output, keep(newUpdates));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
                oldUpdates.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
        this.accumulatedUpdates.dispose();
    };
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        return _this;
    }
    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.add(oldCache, gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdagradOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
        return _this;
    }
    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.secondMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldSecondMoment = _this.secondMoment.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var gradientSquare = math.multiply(gradient, gradient);
                var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
                var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
                var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
                var variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.secondMoment.set(node.output, keep(newSecondMoment));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldSecondMoment.dispose();
            });
            var oldAccB1 = _this.accB1;
            var oldAccB2 = _this.accB2;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
            oldAccB1.dispose();
            oldAccB2.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.secondMoment.dispose();
        this.eps.dispose();
        this.b1.dispose();
        this.b2.dispose();
        this.accB1.dispose();
        this.accB2.dispose();
    };
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        return _this;
    }
    AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.weightedInfNorm.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
                var ut1 = math.abs(gradient);
                var newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
                var variable = math.scaledArrayAdd(_this.one, oldVariable, math.divide(_this.c, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldWeightedInfNorm.dispose();
            });
            var oldAccB1 = _this.accB1;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            oldAccB1.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamaxOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.weightedInfNorm.dispose();
        this.eps.dispose();
        this.accB1.dispose();
        this.b1.dispose();
        this.b2.dispose();
    };
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
        _this.m = ndarray_1.Scalar.new(_this.momentum);
        return _this;
    }
    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.variableVelocities.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldVelocity = _this.variableVelocities.get(node.output);
                var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
                var variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);
                _this.variableVelocities.set(node.output, keep(velocity));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldVelocity.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        this.variableVelocities.dispose();
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./sgd_optimizer":38}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var session_util = require("../session_util");
var tensor_array_map_1 = require("../tensor_array_map");
var Optimizer = (function () {
    function Optimizer(learningRate, specifiedVariableList) {
        this.learningRate = learningRate;
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        this.one = ndarray_1.Scalar.new(1);
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.c != null) {
                this.c.dispose();
            }
            this.prevBatchSize = batchSize;
            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
    };
    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    Optimizer.prototype.dispose = function () {
        if (this.c != null) {
            this.c.dispose();
        }
        this.one.dispose();
    };
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{"../../math/ndarray":56,"../session_util":41,"../tensor_array_map":42}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    RMSPropOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;

},{"../../math/ndarray":56,"../tensor_array_map":42,"./optimizer":36}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        return _this;
    }
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"../tensor_array_map":42,"./optimizer":36}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.nullify(costTensor);
        gradients.add(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function (keep, track) {
            var cost = track(ndarray_1.Scalar.new(0));
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"../math/ndarray":56,"../util":89,"./operation_emitter":11,"./session_util":41,"./tensor_array_map":42}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.nullify(input);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;

},{"../math/ndarray":56,"../util":89,"./graph":9,"./graph_util":10}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMapBase = (function () {
    function TensorArrayMapBase() {
        this.dict = {};
    }
    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error("tensor " + tensor.id + " has null array.");
        }
        return nda;
    };
    TensorArrayMapBase.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMapBase.prototype.nullify = function (tensor) {
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMapBase.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMapBase;
}());
exports.TensorArrayMapBase = TensorArrayMapBase;
var TensorArrayMap = (function (_super) {
    __extends(TensorArrayMap, _super);
    function TensorArrayMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    return TensorArrayMap;
}(TensorArrayMapBase));
exports.TensorArrayMap = TensorArrayMap;
var SummedTensorArrayMap = (function (_super) {
    __extends(SummedTensorArrayMap, _super);
    function SummedTensorArrayMap(math) {
        var _this = _super.call(this) || this;
        _this.math = math;
        return _this;
    }
    SummedTensorArrayMap.prototype.add = function (tensor, array) {
        if (this.dict[tensor.id] == null) {
            this.dict[tensor.id] = this.math.keep(array);
        }
        else {
            var oldValue = this.get(tensor);
            var newValue = this.math.keep(this.math.addStrict(oldValue, array));
            this.dict[tensor.id] = newValue;
            oldValue.dispose();
        }
    };
    return SummedTensorArrayMap;
}(TensorArrayMapBase));
exports.SummedTensorArrayMap = SummedTensorArrayMap;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var session_1 = require("./graph/session");
var ndarray_1 = require("./math/ndarray");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.totalIdleTimeMs = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
        this.totalIdleTimeMs = 0;
        this.lastStopTimestamp = null;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
        this.lastStopTimestamp = performance.now();
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        if (this.lastStopTimestamp != null) {
            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
        }
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        requestAnimationFrame(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            requestAnimationFrame(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep, track) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    var nextCopy = feedEntry.data.getNextCopy(_this.math);
                    ndarrayFeedEntries.push({ tensor: feedEntry.tensor, data: track(nextCopy) });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].getValues();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
        window.clearTimeout(this.lastInferTimeoutID);
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue);
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"./graph/session":40,"./math/ndarray":56}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xhr_dataset = require("./data/xhr-dataset");
exports.xhr_dataset = xhr_dataset;
var environment = require("./environment");
exports.environment = environment;
var conv_util = require("./math/conv_util");
exports.conv_util = conv_util;
var gpgpu_util = require("./math/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = require("./math/webgl/render_ndarray_gpu_util");
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = require("./math/webgl/webgl_util");
exports.webgl_util = webgl_util;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version = version_1.version;
var checkpoint_loader_1 = require("./data/checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./data/dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var input_provider_1 = require("./data/input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var xhr_dataset_1 = require("./data/xhr-dataset");
exports.XhrDataset = xhr_dataset_1.XhrDataset;
var environment_1 = require("./environment");
exports.ENV = environment_1.ENV;
exports.Environment = environment_1.Environment;
var graph_1 = require("./graph/graph");
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var adadelta_optimizer_1 = require("./graph/optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./graph/optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./graph/optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./graph/optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./graph/optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./graph/optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./graph/optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./graph/optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var session_1 = require("./graph/session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var graph_runner_1 = require("./graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = require("./initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var math_1 = require("./math/math");
exports.MatrixOrientation = math_1.MatrixOrientation;
exports.NDArrayMath = math_1.NDArrayMath;
var math_cpu_1 = require("./math/math_cpu");
exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
var math_gpu_1 = require("./math/math_gpu");
exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
var ndarray_1 = require("./math/ndarray");
exports.initializeGPU = ndarray_1.initializeGPU;
var ndarray_2 = require("./math/ndarray");
exports.Array1D = ndarray_2.Array1D;
exports.Array2D = ndarray_2.Array2D;
exports.Array3D = ndarray_2.Array3D;
exports.Array4D = ndarray_2.Array4D;
exports.NDArray = ndarray_2.NDArray;
exports.Scalar = ndarray_2.Scalar;
var gpgpu_context_1 = require("./math/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;

},{"./data/checkpoint_loader":3,"./data/dataset":4,"./data/input_provider":5,"./data/xhr-dataset":6,"./environment":8,"./graph/graph":9,"./graph/optimizers/adadelta_optimizer":31,"./graph/optimizers/adagrad_optimizer":32,"./graph/optimizers/adam_optimizer":33,"./graph/optimizers/adamax_optimizer":34,"./graph/optimizers/momentum_optimizer":35,"./graph/optimizers/optimizer":36,"./graph/optimizers/rmsprop_optimizer":37,"./graph/optimizers/sgd_optimizer":38,"./graph/session":40,"./graph_runner":43,"./initializers":45,"./math/conv_util":50,"./math/math":53,"./math/math_cpu":54,"./math/math_gpu":55,"./math/ndarray":56,"./math/webgl/gpgpu_context":69,"./math/webgl/gpgpu_util":71,"./math/webgl/render_ndarray_gpu_util":78,"./math/webgl/webgl_util":87,"./test_util":88,"./util":89,"./version":90}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error("Unexpected distribution for variance scaling initializer: " +
                ("" + this.distribution));
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"./math/ndarray":56}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var TanHFunc = (function () {
    function TanHFunc() {
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.tanh(x);
        });
    };
    TanHFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
        });
    };
    TanHFunc.prototype.dispose = function () { };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.relu(x);
        });
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.step(x);
        });
    };
    ReLUFunc.prototype.dispose = function () { };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var LeakyReluFunc = (function () {
    function LeakyReluFunc(alpha) {
        this.alpha = alpha;
    }
    LeakyReluFunc.prototype.output = function (math, x) {
        return math.leakyRelu(x, this.alpha);
    };
    LeakyReluFunc.prototype.der = function (math, x, y) {
        return math.step(x, this.alpha);
    };
    LeakyReluFunc.prototype.dispose = function () { };
    return LeakyReluFunc;
}());
exports.LeakyReluFunc = LeakyReluFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.sigmoid(x);
        });
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    SigmoidFunc.prototype.dispose = function () { };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.elementWiseMul(x, x);
        });
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
        });
    };
    SquareFunc.prototype.dispose = function () { };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;

},{"./ndarray":56}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    if (axis == null) {
        axis = shape.map(function (s, i) { return i; });
    }
    else if (typeof (axis) === 'number') {
        axis = [axis];
    }
    return axis;
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    if (!axesAreInnerMostDims(axes, rank)) {
        throw new Error(msg + " supports only inner-most axes for now. " +
            ("Got axes " + axes + " and rank-" + rank + " input."));
    }
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getPermutedAxes(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getPermutedAxes = getPermutedAxes;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;

},{"../util":89}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computeDepthwiseConv2DInfo(inShape, filterShape, strides, pad) {
    var filterHeight = filterShape[0], filterWidth = filterShape[1], inChannels = filterShape[2], channelMul = filterShape[3];
    var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
    var inHeight = inShape[1];
    var inWidth = inShape[2];
    var batchSize = inShape[0];
    var _b = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _b.padInfo, outHeight = _b.outHeight, outWidth = _b.outWidth;
    var outChannels = inChannels * channelMul;
    var outShape = [batchSize, outHeight, outWidth, outChannels];
    return {
        inShape: inShape,
        outShape: outShape,
        channelMul: channelMul,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        padInfo: padInfo
    };
}
exports.computeDepthwiseConv2DInfo = computeDepthwiseConv2DInfo;
function computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad) {
    var inHeight = inShape[0];
    var inWidth = inShape[1];
    var _a = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _a.padInfo, outHeight = _a.outHeight, outWidth = _a.outWidth;
    var outShape = [outHeight, outWidth, outDepth];
    return {
        inShape: inShape,
        outShape: outShape,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
    return [filterHeight, filterWidth, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        padInfo = { top: pad, bottom: pad, left: pad, right: pad };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}

},{"../util":89}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function validateShapes(sourceSize, destSize) {
    var srcArea = sourceSize[0] * sourceSize[1];
    var dstArea = destSize[0] * destSize[1];
    if (srcArea !== dstArea) {
        var srcStr = "[" + sourceSize[0] + ", " + sourceSize[1] + "]";
        var dstStr = "[" + destSize[0] + ", " + destSize[1] + "]";
        throw new Error("copy2D shapes have different areas:\n  sourceSize " + srcStr +
            (", area " + srcArea + "\n  destSize " + dstStr + ", area " + dstArea));
    }
}
exports.validateShapes = validateShapes;

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = ndarray_1.Scalar.new(0.5);
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.elementWiseMul(diff, diff);
        var result = math.scalarTimesArray(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"./ndarray":56}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var axis_util = require("./axis_util");
var broadcast_util = require("./broadcast_util");
var concat_util = require("./concat_util");
var conv_util = require("./conv_util");
var copy2d_util = require("./copy2d_util");
var ndarray_1 = require("./ndarray");
var slice_util = require("./slice_util");
var SumTypesMap;
(function (SumTypesMap) {
    SumTypesMap["float32"] = "float32";
    SumTypesMap["int32"] = "int32";
    SumTypesMap["bool"] = "int32";
})(SumTypesMap = exports.SumTypesMap || (exports.SumTypesMap = {}));
var NDArrayMath = (function () {
    function NDArrayMath(safeMode) {
        this.safeMode = safeMode;
        this.ndarrayScopes = [];
        this.ndarraysToKeep = [];
        this.activeScopeNDArraysToKeep = [];
        this.debugMode = false;
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var _this = this;
        this.startScope();
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return _this.track(ndarray); };
        var result = scopeFn(keepFn, trackFn);
        if (result instanceof Promise) {
            result.then(function (r) { return _this.endScope(r); });
            return result;
        }
        else {
            this.endScope(result);
            return result;
        }
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.debugMode = true;
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.startScope = function () {
        var newScope = [];
        this.ndarrayScopes.push(newScope);
        this.activeScope = newScope;
        var newNDArraysToKeep = [];
        this.ndarraysToKeep.push(newNDArraysToKeep);
        this.activeScopeNDArraysToKeep = newNDArraysToKeep;
    };
    NDArrayMath.prototype.extractNDArraysFromScopeResult = function (result) {
        if (result == null) {
            return [];
        }
        if (result instanceof ndarray_1.NDArray) {
            return [result];
        }
        var list = [];
        var resultObj = result;
        for (var k in resultObj) {
            var val = resultObj[k];
            if (val instanceof ndarray_1.NDArray) {
                list.push(val);
            }
        }
        return list;
    };
    NDArrayMath.prototype.endScope = function (result) {
        var _this = this;
        var arraysToKeep = this.activeScopeNDArraysToKeep;
        var resultArrays = this.extractNDArraysFromScopeResult(result);
        arraysToKeep = arraysToKeep.concat(resultArrays);
        for (var i = 0; i < this.activeScope.length; i++) {
            var ndarray = this.activeScope[i];
            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                continue;
            }
            ndarray.dispose();
        }
        this.ndarrayScopes.pop();
        this.activeScope = this.ndarrayScopes.length === 0 ?
            null :
            this.ndarrayScopes[this.ndarrayScopes.length - 1];
        resultArrays.forEach(function (val) {
            if (!_this.isNDArrayDataInList(val, _this.activeScopeNDArraysToKeep)) {
                _this.track(val);
            }
        });
        this.ndarraysToKeep.pop();
        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
            null :
            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
    };
    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
        for (var i = 0; i < ndarrayList.length; i++) {
            if (ndarrayList[i].getData() === ndarray.getData()) {
                return true;
            }
        }
        return false;
    };
    NDArrayMath.prototype.keep = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScopeNDArraysToKeep.push(result);
        return result;
    };
    NDArrayMath.prototype.checkForNaN = function (vals, dtype, name) {
        for (var i = 0; i < vals.length; i++) {
            if (util.isValNaN(vals[i], dtype)) {
                throw Error("The result of the last math." + name + " has NaNs.");
            }
        }
    };
    NDArrayMath.prototype.track = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScope.push(result);
        return result;
    };
    NDArrayMath.prototype.dispose = function () { };
    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        var _this = this;
        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + MatrixOrientation[aOrientation]) +
            (" and " + MatrixOrientation[bOrientation] + " must match."));
        return this.executeOp('matMul', function () { return _this.matMulInternal(a, b, aOrientation, bOrientation); });
    };
    NDArrayMath.prototype.executeOp = function (name, f) {
        var start;
        if (this.debugMode) {
            start = performance.now();
        }
        var result = f();
        if (this.debugMode) {
            var vals = result.getValues();
            var time = util.rightPad(performance.now() - start + "ms", 9);
            var paddedName = util.rightPad(name, 25);
            var rank = result.rank;
            var size = result.size;
            var shape = util.rightPad(result.shape.toString(), 14);
            console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
            this.checkForNaN(vals, result.dtype, name);
        }
        return this.track(result);
    };
    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return this.matMul(v.as2D(1, -1), matrix).as1D();
    };
    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return this.matMul(matrix, v.as2D(-1, 1)).as1D();
    };
    NDArrayMath.prototype.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return this.matMul(v1.as2D(1, -1), v2.as2D(-1, 1)).asScalar();
    };
    NDArrayMath.prototype.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return this.matMul(v1.as2D(-1, 1), v2.as2D(1, -1));
    };
    NDArrayMath.prototype.clone = function (ndarray) {
        var _this = this;
        return this.executeOp('clone', function () { return _this.cloneInternal(ndarray); });
    };
    NDArrayMath.prototype.reshape = function (ndarray, newShape) {
        console.warn('math.reshape() is deprecated. Please call reshape() ' +
            'directly on the ndarray object');
        return ndarray.reshape(newShape);
    };
    NDArrayMath.prototype.slice1D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, [begin], [size]);
        return this.executeOp('slice1D', function () { return _this.slice1DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice2D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice2D', function () { return _this.slice2DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice3D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice3D', function () { return _this.slice3DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice4D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice4D', function () { return _this.slice4DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
        var _this = this;
        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
            sourceBegin[1] + sourceSize[1] <= source.shape[1], "Error in copy2D: requested source start position " + sourceBegin + " " +
            ("and source size " + sourceSize + " would overflow source NDArray") +
            ("of shape " + source.shape + "."));
        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
            destBegin[1] + destSize[1] <= dest.shape[1], "Error in copy2D: requested dest start position " + destBegin + " " +
            ("and source size " + destSize + " would overflow dest NDArray of") +
            ("shape " + dest.shape + "."));
        copy2d_util.validateShapes(sourceSize, destSize);
        this.executeOp('copy2D', function () {
            _this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
            return dest;
        });
    };
    NDArrayMath.prototype.concat1D = function (a, b) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, 0);
        return this.executeOp('concat1D', function () { return _this.concat1DInternal(a, b); });
    };
    NDArrayMath.prototype.concat2D = function (a, b, axis) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, axis);
        return this.executeOp('concat2D', function () { return _this.concat2DInternal(a, b, axis); });
    };
    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat3D', function () { return _this.concat3DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.concat4D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat4D', function () { return _this.concat4DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.logSumExp = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        return this.executeOp('logSumExp', function () {
            var xMax = _this.max(input, axes, true);
            var a = _this.subtract(input, xMax);
            var b = _this.exp(a);
            var c = _this.sum(b, axes);
            var d = _this.log(c);
            var res = _this.add(xMax.reshape(d.shape), d);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.sum = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('sum', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.sumInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.mean = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        return this.executeOp('mean', function () {
            return _this.scope(function (keep, track) {
                var res = _this.divide(x, track(ndarray_1.Scalar.new(reduceSize)));
                return _this.sum(res, axis, keepDims);
            });
        });
    };
    NDArrayMath.prototype.argMin = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMin', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMinInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMax = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMax', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMaxInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        var _this = this;
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return this.executeOp('argMaxEquals', function () { return _this.scope(function () {
            return _this.equal(_this.argMax(x1), _this.argMax(x2));
        }); });
    };
    NDArrayMath.prototype.equal = function (x, y) {
        var _this = this;
        return this.executeOp('equal', function () { return _this.equalInternal(x, y); });
    };
    NDArrayMath.prototype.equalStrict = function (x, y) {
        util.assertShapesMatch(x.shape, y.shape, 'Error in equalStrict: ');
        return this.equal(x, y);
    };
    NDArrayMath.prototype.topK = function (ndarray, k) {
        var _this = this;
        util.assert(k <= ndarray.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + ndarray.shape + "."));
        var result;
        this.executeOp('topK', function () {
            result = _this.topKInternal(ndarray, k);
            return result.values;
        });
        this.track(result.indices);
        return result;
    };
    NDArrayMath.prototype.min = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('min', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.minInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.max = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('max', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.maxInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.softmax = function (logits, dim) {
        var _this = this;
        if (dim === void 0) { dim = -1; }
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        return this.executeOp('softmax', function () {
            return _this.scope(function () {
                var lse = _this.logSumExp(logits, [dim], true);
                var logResult = _this.subtract(logits, lse);
                return _this.exp(logResult);
            });
        });
    };
    NDArrayMath.prototype.switchDim = function (a, newDim) {
        return this.transpose(a, newDim);
    };
    NDArrayMath.prototype.tile = function (a, reps) {
        var _this = this;
        util.assert(a.rank === reps.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of reps " + reps + "."));
        return this.executeOp('tile', function () { return _this.tileInternal(a, reps); });
    };
    NDArrayMath.prototype.transpose = function (a, perm) {
        var _this = this;
        if (perm == null) {
            perm = a.shape.map(function (s, i) { return i; }).reverse();
        }
        util.assert(a.rank === perm.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of perm " + perm + "."));
        return this.executeOp('transpose', function () { return _this.transposeInternal(a, perm); });
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.subtract(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.subtract(a, c);
    };
    NDArrayMath.prototype.neg = function (a) {
        var _this = this;
        return this.executeOp('neg', function () { return _this.negInternal(a); });
    };
    NDArrayMath.prototype.add = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('add', function () { return _this.addInternal(a, b); });
    };
    NDArrayMath.prototype.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return this.add(a, b);
    };
    NDArrayMath.prototype.subtract = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('subtract', function () { return _this.subtractInternal(a, b); });
    };
    NDArrayMath.prototype.sub = function (a, b) {
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.multiply = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('multiply', function () { return _this.multiplyInternal(a, b); });
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return this.multiplyStrict(a, b);
    };
    NDArrayMath.prototype.multiplyStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.divide = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('divide', function () { return _this.divideInternal(a, b); });
    };
    NDArrayMath.prototype.divideStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return this.divide(a, b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return this.divide(c, a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return this.divide(a, c);
    };
    NDArrayMath.prototype.ceil = function (ndarray) {
        var _this = this;
        return this.executeOp('ceil', function () { return _this.ceilInternal(ndarray); });
    };
    NDArrayMath.prototype.floor = function (ndarray) {
        var _this = this;
        return this.executeOp('floor', function () { return _this.floorInternal(ndarray); });
    };
    NDArrayMath.prototype.exp = function (ndarray) {
        var _this = this;
        return this.executeOp('exp', function () { return _this.expInternal(ndarray); });
    };
    NDArrayMath.prototype.log = function (ndarray) {
        var _this = this;
        return this.executeOp('log', function () { return _this.logInternal(ndarray); });
    };
    NDArrayMath.prototype.sqrt = function (ndarray) {
        var _this = this;
        return this.executeOp('sqrt', function () { return _this.sqrtInternal(ndarray); });
    };
    NDArrayMath.prototype.square = function (x) {
        var _this = this;
        return this.executeOp('square', function () { return _this.squareInternal(x); });
    };
    NDArrayMath.prototype.abs = function (ndarray) {
        var _this = this;
        return this.executeOp('abs', function () { return _this.absInternal(ndarray); });
    };
    NDArrayMath.prototype.clip = function (ndarray, min, max) {
        var _this = this;
        util.assert((min <= max), "Error in clip: min (" + min + ") must be" +
            ("less than or equal to max (" + max + ")."));
        return this.executeOp('clip', function () { return _this.clipInternal(ndarray, min, max); });
    };
    NDArrayMath.prototype.relu = function (ndarray) {
        var _this = this;
        return this.executeOp('relu', function () { return _this.reluInternal(ndarray); });
    };
    NDArrayMath.prototype.elu = function (ndarray) {
        var _this = this;
        return this.executeOp('elu', function () { return _this.eluInternal(ndarray); });
    };
    NDArrayMath.prototype.leakyRelu = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.2; }
        return this.executeOp('leakyRelu', function () { return _this.leakyReluInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.sigmoid = function (ndarray) {
        var _this = this;
        return this.executeOp('sigmoid', function () { return _this.sigmoidInternal(ndarray); });
    };
    NDArrayMath.prototype.sin = function (ndarray) {
        var _this = this;
        return this.executeOp('sin', function () { return _this.sinInternal(ndarray); });
    };
    NDArrayMath.prototype.cos = function (ndarray) {
        var _this = this;
        return this.executeOp('cos', function () { return _this.cosInternal(ndarray); });
    };
    NDArrayMath.prototype.tan = function (ndarray) {
        var _this = this;
        return this.executeOp('tan', function () { return _this.tanInternal(ndarray); });
    };
    NDArrayMath.prototype.asin = function (ndarray) {
        var _this = this;
        return this.executeOp('asin', function () { return _this.asinInternal(ndarray); });
    };
    NDArrayMath.prototype.acos = function (ndarray) {
        var _this = this;
        return this.executeOp('acos', function () { return _this.acosInternal(ndarray); });
    };
    NDArrayMath.prototype.atan = function (ndarray) {
        var _this = this;
        return this.executeOp('atan', function () { return _this.atanInternal(ndarray); });
    };
    NDArrayMath.prototype.sinh = function (ndarray) {
        var _this = this;
        return this.executeOp('sinh', function () { return _this.sinhInternal(ndarray); });
    };
    NDArrayMath.prototype.cosh = function (ndarray) {
        var _this = this;
        return this.executeOp('cosh', function () { return _this.coshInternal(ndarray); });
    };
    NDArrayMath.prototype.tanh = function (ndarray) {
        var _this = this;
        return this.executeOp('tanh', function () { return _this.tanhInternal(ndarray); });
    };
    NDArrayMath.prototype.step = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.0; }
        return this.executeOp('step', function () { return _this.stepInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var _this = this;
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.executeOp('scaledArrayAdd', function () { return _this.scaledArrayAddInternal(c1, a, c2, b); });
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
        util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
            ("rank 2, but got rank " + a.rank + "."));
        util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
            ("rank 2, but got rank " + b.rank + "."));
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in conv2d: x must be rank 3, but got rank " + x.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        util.assert(x.shape[2] === filter.shape[2], "Error in conv2d: depth of input (" + x.shape[2] + ") must match  " +
            ("input depth for filter " + filter.shape[2] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2d', function () { return _this.conv2dInternal(x, filter, bias, convInfo); });
    };
    NDArrayMath.prototype.conv2dBackProp = function (x, dy, filter, strides, pad) {
        var dw = this.conv2dDerFilter(x, dy, filter.shape, strides, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dDerInput(x.shape, dy, filter, strides, pad);
        return { db: db, dw: dw, dx: dx };
    };
    NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {
        var _this = this;
        var inDepth = inShape[2];
        var outDepth = dy.shape[2];
        util.assert(inShape.length === 3, "Error in conv2dDerInput: x must be rank 3, but got rank " +
            (inShape.length + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerInput: dy must be rank 3, but got " +
            ("rank " + dy.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
            ("match output depth for filter " + filter.shape[3] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2dDerInput', function () { return _this.conv2dDerInputInternal(dy, filter, convInfo); });
    };
    NDArrayMath.prototype.conv2dDerBias = function (dy) {
        return this.track(this.conv2dDerBiasInternal(dy));
    };
    NDArrayMath.prototype.conv2dDerFilter = function (x, dy, filterSize, strides, pad) {
        util.assert(x.rank === 3, "Error in conv2dDerFilter: x must be rank 3, but got shape " +
            (x.shape + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerFilter: dy must be rank 3, but got shape " +
            (dy.shape + "."));
        util.assert(filterSize.length === 4, "Error in conv2dDerFilter: filterSize must be length 4, but got " +
            (filterSize + "."));
        util.assert(x.shape[2] === filterSize[2], "Error in conv2dDerFilter: depth of x " + x.shape[2] + ") must " +
            ("match input depth in filter (" + filterSize[2] + "."));
        util.assert(dy.shape[2] === filterSize[3], "Error in conv2dDerFilter: depth of dy (" + dy.shape[2] + ") must " +
            ("match output depth for filter (" + filterSize[3] + ")."));
        var filterHeight = filterSize[0];
        var filterWidth = filterSize[1];
        var outDepth = filterSize[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.track(this.conv2dDerFilterInternal(x, dy, convInfo));
    };
    NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {
        return this.conv2dDerInput(outputShape, x, filter, strides, pad);
    };
    NDArrayMath.prototype.depthwiseConv2D = function (input, filter, strides, pad, rates) {
        var _this = this;
        if (rates === void 0) { rates = [1, 1]; }
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
            ("rank " + input4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
            ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        rates = rates || [1, 1];
        var _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
        util.assert(rateHeight === 1 && rateWidth === 1, 'Error in depthwiseConv2D: rates greater than 1 are not yet ' +
            ("supported. Got rates '" + rates + "'"));
        var convInfo = conv_util.computeDepthwiseConv2DInfo(input4D.shape, filter.shape, strides, pad);
        return this.executeOp('depthwiseConv2D', function () {
            var res = _this.depthwiseConv2DInternal(input4D, filter, convInfo);
            if (reshapedTo4D) {
                return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
            }
            return res;
        });
    };
    NDArrayMath.prototype.maxPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in maxPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPool', function () { return _this.maxPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, filterSize, strides, pad) {
        var _this = this;
        util.assert(dy.rank === 3, "Error in maxPoolBackprop: dy must be rank 3 but got rank " +
            (dy.rank + "."));
        util.assert(x.rank === 3, "Error in maxPoolBackprop: x must be rank 3 but got rank " +
            (x.rank + "."));
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPoolBackprop', function () { return _this.maxPoolBackpropInternal(dy, x, convInfo); });
    };
    NDArrayMath.prototype.minPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in minPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('minPool', function () { return _this.minPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.avgPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in avgPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('avgPool', function () { return _this.avgPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        var _this = this;
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
        util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
            (newShape2D + "."));
        return this.executeOp('resizeBilinear3D', function () { return _this.resizeBilinear3DInternal(x, newShape2D, alignCorners); });
    };
    NDArrayMath.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm2D', function () { return _this.batchNormalization2DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm3D', function () { return _this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
        var res = this.scope(function () {
            var input = data;
            var newStates = [];
            for (var i = 0; i < lstmCells.length; i++) {
                var output = lstmCells[i](input, c[i], h[i]);
                newStates.push(output[0]);
                newStates.push(output[1]);
                input = output[1];
            }
            return newStates;
        });
        var newC = [];
        var newH = [];
        for (var i = 0; i < res.length; i += 2) {
            newC.push(res[i]);
            newH.push(res[i + 1]);
        }
        return [newC, newH];
    };
    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var _this = this;
        var res = this.scope(function () {
            var combined = _this.concat2D(data, h, 1);
            var weighted = _this.matMul(combined, lstmKernel);
            var res = _this.add(weighted, lstmBias);
            var batchSize = res.shape[0];
            var sliceCols = res.shape[1] / 4;
            var sliceSize = [batchSize, sliceCols];
            var i = _this.slice2D(res, [0, 0], sliceSize);
            var j = _this.slice2D(res, [0, sliceCols], sliceSize);
            var f = _this.slice2D(res, [0, sliceCols * 2], sliceSize);
            var o = _this.slice2D(res, [0, sliceCols * 3], sliceSize);
            var newC = _this.addStrict(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
            return [newC, newH];
        });
        return [res[0], res[1]];
    };
    NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {
        var _this = this;
        var numOutcomes = probabilities.size;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (probabilities.rank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + probabilities.rank);
        }
        seed = seed || Math.random();
        var origRank = probabilities.rank;
        if (probabilities.rank === 1) {
            probabilities = probabilities.as2D(1, -1);
        }
        return this.executeOp('multinomial', function () {
            var res = _this.multinomialInternal(probabilities, numSamples, seed);
            if (origRank === 1) {
                return res.as1D();
            }
            return res;
        });
    };
    NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var _this = this;
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return this.executeOp('oneHot', function () { return _this.oneHotInternal(indices, depth, onValue, offValue); });
    };
    NDArrayMath.prototype.moments = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var result = this.scope(function () {
            var mean = _this.mean(x, axes, keepDims);
            var keepDimsShape = mean.shape;
            if (!keepDims) {
                keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
            }
            var devSquared = _this.square(_this.subtract(x, mean.reshape(keepDimsShape)));
            var variance = _this.mean(devSquared, axes, keepDims);
            return { mean: mean, variance: variance };
        });
        return result;
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}

},{"../util":89,"./axis_util":47,"./broadcast_util":48,"./concat_util":49,"./conv_util":50,"./copy2d_util":51,"./ndarray":56,"./slice_util":58}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var util = require("../util");
var axis_util = require("./axis_util");
var broadcast_util = require("./broadcast_util");
var concat_util = require("./concat_util");
var conv_util = require("./conv_util");
var copy2D_util = require("./copy2d_util");
var math_1 = require("./math");
var ndarray_1 = require("./ndarray");
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, safeMode) || this;
    }
    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });
    };
    NDArrayMathCPU.prototype.slice1DInternal = function (input, begin, size) {
        var newVals = input.getValues().slice(begin, begin + size);
        return ndarray_1.Array1D.new(newVals);
    };
    NDArrayMathCPU.prototype.slice2DInternal = function (input, begin, size) {
        var result = ndarray_1.Array2D.zeros(size);
        var startI = begin[0], startJ = begin[1];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                var val = input.get(i + startI, j + startJ);
                result.set(val, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice3DInternal = function (input, begin, size) {
        var result = ndarray_1.Array3D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    var val = input.get(i + startI, j + startJ, k + startK);
                    result.set(val, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice4DInternal = function (input, begin, size) {
        var result = ndarray_1.Array4D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    for (var l = 0; l < size[3]; ++l) {
                        var val = input.get(i + startI, j + startJ, k + startK, l + startL);
                        result.set(val, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
        var srcValues = source.getValues();
        var dstValues = dest.getValues();
        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
        for (var i = 0; i < n; ++i) {
            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
            var srcOff = srcRow * source.shape[1] + srcCol;
            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
            var dstOff = dstRow * dest.shape[1] + dstCol;
            dstValues[dstOff] = srcValues[srcOff];
        }
    };
    NDArrayMathCPU.prototype.concat1DInternal = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 0);
        var result = ndarray_1.Array1D.zeros(outShape);
        var aVals = a.getValues();
        var bVals = b.getValues();
        var vals = result.getValues();
        vals.set(aVals, 0);
        vals.set(bVals, a.size);
        return result;
    };
    NDArrayMathCPU.prototype.concat2DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array2D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                var index = [i, j];
                var value = void 0;
                if (index[axis] < a.shape[axis]) {
                    value = a.get(i, j);
                }
                else {
                    index[axis] -= a.shape[axis];
                    var i2 = index[0], j2 = index[1];
                    value = b.get(i2, j2);
                }
                result.set(value, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat3DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array3D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    var index = [i, j, k];
                    var value = void 0;
                    if (index[axis] < a.shape[axis]) {
                        value = a.get(i, j, k);
                    }
                    else {
                        index[axis] -= a.shape[axis];
                        var i2 = index[0], j2 = index[1], k2 = index[2];
                        value = b.get(i2, j2, k2);
                    }
                    result.set(value, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat4DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array4D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    for (var l = 0; l < outShape[3]; ++l) {
                        var index = [i, j, k, l];
                        var value = void 0;
                        if (index[axis] < a.shape[axis]) {
                            value = a.get(i, j, k, l);
                        }
                        else {
                            index[axis] -= a.shape[axis];
                            var i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];
                            value = b.get(i2, j2, k2, l2);
                        }
                        result.set(value, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var c1Val = c1.get();
        var c2Val = c2.get();
        return this.broadcastedBinaryOp(a, b, 'float32', function (aVal, bVal) {
            return c1Val * aVal + c2Val * bVal;
        });
    };
    NDArrayMathCPU.prototype.negInternal = function (a) {
        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
    };
    NDArrayMathCPU.prototype.addInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
    };
    NDArrayMathCPU.prototype.subtractInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
    };
    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.divideInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] / bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues }, 'float32');
    };
    NDArrayMathCPU.prototype.sumInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = math_1.SumTypesMap[input.dtype];
        var result = ndarray_1.NDArray.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMinInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    minIndex = util.NAN_INT32;
                    break;
                }
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMaxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    maxIndex = util.NAN_INT32;
                    break;
                }
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.equalInternal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal === bVal) ? 1 : 0;
            }
        });
    };
    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
        var values = ndarray.getValues();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = new Float32Array(k);
        var topkIndices = new Float32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };
    };
    NDArrayMathCPU.prototype.minInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    min = Number.NaN;
                    break;
                }
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    NDArrayMathCPU.prototype.maxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    max = Number.NaN;
                    break;
                }
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    NDArrayMathCPU.prototype.ceilInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.floorInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.expInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.sqrtInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.squareInternal = function (x) {
        var values = x.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.reluInternal = function (input) {
        var res = ndarray_1.NDArray.zeros(input.shape, input.dtype);
        var resVals = res.getValues();
        var inVals = input.getValues();
        for (var i = 0; i < inVals.length; ++i) {
            var val = inVals[i];
            if (util.isValNaN(val, input.dtype)) {
                resVals[i] = util.getNaN(res.dtype);
            }
            else {
                resVals[i] = Math.max(0, inVals[i]);
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.eluInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.leakyReluInternal = function (ndarray, alpha) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alpha * v;
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.clipInternal = function (ndarray, min, max) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.absInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.cosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.asinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.acosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.atanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.coshInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.stepInternal = function (ndarray, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            resultValues[i] = value > 0 ? 1 : (value < 0 ? alpha : value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        for (var d2 = 0; d2 < outDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * convInfo.strideHeight - padLeft;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * convInfo.strideWidth - padTop;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            for (var d1 = 0; d1 < inputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = filter.get(wR, wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var biasVal = (bias != null) ? bias.get(d2) : 0;
                    y.set(dotProd + biasVal, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var inDepth = filter.shape[2];
        var outDepth = filter.shape[3];
        var yRows = dy.shape[0];
        var yCols = dy.shape[1];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dx = ndarray_1.Array3D.zeros(convInfo.inShape);
        for (var d1 = 0; d1 < inDepth; ++d1) {
            for (var xR = 0; xR < dx.shape[0]; ++xR) {
                var xRCorner = xR - leftPad;
                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                var yRMax = Math.min(yRows, (filterHeight + xRCorner) / strideHeight);
                for (var xC = 0; xC < dx.shape[1]; ++xC) {
                    var xCCorner = xC - topPad;
                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                    var yCMax = Math.min(yCols, (filterWidth + xCCorner) / strideWidth);
                    var dotProd = 0;
                    for (var yR = xRMin; yR < yRMax; ++yR) {
                        var wR = yR * strideHeight - xRCorner;
                        for (var yC = xCMin; yC < yCMax; ++yC) {
                            var wC = yC * strideWidth - xCCorner;
                            for (var d2 = 0; d2 < outDepth; ++d2) {
                                var pixel = dy.get(yR, yC, d2);
                                var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    dx.set(dotProd, xR, xC, d1);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth);
        var dW = ndarray_1.Array4D.zeros(weightsShape);
        var yNumRows = dY.shape[0];
        var yNumCols = dY.shape[1];
        var xNumRows = x.shape[0];
        var xNumCols = x.shape[1];
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(yNumRows, (xNumRows + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(yNumCols, (xNumCols + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < inputDepth; ++d1) {
                    for (var d2 = 0; d2 < outputDepth; ++d2) {
                        var dotProd = 0;
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    NDArrayMathCPU.prototype.conv2dDerBiasInternal = function (dY) {
        var outputDepth = dY.shape[2];
        var numRows = dY.shape[0];
        var numCols = dY.shape[1];
        var values = new Float32Array(outputDepth);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            var sum = 0;
            for (var r = 0; r < numRows; ++r) {
                for (var c = 0; c < numCols; ++c) {
                    sum += dY.get(r, c, d2);
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    NDArrayMathCPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var _a = convInfo.inShape, numBatches = _a[0], xRows = _a[1], xCols = _a[2], inChannels = _a[3];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var yRows = convInfo.outShape[1];
        var yCols = convInfo.outShape[2];
        var chMul = convInfo.channelMul;
        var y = ndarray_1.Array4D.zeros(convInfo.outShape);
        for (var b = 0; b < numBatches; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var yR = 0; yR < yRows; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(xRows, filterHeight + xRCorner);
                    for (var yC = 0; yC < yCols; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(xCols, filterWidth + xCCorner);
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var xR = xRMin; xR < xRMax; ++xR) {
                                var wR = xR - xRCorner;
                                for (var xC = xCMin; xC < xCMax; ++xC) {
                                    var wC = xC - xCCorner;
                                    var pixel = input.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.tileInternal = function (a, reps) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[i] * reps[i];
        }
        var dtype;
        if (a.dtype === 'float32') {
            dtype = Float32Array;
        }
        else if (a.dtype === 'int32') {
            dtype = Int32Array;
        }
        else if (a.dtype === 'bool') {
            dtype = Uint8Array;
        }
        else {
            throw new Error("Dtype " + a.dtype + " not supported for tile");
        }
        var resultValues = new dtype(util.sizeFromShape(newShape));
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues }, a.dtype);
        var values = a.getValues();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(a.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % a.shape[i_1];
            }
            var originalIndex = a.locToIndex(originalLoc);
            resultValues[i] = values[originalIndex];
        }
        return result;
    };
    NDArrayMathCPU.prototype.transposeInternal = function (a, perm) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[perm[i]];
        }
        var resultValues = new Float32Array(a.size);
        var values = a.getValues();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < a.size; ++i) {
            var loc = a.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    NDArrayMathCPU.prototype.pool = function (x, convInfo, poolType) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                        Number.POSITIVE_INFINITY);
                    var avgValue = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var pixel = x.get(xR, xC, d);
                            if (isNaN(pixel)) {
                                minMaxValue = NaN;
                                avgValue = NaN;
                                break;
                            }
                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                (poolType === 'min' && pixel < minMaxValue)) {
                                minMaxValue = pixel;
                            }
                            else if (poolType === 'avg') {
                                avgValue += pixel / (filterHeight * filterWidth);
                            }
                        }
                        if (isNaN(minMaxValue)) {
                            break;
                        }
                    }
                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.maxPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    NDArrayMathCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = convInfo.outShape;
        var maxPositions = ndarray_1.Array3D.zeros(outputShape);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < outputShape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < outputShape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var maxValue = Number.NEGATIVE_INFINITY;
                    var maxPosition = -1;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            var pixel = x.get(xR, xC, d);
                            if (pixel > maxValue) {
                                maxValue = pixel;
                                maxPosition = wR * filterWidth + wC;
                            }
                        }
                    }
                    maxPositions.set(maxPosition, yR, yC, d);
                }
            }
        }
        return maxPositions;
    };
    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
        var dx = ndarray_1.Array3D.zeros(x.shape);
        for (var d = 0; d < depth; ++d) {
            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {
                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {
                    var dyRCorner = dxR - padTop;
                    var dyCCorner = dxC - padLeft;
                    var dotProd = 0;
                    for (var wR = 0; wR < filterHeight; ++wR) {
                        var dyR = (dyRCorner + wR) / strideHeight;
                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
                            continue;
                        }
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var dyC = (dyCCorner + wC) / strideWidth;
                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
                                continue;
                            }
                            var maxPos = filterHeight * filterWidth - 1 -
                                maxPositions.get(dyR, dyC, d);
                            var curPos = wR * filterWidth + wC;
                            var mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) {
                                continue;
                            }
                            var pixel = dy.get(dyR, dyC, d);
                            dotProd += pixel * mask;
                        }
                    }
                    dx.set(dotProd, dxR, dxC, d);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.minPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'min');
    };
    NDArrayMathCPU.prototype.avgPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg');
    };
    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
        var effectiveOutputSize = alignCorners ?
            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
            output.shape;
        for (var r = 0; r < output.shape[0]; r++) {
            for (var c = 0; c < output.shape[1]; c++) {
                for (var d = 0; d < output.shape[2]; d++) {
                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                    var sourceRowFloor = Math.floor(sourceFracRow);
                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                    var rowFrac = sourceFracRow - sourceRowFloor;
                    var colFrac = sourceFracCol - sourceColFloor;
                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                    output.set(newValue, r, c, d);
                }
            }
        }
        return output;
    };
    NDArrayMathCPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array2D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array3D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.multinomialInternal = function (probabilities, numSamples, seed) {
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ndarray_1.Array2D.zeros([batchSize, numSamples], 'int32');
        var resVals = res.getValues();
        var probVals = probabilities.getValues();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ndarray_1.Array2D.new([indices.size, depth], res);
    };
    NDArrayMathCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ndarray_1.NDArray.zeros(newShape, dtype);
        var newValues = result.getValues();
        var aValues = a.getValues();
        var bValues = b.getValues();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var _loop_1 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = a.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = b.locToIndex(bLoc);
            newValues[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < newValues.length; ++i) {
            _loop_1(i);
        }
        return result;
    };
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../util":89,"./axis_util":47,"./broadcast_util":48,"./concat_util":49,"./conv_util":50,"./copy2d_util":51,"./math":53,"./ndarray":56,"seedrandom":91}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var axis_util = require("./axis_util");
var math_1 = require("./math");
var ndarray = require("./ndarray");
var ndarray_1 = require("./ndarray");
var reduce_util = require("./reduce_util");
var addscaledmat_gpu_1 = require("./webgl/addscaledmat_gpu");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var copy_gpu_1 = require("./webgl/copy_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = _super.call(this, safeMode) || this;
        _this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            _this.gpgpuCreatedLocally = true;
        }
        else {
            _this.gpgpu = gpgpu;
            _this.gpgpuCreatedLocally = false;
        }
        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    NDArrayMathGPU.prototype.cloneInternal = function (a) {
        var texShape = a.getTextureShapeRC();
        var source = a.as2D(texShape[0], texShape[1]);
        var output = this.makeOutputArray(texShape, a.dtype);
        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
        return output.reshape(a.shape);
    };
    NDArrayMathGPU.prototype.slice1DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram([size]);
        var customSetup = program.getCustomSetupFunc([begin]);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice2DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice3DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice4DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
        this.compileAndRun(program, [source], dest, customSetup);
    };
    NDArrayMathGPU.prototype.concat1DInternal = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat2DInternal = function (a, b, axis) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.concat4DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b, c1, c2]);
    };
    NDArrayMathGPU.prototype.negInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.makeOutputArray = function (shape, dtype) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC }, dtype);
    };
    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output, customSetup);
        return output;
    };
    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.tileInternal = function (a, reps) {
        var program = new tile_gpu_1.TileProgram(a.shape, reps);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.transposeInternal = function (a, perm) {
        var program = new transpose_gpu_1.TransposeProgram(a.shape, perm);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.reduce = function (a, reduceType, dtype) {
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
        this.compileAndRun(program, [a], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    NDArrayMathGPU.prototype.argReduce = function (a, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
        var inputs = [a];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(a, reduceType, output);
    };
    NDArrayMathGPU.prototype.sumInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        var outputDType = math_1.SumTypesMap[a.dtype];
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMinInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMaxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    NDArrayMathGPU.prototype.equalInternal = function (x, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, x.shape, y.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [x, y], output);
    };
    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
        throw new Error('topK GPU not yet implemented!');
    };
    NDArrayMathGPU.prototype.minInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.maxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.divideInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    NDArrayMathGPU.prototype.addInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.subtractInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.ceilInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.CEIL);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.floorInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.expInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.logInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sqrtInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.squareInternal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.reluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.eluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.leakyReluInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.clipInternal = function (a, min, max) {
        var program = new clip_gpu_1.ClipProgram(a.shape, min, max);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.absInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.cosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.asinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.acosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.atanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.coshInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.stepInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
        var inputs = bias != null ? [x, filter, bias] : [x, filter];
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    NDArrayMathGPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);
        return this.compileAndRun(program, [x, dY]);
    };
    NDArrayMathGPU.prototype.conv2dDerBiasInternal = function (dY) {
        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);
        return this.compileAndRun(program, [dY]);
    };
    NDArrayMathGPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [input, filter]);
    };
    NDArrayMathGPU.prototype.maxPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.minPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.avgPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
        maxPoolPositions.dispose();
        return result;
    };
    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.multinomialInternal = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    NDArrayMathGPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    NDArrayMathGPU.prototype.dispose = function () {
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;

},{"../util":89,"./axis_util":47,"./math":53,"./ndarray":56,"./reduce_util":57,"./webgl/addscaledmat_gpu":59,"./webgl/argminmax_gpu":60,"./webgl/batchnorm_gpu":61,"./webgl/binaryop_gpu":62,"./webgl/clip_gpu":63,"./webgl/concat_gpu":64,"./webgl/conv_backprop_gpu":65,"./webgl/conv_gpu":66,"./webgl/conv_gpu_depthwise":67,"./webgl/copy_gpu":68,"./webgl/gpgpu_context":69,"./webgl/gpgpu_math":70,"./webgl/gpgpu_util":71,"./webgl/max_pool_backprop_gpu":72,"./webgl/mulmat_gpu":73,"./webgl/multinomial_gpu":74,"./webgl/onehot_gpu":75,"./webgl/pool_gpu":76,"./webgl/reduce_gpu":77,"./webgl/resize_bilinear_gpu":79,"./webgl/slice_gpu":81,"./webgl/texture_manager":83,"./webgl/tile_gpu":84,"./webgl/transpose_gpu":85,"./webgl/unaryop_gpu":86,"./webgl/webgl_util":87}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var tex_util_1 = require("./webgl/tex_util");
var webgl_util = require("./webgl/webgl_util");
exports.GPGPU = null;
exports.TEXTURE_MANAGER = null;
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
function initializeGPU(gpgpu, textureManager) {
    exports.GPGPU = gpgpu;
    exports.TEXTURE_MANAGER = textureManager;
}
exports.initializeGPU = initializeGPU;
function throwIfGPUNotInitialized() {
    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
        throw new Error('GPU not intialized.');
    }
}
var NDArray = (function () {
    function NDArray(shape, data, dtype) {
        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');
        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');
        this.size = util.sizeFromShape(shape);
        if (data.values != null) {
            util.assert(this.size === data.values.length, "Constructing ndarray of shape (" + this.size + ") should match the " +
                ("length of values (" + data.values.length + ")"));
        }
        this.shape = shape;
        if (data.textureType == null) {
            data.textureType = tex_util_1.TextureType.DEFAULT;
        }
        this.ndarrayData = data;
        this.dtype = dtype || 'float32';
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
    }
    NDArray.zeros = function (shape, dtype) {
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return NDArray.make(shape, { values: values }, dtype);
    };
    NDArray.zerosLike = function (another) {
        return NDArray.zeros(another.shape, another.dtype);
    };
    NDArray.like = function (another) {
        var newValues = copyTypedArray(another.getValues(), another.dtype);
        return NDArray.make(another.shape, { values: newValues }, another.dtype);
    };
    NDArray.make = function (shape, data, dtype) {
        if (data.isDisposed) {
            throw new Error("Cannot make new NDArray from disposed NDArrayData.");
        }
        switch (shape.length) {
            case 0:
                return new Scalar(data, dtype);
            case 1:
                return new Array1D(data, dtype);
            case 2:
                return new Array2D(shape, data, dtype);
            case 3:
                return new Array3D(shape, data, dtype);
            case 4:
                return new Array4D(shape, data, dtype);
            default:
                return new NDArray(shape, data, dtype);
        }
    };
    NDArray.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');
        }
        var shape = [pixels.height, pixels.width, numChannels];
        var textureShapeRC = [shape[0], shape[1]];
        var texture = exports.TEXTURE_MANAGER.acquireTexture(textureShapeRC);
        var textureType = tex_util_1.TextureType.RGBA_COLOR;
        exports.GPGPU.uploadPixelDataToTexture(texture, pixels);
        return Array3D.make(shape, { texture: texture, textureShapeRC: textureShapeRC, textureType: textureType });
    };
    NDArray.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        newShape = util.inferFromImplicitShape(newShape, this.size);
        if (util.arraysEqual(this.shape, newShape)) {
            return this;
        }
        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        return NDArray.make(newShape, this.ndarrayData, this.dtype);
    };
    NDArray.prototype.flatten = function () {
        if (this instanceof Array1D) {
            return this;
        }
        return this.as1D();
    };
    NDArray.prototype.asScalar = function () {
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        return this.reshape([rows, columns, depth, depth2]);
    };
    NDArray.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        var newData = this.getData();
        if (newData.values != null) {
            newData = { values: toTypedArray(newData.values, dtype) };
        }
        return NDArray.make(this.shape, newData, dtype);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            this.throwIfDisposed();
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.getValues()[index];
    };
    NDArray.prototype.add = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        this.getValues()[index] = value;
    };
    NDArray.prototype.val = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwIfDisposed();
                        return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get.apply(this, locs)];
                }
            });
        });
    };
    NDArray.prototype.locToIndex = function (locs) {
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.throwIfDisposed();
        this.getValues().fill(value);
    };
    NDArray.prototype.getData = function () {
        return this.ndarrayData;
    };
    NDArray.prototype.getValues = function () {
        return this.dataSync();
    };
    NDArray.prototype.getValuesAsync = function () {
        return this.data();
    };
    NDArray.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, queryFn;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.throwIfDisposed();
                        if (this.ndarrayData.values != null) {
                            return [2, this.ndarrayData.values];
                        }
                        if (!(environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') &&
                            this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT)) return [3, 2];
                        _a = this.ndarrayData;
                        return [4, exports.GPGPU.downloadMatrixFromTextureAsync(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1])];
                    case 1:
                        _a.values = _b.sent();
                        return [2, this.ndarrayData.values];
                    case 2:
                        if (!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) return [3, 4];
                        return [4, this.dataSync()];
                    case 3: return [2, _b.sent()];
                    case 4:
                        queryFn = function () { };
                        return [4, exports.GPGPU.runQuery(queryFn)];
                    case 5:
                        _b.sent();
                        return [2, this.dataSync()];
                }
            });
        });
    };
    NDArray.prototype.dataSync = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.values == null) {
            throwIfGPUNotInitialized();
            var values = void 0;
            if (this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT) {
                values = exports.GPGPU.downloadMatrixFromTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1]);
            }
            else {
                values = exports.GPGPU.downloadMatrixFromRGBAColorTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], this.shape[2]);
            }
            this.ndarrayData.values = float32ToTypedArray(values, this.dtype);
            this.disposeTexture();
        }
        return this.ndarrayData.values;
    };
    NDArray.prototype.uploadToGPU = function () {
        throwIfGPUNotInitialized();
        this.throwIfDisposed();
        this.ndarrayData.textureShapeRC =
            webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape);
        this.ndarrayData.texture =
            exports.TEXTURE_MANAGER.acquireTexture(this.ndarrayData.textureShapeRC);
        this.ndarrayData.textureType = tex_util_1.TextureType.DEFAULT;
        exports.GPGPU.uploadMatrixToTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], typedArrayToFloat32(this.ndarrayData.values, this.dtype));
        this.ndarrayData.values = null;
    };
    NDArray.prototype.getTexture = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.texture == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.texture;
    };
    NDArray.prototype.getTextureShapeRC = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.textureShapeRC == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.textureShapeRC;
    };
    NDArray.prototype.throwIfDisposed = function () {
        if (this.ndarrayData.isDisposed) {
            throw new Error("NDArray is disposed.");
        }
    };
    NDArray.prototype.dispose = function () {
        this.ndarrayData.values = null;
        this.shape = null;
        this.ndarrayData.isDisposed = true;
        if (this.ndarrayData.texture != null) {
            this.disposeTexture();
        }
    };
    NDArray.prototype.disposeTexture = function () {
        throwIfGPUNotInitialized();
        exports.TEXTURE_MANAGER.releaseTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC);
        this.ndarrayData.texture = null;
        this.ndarrayData.textureShapeRC = null;
        this.ndarrayData.textureType = null;
    };
    NDArray.prototype.inGPU = function () {
        this.throwIfDisposed();
        return this.ndarrayData.texture != null;
    };
    NDArray.prototype.equals = function (t) {
        this.throwIfDisposed();
        return this.dtype === t.dtype && util.arraysEqual(this.shape, t.shape) &&
            util.arraysEqual(this.getValues(), t.getValues());
    };
    NDArray.rand = function (shape, randFunction) {
        var size = util.sizeFromShape(shape);
        var values = new Float32Array(size);
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return NDArray.make(shape, { values: values });
    };
    NDArray.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    NDArray.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar(data, dtype) {
        var _this = this;
        if (data.texture != null) {
            data.textureShapeRC = [1, 1];
        }
        _this = _super.call(this, [], data, dtype) || this;
        return _this;
    }
    Scalar.new = function (value, dtype) {
        var values = [value];
        return new Scalar({ values: toTypedArray(values, dtype) }, dtype);
    };
    Scalar.prototype.get = function () {
        return this.getValues()[0];
    };
    Scalar.prototype.val = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get()];
                }
            });
        });
    };
    Scalar.prototype.set = function (value) {
        this.getValues()[0] = value;
    };
    Scalar.prototype.add = function (value) {
        this.getValues()[0] += value;
    };
    Scalar.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Scalar.prototype.locToIndex = function (loc) {
        return 0;
    };
    Scalar.prototype.indexToLoc = function (index) {
        return [];
    };
    Scalar.ZERO = Scalar.new(0);
    Scalar.ONE = Scalar.new(1);
    Scalar.TWO = Scalar.new(2);
    Scalar.NEG_ONE = Scalar.new(-1);
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D(data, dtype) {
        var _this = this;
        var shape = (data.values != null) ?
            [data.values.length] :
            [util.sizeFromShape(data.textureShapeRC)];
        _this = _super.call(this, shape, data, dtype) || this;
        return _this;
    }
    Array1D.new = function (values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D({ values: toTypedArray(values, dtype) }, dtype);
    };
    Array1D.prototype.get = function (i) {
        return this.getValues()[i];
    };
    Array1D.prototype.set = function (value, i) {
        this.getValues()[i] = value;
    };
    Array1D.prototype.val = function (i) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i)];
                }
            });
        });
    };
    Array1D.prototype.add = function (value, i) {
        this.getValues()[i] += value;
    };
    Array1D.prototype.locToIndex = function (loc) {
        return loc[0];
    };
    Array1D.prototype.indexToLoc = function (index) {
        return [index];
    };
    Array1D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array1D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array1D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array1D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array1D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 2, 'Shape should be of length 2');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        return _this;
    }
    Array2D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array2D.prototype.get = function (i, j) {
        return this.getValues()[this.stride0 * i + j];
    };
    Array2D.prototype.set = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] = value;
    };
    Array2D.prototype.add = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] += value;
    };
    Array2D.prototype.val = function (i, j) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j)];
                }
            });
        });
    };
    Array2D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + locs[1];
    };
    Array2D.prototype.indexToLoc = function (index) {
        return [Math.floor(index / this.stride0), index % this.stride0];
    };
    Array2D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array2D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array2D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array2D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array2D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 3, 'Shape should be of length 3');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        return _this;
    }
    Array3D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array3D.prototype.get = function (i, j, k) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + k];
    };
    Array3D.prototype.set = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
    };
    Array3D.prototype.val = function (i, j, k) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k)];
                }
            });
        });
    };
    Array3D.prototype.add = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
    };
    Array3D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
    };
    Array3D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        return [i, Math.floor(index / this.stride1), index % this.stride1];
    };
    Array3D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array3D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array3D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array3D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array3D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 4, 'Shape should be of length 4');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        _this.stride2 = _this.strides[2];
        return _this;
    }
    Array4D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array4D.prototype.get = function (i, j, k, l) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
    };
    Array4D.prototype.set = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
    };
    Array4D.prototype.val = function (i, j, k, l) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k, l)];
                }
            });
        });
    };
    Array4D.prototype.add = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
    };
    Array4D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] +
            this.stride2 * locs[2] + locs[3];
    };
    Array4D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        var j = Math.floor(index / this.stride1);
        index -= j * this.stride1;
        return [i, j, Math.floor(index / this.stride2), index % this.stride2];
    };
    Array4D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array4D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array4D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array4D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array4D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            var val = array[i];
            if (util.isValNaN(val, 'bool')) {
                bool[i] = util.getNaN('bool');
            }
            else if (val) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function instanceofTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return copyTypedArray(a, dtype);
}
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    if (a instanceof Float32Array) {
        return a;
    }
    else {
        var res = new Float32Array(a.length);
        for (var i = 0; i < res.length; i++) {
            var val = a[i];
            res[i] = util.isValNaN(val, dtype) ? NaN : val;
        }
        return res;
    }
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            var val = a[i];
            val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
            result[i] = val;
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}

},{"../environment":8,"../util":89,"./webgl/tex_util":82,"./webgl/webgl_util":87}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;

},{"../util":89}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
var AddScaledMatProgram = (function () {
    function AddScaledMatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B', 'c1', 'c2'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        float c1 = getC1();\n        float c2 = getC2();\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\n      }\n    ";
    }
    return AddScaledMatProgram;
}());
exports.AddScaledMatProgram = AddScaledMatProgram;

},{"../broadcast_util":48}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../broadcast_util":48}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.EQUAL = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../broadcast_util":48}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../concat_util");
var shader_compiler_1 = require("./shader_compiler");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape, axis) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        var yAxes = ['yR', 'yC', 'yD', 'yW'];
        var concatAxis = yAxes[axis];
        this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);
        var dType = shader_compiler_1.getCoordsDataType(aShape.length);
        var unpackSnippet = getUnpack(aShape.length);
        var sampleCoords = getSampleCoords(aShape.length);
        this.userCode = "\n      void main() {\n        " + dType + " coords = getOutputCoords();\n        " + unpackSnippet + "\n\n        float value = 0.0;\n        if (" + concatAxis + " < " + aShape[axis] + ") {\n          value = getA(" + sampleCoords + ");\n        } else {\n          " + concatAxis + " -= " + aShape[axis] + ";\n          value = getB(" + sampleCoords + ");\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;
function getSampleCoords(rank) {
    if (rank === 1) {
        return 'yR';
    }
    else if (rank === 2) {
        return 'yR, yC';
    }
    else if (rank === 3) {
        return 'yR, yC, yD';
    }
    else if (rank === 4) {
        return 'yR, yC, yD, yW';
    }
    else {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
}
function getUnpack(rank) {
    var res = rank === 1 ? 'int yR = coords;' : 'int yR = coords.x;';
    if (rank > 1) {
        res += '\nint yC = coords.y;';
    }
    if (rank > 2) {
        res += '\nint yD = coords.z;';
    }
    if (rank > 3) {
        res += '\nint yW = coords.w;';
    }
    if (rank > 4) {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
    return res;
}

},{"../concat_util":49,"./shader_compiler":80}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
var Conv2DDerWeightsProgram = (function () {
    function Conv2DDerWeightsProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        var _a = convInfo.outShape, yNumRows = _a[0], yNumCols = _a[1], outDepth = _a[2];
        var _b = convInfo.inShape, xNumRows = _b[0], xNumCols = _b[1], inDepth = _b[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        this.outputShape = conv_util.computeWeightsShape4D(inDepth, outDepth, convInfo.filterHeight, convInfo.filterWidth);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float dyValue = getDy(yR, yC, d2);\n            float xValue = getX(xR, xC, d1);\n            dotProd += (xValue * dyValue);\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerWeightsProgram;
}());
exports.Conv2DDerWeightsProgram = Conv2DDerWeightsProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        var _a = convInfo.outShape, yRows = _a[0], yCols = _a[1], outDepth = _a[2];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d1 = coords.z;\n\n        ivec2 dyCorner = coords.xy - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + yRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + yCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + outDepth + "; d2++) {\n              float xValue = getDy(idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
var Conv2DDerBiasProgram = (function () {
    function Conv2DDerBiasProgram(yShape) {
        this.variableNames = ['dy'];
        var yNumRows = yShape[0], yNumCols = yShape[1], outputDepth = yShape[2];
        this.outputShape = [outputDepth];
        this.userCode = "\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            derBias += getDy(yR, yC, d2);\n          }\n        }\n        setOutput(derBias);\n      }\n    ";
    }
    return Conv2DDerBiasProgram;
}());
exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;

},{"../conv_util":50}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo, hasBias) {
        this.variableNames = ['x', 'W'];
        if (hasBias) {
            this.variableNames.push('bias');
        }
        this.outputShape = convInfo.outShape;
        var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';
        var _a = convInfo.inShape, xNumRows = _a[0], xNumCols = _a[1], inputDepth = _a[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(inputDepth / 4) * 4;
        var inputDepthVec4Remainder = inputDepth % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d2 = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(xR, xC, d1),\n                getX(xR, xC, d1 + 1),\n                getX(xR, xC, d1 + 2),\n                getX(xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        " + biasSnippet + "\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inShape[1];
        var xNumCols = convInfo.inShape[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.channelMul;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Copy2DProgram = (function () {
    function Copy2DProgram(srcNumCols, destNumCols) {
        this.variableNames = ['source'];
        this.outputShape = null;
        this.userCode = "\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * " + destNumCols + " + destCoords.y;\n        int r = index / " + srcNumCols + ";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * " + srcNumCols + ");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";
    }
    Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
        return function (gpgpu, webGLProgram) {
            gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
            var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');
            gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
            var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');
            gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
        };
    };
    return Copy2DProgram;
}());
exports.Copy2DProgram = Copy2DProgram;

},{}],69:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        this.throwIfDisposed();
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {
        this.throwIfDisposed();
        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function (attribLocations) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
            return this.runQueryWebGL2(queryFn);
        }
        return this.runQueryWebGL1(queryFn);
    };
    GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');
        var query = this.gl.createQuery();
        this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        this.gl.endQuery(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"../../environment":8,"../../util":89,"./gpgpu_util":71,"./tex_util":82,"./webgl_util":87}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.shape,
            texShape: input.getTextureShapeRC(),
            textureType: input.getData().textureType
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.getTextureShapeRC(),
        textureType: output.getData().textureType
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    var attributeLocations = {};
    ATTRIBUTE_NAMES.forEach(function (attribute) {
        attributeLocations[attribute] =
            gpgpu.getAttributeLocation(webGLProgram, attribute);
    });
    if (shouldUploadNaNUniform()) {
        uniformLocations[NAN_UNIFORM_NAME] =
            gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].shape;
        var texShapeB = inputs[i].getTextureShapeRC();
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.getTexture();
    var outTexShape = output.getTextureShapeRC();
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.getTexture();
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram(binary.attributeLocations);
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.shape + "_" + x.getTextureShapeRC();
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../environment":8,"../../util":89,"./shader_compiler":80}],71:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var downloadTarget;
    if (isFloatTexture) {
        downloadTarget =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    }
    else {
        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
    }
    return downloadTarget;
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":8,"./tex_util":82,"./webgl_util":87}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var dyRows = convInfo.outShape[0];
        var dyCols = convInfo.outShape[1];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 dyRCCorner = coords.xy - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + dyRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + dyCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../math");
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return (aOrient === math_1.MatrixOrientation.REGULAR) ?
                "aRow, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", aRow";
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return (bOrient === math_1.MatrixOrientation.REGULAR) ?
                indexVar + " + " + vec4Offset + ", bCol" :
                "bCol, " + indexVar + " + " + vec4Offset;
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{"../math":53}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    OneHotProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var xNumRows = convInfo.inShape[0];
        var xNumCols = convInfo.inShape[1];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            if (poolType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        if (computePositions) {
            var compareOp_1 = poolType === 'min' ? '<=' : '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n          int d = coords.z;\n\n          ivec2 xRCCorner = coords.xy * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + xNumRows + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + xNumCols + ") {\n                continue;\n              }\n\n              float value = getX(xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = poolType === 'min' ? 'min' : 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + xNumCols + ") {\n          return initializationValue;\n        }\n        return getX(xR, xC, d);\n      }\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              getValue(xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = require("./webgl_util");
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');
    gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;

},{"./webgl_util":87}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinear3DProgram = (function () {
    function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var depth = inputShape[2];
        this.outputShape =
            [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
        var effectiveInputShape = alignCorners ?
            [inputShape[0] - 1, inputShape[1] - 1, depth] :
            inputShape;
        var effectiveOutputShape = alignCorners ?
            [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :
            this.outputShape;
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInputShape[0] / effectiveOutputShape[0] + ",\n          " + effectiveInputShape[1] / effectiveOutputShape[1] + ");\n      const vec2 inputShapeRC = vec2(" + inputShape[0] + ".0, " + inputShape[1] + ".0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinear3DProgram;
}());
exports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;

},{}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../broadcast_util");
var tex_util = require("./tex_util");
var tex_util_1 = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    return any(notEqual(values, values));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var texType = inputInfo.shapeInfo.textureType;
    if (texType === tex_util_1.TextureType.DEFAULT) {
        var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        var squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
            var params = ['row', 'col', 'depth'];
            return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
        }
    }
    if (texNumC === stride0) {
        if (texType === tex_util_1.TextureType.DEFAULT) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
        }
        else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleUVAndDepth(" + texName + ", uv, depth);\n        }\n      ";
        }
        else {
            throw new Error("Unknown TextureType " + texType + ".");
        }
    }
    if (texNumC === stride1 && texType === tex_util_1.TextureType.DEFAULT) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texType === tex_util_1.TextureType.DEFAULT) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
    }
    else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n        return sampleUVAndDepth(" + texName + ", uv, depth);\n      }\n    ";
    }
    else {
        throw new Error("Unknown TextureType " + texType + ".");
    }
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var isRGBAColorTexture = inputInfo.shapeInfo.textureType === tex_util_1.TextureType.RGBA_COLOR;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape) && !isRGBAColorTexture) {
        return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
    }
    var inTexExpandedShape = isRGBAColorTexture ?
        [inTexShape[0], inTexShape[1] * inputInfo.shapeInfo.logicalShape[2]] :
        inTexShape;
    var sampleSnippet = "return sample(" + texName + ", uv);";
    var rgbaColorSnippet = '';
    if (isRGBAColorTexture) {
        rgbaColorSnippet = "\n      int col = texC / " + inputInfo.shapeInfo.logicalShape[2] + ";\n      int texD = texC - col * " + inputInfo.shapeInfo.logicalShape[2] + ";\n      texC = col;\n    ";
        sampleSnippet = "return sampleUVAndDepth(" + texName + ", uv, texD);";
    }
    var inSize = util.sizeFromShape(inTexExpandedShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexExpandedShape[1] + ";\n      int texC = index - texR * " + inTexExpandedShape[1] + ";\n\n      " + rgbaColorSnippet + "\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      " + sampleSnippet + "\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank === 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../environment":8,"../../util":89,"../broadcast_util":48,"./tex_util":82}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":80}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["DEFAULT"] = 0] = "DEFAULT";
    TextureType[TextureType["RGBA_COLOR"] = 1] = "RGBA_COLOR";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC) {
        var shapeKey = getKeyFromTextureShape(shapeRC);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
    };
    TextureManager.prototype.releaseTexture = function (texture, shape) {
        var shapeKey = getKeyFromTextureShape(shape);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        for (var shape in this.freeTextures) {
            if (this.freeTextures.hasOwnProperty(shape)) {
                for (var i = 0; i < this.freeTextures[shape].length; i++) {
                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                }
            }
        }
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1];
}

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":80}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 4) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":80}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
exports.CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) {\n    return x;\n  }\n";
exports.ABS = "\n  return abs(x);\n";
exports.RELU = "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
function LEAKY_RELU(alpha) {
    return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
}
exports.LEAKY_RELU = LEAKY_RELU;
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return "\n    return (x == x) ? (x > 0.0 ? 1.0 : float(" + alpha + ")) : x;\n  ";
}
exports.STEP = STEP;
exports.NEG = "\n  return -x;\n";
exports.CEIL = "\n  return ceil(x);\n";
exports.FLOOR = "\n  return floor(x);\n";
exports.EXP = "\n  return exp(x);\n";
exports.LOG = "\n  return log(x);\n";
exports.SQRT = exports.CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
exports.SIN = exports.CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = exports.CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "\n  return tan(x);\n";
exports.ASIN = exports.CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
exports.ACOS = exports.CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
exports.ATAN = exports.CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.SQUARE = "\n  return x * x;\n";

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
var environment_1 = require("../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
    var loc = -1;
    if ((attribLocations != null) && (attribute in attribLocations)) {
        loc = attribLocations[attribute];
    }
    else {
        loc = gl.getAttribLocation(program, attribute);
    }
    if (loc === -1) {
        return;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":8,"../../util":89}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment = require("./environment");
var environment_1 = require("./environment");
var math_cpu_1 = require("./math/math_cpu");
var math_gpu_1 = require("./math/math_gpu");
var util = require("./util");
exports.TEST_EPSILON = 1e-2;
function mean(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum / values.length;
}
exports.mean = mean;
function standardDeviation(values, mean) {
    var squareDiffSum = 0;
    for (var i = 0; i < values.length; i++) {
        var diff = values[i] - mean;
        squareDiffSum += diff * diff;
    }
    return Math.sqrt(squareDiffSum / values.length);
}
exports.standardDeviation = standardDeviation;
function kurtosis(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum4 = 0;
    for (var i = 0; i < n; i++) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum4 += Math.pow(v, 4);
    }
    return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2) - 3;
}
exports.kurtosis = kurtosis;
function skewness(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum3 = 0;
    var i = -1;
    while (++i < n) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum3 += Math.pow(v, 3);
    }
    return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
}
exports.skewness = skewness;
function jarqueBeraNormalityTest(values) {
    var s = skewness(values);
    var k = kurtosis(values);
    var jb = values.length * ((Math.pow(s, 2) / 6) + (Math.pow(k, 2) / 24));
    var CHI_SQUARE_2DEG = 5.991;
    if (jb > CHI_SQUARE_2DEG) {
        throw new Error("Invalid p-value for JB: " + jb);
    }
}
exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;
function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var actualMean = mean(actual);
    expectNumbersClose(actualMean, expectedMean, epsilon);
    expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);
}
exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var aType = actual.constructor.name;
    var bType = expected.constructor.name;
    if (aType !== bType) {
        throw new Error("Arrays are of different type " + aType + " vs " + bType);
    }
    if (actual.length !== expected.length) {
        throw new Error("Matrices have different lengths (" + actual.length + " vs " +
            (expected.length + ")."));
    }
    for (var i = 0; i < expected.length; ++i) {
        var a = actual[i];
        var e = expected[i];
        if (!areClose(a, e, epsilon)) {
            var actualStr = "actual[" + i + "] === " + a;
            var expectedStr = "expected[" + i + "] === " + e;
            throw new Error('Arrays differ: ' + actualStr + ', ' + expectedStr);
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    for (var i = 0; i < actual.length; i++) {
        if (actual[i] < low || actual[i] > high) {
            throw new Error("Value out of range:" + actual[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function randomArrayInRange(n, minValue, maxValue) {
    var v = new Float32Array(n);
    var range = maxValue - minValue;
    for (var i = 0; i < n; ++i) {
        v[i] = (Math.random() * range) + minValue;
    }
    return v;
}
exports.randomArrayInRange = randomArrayInRange;
function makeIdentity(n) {
    var i = new Float32Array(n * n);
    for (var j = 0; j < n; ++j) {
        i[(j * n) + j] = 1;
    }
    return i;
}
exports.makeIdentity = makeIdentity;
function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
    var result = new Float32Array(aRow * bCol);
    for (var r = 0; r < aRow; ++r) {
        var aOffset = (r * aCol);
        var cOffset = (r * bCol);
        for (var c = 0; c < bCol; ++c) {
            var d = 0;
            for (var k = 0; k < aCol; ++k) {
                d += a[aOffset + k] * b[(k * bCol) + c];
            }
            result[cOffset + c] = d;
        }
    }
    return result;
}
exports.cpuMultiplyMatrix = cpuMultiplyMatrix;
function cpuDotProduct(a, b) {
    if (a.length !== b.length) {
        throw new Error('cpuDotProduct: incompatible vectors.');
    }
    var d = 0;
    for (var i = 0; i < a.length; ++i) {
        d += a[i] * b[i];
    }
    return d;
}
exports.cpuDotProduct = cpuDotProduct;
function describeMathCPU(name, tests, featuresList) {
    var testNameBase = 'math_cpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_cpu_1.NDArrayMathCPU(); }, features); }, featuresList);
}
exports.describeMathCPU = describeMathCPU;
function describeMathGPU(name, tests, featuresList) {
    var testNameBase = 'math_gpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_gpu_1.NDArrayMathGPU(); }, features); }, featuresList);
}
exports.describeMathGPU = describeMathGPU;
function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
    describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);
}
exports.describeCustom = describeCustom;
function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
    if (featuresList != null) {
        featuresList.forEach(function (features) {
            var testName = testNameBase + ' ' + JSON.stringify(features);
            executor(testName, tests, features);
        });
    }
    else {
        executor(testNameBase, tests);
    }
}
var PROMISE_IT = function (name, testFunc) {
    it(name, function (done) {
        var result = testFunc();
        if (result instanceof Promise) {
            result.then(done, function (e) {
                fail(e);
                done();
            });
        }
        else {
            done();
        }
    });
};
function executeMathTests(testName, tests, mathFactory, features) {
    var math;
    var customBeforeEach = function () {
        math = mathFactory();
        math.startScope();
    };
    var customAfterEach = function () {
        math.endScope(null);
        math.dispose();
    };
    var customIt = function (name, testFunc) {
        PROMISE_IT(name, function () { return testFunc(math); });
    };
    executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);
}
exports.executeMathTests = executeMathTests;
function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {
    if (customIt === void 0) { customIt = PROMISE_IT; }
    describe(testName, function () {
        beforeEach(function () {
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment(features));
            }
            if (customBeforeEach != null) {
                customBeforeEach();
            }
        });
        afterEach(function () {
            if (customAfterEach != null) {
                customAfterEach();
            }
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment());
            }
        });
        tests.forEach(function (test) { return test(customIt); });
    });
}
exports.executeTests = executeTests;
function assertIsNan(val, dtype) {
    if (!util.isValNaN(val, dtype)) {
        throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
    }
}
exports.assertIsNan = assertIsNan;

},{"./environment":8,"./math/math_cpu":54,"./math/math_gpu":55,"./util":89}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function randGauss(mean, stdDev, truncated) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (truncated === void 0) { truncated = false; }
    var v1, v2, s;
    do {
        v1 = 2 * Math.random() - 1;
        v2 = 2 * Math.random() - 1;
        s = v1 * v1 + v2 * v2;
    } while (s > 1);
    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
    if (truncated && Math.abs(result) > 2) {
        return randGauss(mean, stdDev, true);
    }
    return mean + stdDev * result;
}
exports.randGauss = randGauss;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        setTimeout(tryFn, 0);
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size (" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
exports.NAN_INT32 = 1 << 31;
exports.NAN_BOOL = 255;
exports.NAN_FLOAT32 = NaN;
function getNaN(dtype) {
    if (dtype === 'float32') {
        return exports.NAN_FLOAT32;
    }
    else if (dtype === 'int32') {
        return exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.getNaN = getNaN;
function isValNaN(val, dtype) {
    if (dtype === 'float32') {
        return isNaN(val);
    }
    else if (dtype === 'int32') {
        return val === exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return val === exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.isValNaN = isValNaN;
function squeezeShape(shape) {
    var newShape = [];
    var keptDims = [];
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.3.11';
exports.version = version;

},{}],91:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":92,"./lib/tychei":93,"./lib/xor128":94,"./lib/xor4096":95,"./lib/xorshift7":96,"./lib/xorwow":97,"./seedrandom":98}],92:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],93:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],94:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],95:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],96:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],97:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],98:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":2}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlbW9zL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vcy9jb21wbGVtZW50YXJ5LWNvbG9yLXByZWRpY3Rpb24vY29tcGxlbWVudGFyeS1jb2xvci1wcmVkaWN0aW9uLnRzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZGF0YS9jaGVja3BvaW50X2xvYWRlci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZGF0YS9kYXRhc2V0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL2lucHV0X3Byb3ZpZGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL3hoci1kYXRhc2V0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kZXZpY2VfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZW52aXJvbm1lbnQuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9ncmFwaF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcGVyYXRpb25fZW1pdHRlci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2FkZC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2FyZ21heC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2FyZ21heGVxdWFscy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2NvbmNhdDNkLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvY29udm9sdXRpb24uanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9kaXZpZGUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvbi5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9jb3N0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvZXhwLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvbGluZWFyX2NvbWJpbmF0aW9uLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvbG9nLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvbWF0bXVsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvbWF4X3Bvb2wuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tdWx0aXBseS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL29wLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvcmVkdWNlX3N1bS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL3Jlc2hhcGUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9zb2Z0bWF4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvc3VidHJhY3QuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL29wdGltaXplci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9ybXNwcm9wX29wdGltaXplci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9wcmlvcml0eV9xdWV1ZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvc2Vzc2lvbi5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvc2Vzc2lvbl91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC90ZW5zb3JfYXJyYXlfbWFwLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaF9ydW5uZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2luZGV4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9pbml0aWFsaXplcnMuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnMuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYXhpc191dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2Jyb2FkY2FzdF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2NvbmNhdF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2NvbnZfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9jb3B5MmRfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9jb3N0X2Z1bmN0aW9ucy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9tYXRoLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL21hdGhfY3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL21hdGhfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL25kYXJyYXkuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvcmVkdWNlX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvc2xpY2VfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9hZGRzY2FsZWRtYXRfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2FyZ21pbm1heF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYmF0Y2hub3JtX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9iaW5hcnlvcF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY2xpcF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29uY2F0X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb252X2JhY2twcm9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb252X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb252X2dwdV9kZXB0aHdpc2UuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29weV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfY29udGV4dC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV9tYXRoLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2dwZ3B1X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL211bG1hdF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbXVsdGlub21pYWxfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL29uZWhvdF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcG9vbF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcmVkdWNlX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3NoYWRlcl9jb21waWxlci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9zbGljZV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGV4X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3RpbGVfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3RyYW5zcG9zZV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdW5hcnlvcF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvd2ViZ2xfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvdGVzdF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy92ZXJzaW9uLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ2tCQSx1Q0FBNks7QUFHN0s7SUF3QkU7UUFuQkEsU0FBSSxHQUFnQixJQUFJLDBCQUFjLEVBQUUsQ0FBQztRQUd6Qyx3QkFBbUIsR0FBRyxLQUFLLENBQUM7UUFHNUIsYUFBUSxHQUFHLEdBQUcsQ0FBQztRQUdmLGNBQVMsR0FBRyxHQUFHLENBQUM7UUFXZCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksNkJBQWlCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUNqRixDQUFDO0lBS0QsOENBQVksR0FBWjtRQUNFLElBQU0sS0FBSyxHQUFHLElBQUksaUJBQUssRUFBRSxDQUFDO1FBRzFCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFHN0QsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUkvRCxJQUFJLG1CQUFtQixHQUNuQixJQUFJLENBQUMseUJBQXlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBR25FLG1CQUFtQjtZQUNmLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBR3RFLG1CQUFtQjtZQUNmLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXRFLElBQUksQ0FBQyxnQkFBZ0I7WUFDakIsSUFBSSxDQUFDLHlCQUF5QixDQUFDLEtBQUssRUFBRSxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFHckUsSUFBSSxDQUFDLFVBQVU7WUFDWCxLQUFLLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFHcEUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLG1CQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUc3QyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQVdELDZDQUFXLEdBQVgsVUFBWSxlQUF3QjtRQUFwQyxpQkF1QkM7UUFyQkMsSUFBTSxZQUFZLEdBQ2QsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUM7UUFHN0MsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDZCxJQUFNLElBQUksR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FDM0IsS0FBSSxDQUFDLFVBQVUsRUFBRSxLQUFJLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSSxDQUFDLFNBQVMsRUFDakUsZUFBZSxDQUFDLENBQUMsQ0FBQyx5QkFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMseUJBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUvRCxFQUFFLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7Z0JBRXJCLE1BQU0sQ0FBQztZQUNULENBQUM7WUFJRCxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsZ0RBQWMsR0FBZCxVQUFlLFFBQWtCO1FBQy9CLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxHQUFHLEdBQUcsRUFBUCxDQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsa0RBQWdCLEdBQWhCLFVBQWlCLGtCQUE0QjtRQUMzQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxHQUFHLEdBQUcsRUFBUCxDQUFPLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQseUNBQU8sR0FBUCxVQUFRLFFBQWtCO1FBQTFCLGlCQWdCQztRQWZDLElBQUksZUFBZSxHQUFhLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUksRUFBRSxLQUFLO1lBQzFCLElBQU0sT0FBTyxHQUFHLENBQUM7b0JBQ2YsTUFBTSxFQUFFLEtBQUksQ0FBQyxXQUFXO29CQUN4QixJQUFJLEVBQUUsbUJBQU8sQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDakQsQ0FBQyxDQUFDO1lBQ0gsSUFBTSxVQUFVLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3JFLElBQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN0QyxJQUFNLE1BQU0sR0FBRyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFHekUsZUFBZTtnQkFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQXpDLENBQXlDLENBQUMsQ0FBQztRQUNqRSxDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxlQUFlLENBQUM7SUFDekIsQ0FBQztJQUVPLDJEQUF5QixHQUFqQyxVQUNJLEtBQVksRUFBRSxVQUFrQixFQUFFLFVBQWtCLEVBQ3BELGVBQXVCO1FBR3pCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDckIscUJBQW1CLFVBQVksRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUM1RCxVQUFDLENBQUMsSUFBSyxPQUFBLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUF6QixDQUF5QixDQUFDLENBQUM7SUFDeEMsQ0FBQztJQU1PLHNEQUFvQixHQUE1QixVQUE2QixZQUFvQjtRQUFqRCxpQkErQkM7UUE5QkMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDZCxJQUFNLFNBQVMsR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMxQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUN0QyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUc7b0JBQ2IsS0FBSSxDQUFDLDBCQUEwQixFQUFFLEVBQUUsS0FBSSxDQUFDLDBCQUEwQixFQUFFO29CQUNwRSxLQUFJLENBQUMsMEJBQTBCLEVBQUU7aUJBQ2xDLENBQUM7WUFDSixDQUFDO1lBR0QsSUFBTSxVQUFVLEdBQ1osU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLG1CQUFPLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBbkMsQ0FBbUMsQ0FBQyxDQUFDO1lBQzVELElBQU0sV0FBVyxHQUFjLFNBQVMsQ0FBQyxHQUFHLENBQ3hDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsbUJBQU8sQ0FBQyxHQUFHLENBQ1osS0FBSSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUR0RCxDQUNzRCxDQUFDLENBQUM7WUFJakUsSUFBTSw0QkFBNEIsR0FDOUIsSUFBSSxtREFBdUMsQ0FDdkMsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFBLHFEQUM4QyxFQUQ3QyxxQkFBYSxFQUFFLHNCQUFjLENBQ2lCO1lBR3JELEtBQUksQ0FBQyxXQUFXLEdBQUc7Z0JBQ2pCLEVBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBQztnQkFDL0MsRUFBQyxNQUFNLEVBQUUsS0FBSSxDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFDO2FBQ2xELENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyw0REFBMEIsR0FBbEM7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQU1ELDJEQUF5QixHQUF6QixVQUEwQixRQUFrQjtRQUMxQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUlwQixDQUFDLElBQUksS0FBSyxDQUFDO1FBQ1gsQ0FBQyxJQUFJLEtBQUssQ0FBQztRQUNYLENBQUMsSUFBSSxLQUFLLENBQUM7UUFDWCxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDOUIsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMxQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixJQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFWixFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNoQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNaLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLElBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDcEIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFeEQsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDeEIsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0IsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5QixDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUM7WUFDcEMsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckIsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3BDLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JCLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQztZQUNwQyxDQUFDO1FBQ0gsQ0FBQztRQUVELENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7UUFHM0IsQ0FBQyxJQUFJLEdBQUcsQ0FBQztRQUNULEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ1osQ0FBQyxJQUFJLEdBQUcsQ0FBQztRQUNYLENBQUM7UUFDRCxDQUFDLElBQUksR0FBRyxDQUFDO1FBSVQsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDWixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEIsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sSUFBTSxPQUFPLEdBQUcsVUFBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7Z0JBQzlDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEIsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsQixFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FBQztZQUVGLElBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2hELElBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXBCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzdCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNyQixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMvQixDQUFDO1FBRUQsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBbkIsQ0FBbUIsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFDSCw4QkFBQztBQUFELENBeFBBLEFBd1BDLElBQUE7QUFFRCxJQUFNLHVCQUF1QixHQUFHLElBQUksdUJBQXVCLEVBQUUsQ0FBQztBQUc5RCx1QkFBdUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUd2QyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDYixJQUFJLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQztBQUVyQjtJQUVFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQztJQUN2QixJQUFNLFVBQVUsR0FBRyxNQUFNLENBQUM7SUFDMUIsRUFBRSxDQUFDLENBQUMsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsMEJBQTBCLENBQUMseUJBQXVCLFNBQVMsTUFBRyxDQUFDLENBQUM7UUFFaEUsTUFBTSxDQUFDO0lBQ1QsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLDBCQUEwQixDQUFDLDBCQUF3QixVQUFVLGlCQUFZLElBQUksY0FBUyxJQUFNLENBQUMsQ0FBQztRQUU5RixNQUFNLENBQUM7SUFDVCxDQUFDO0lBRUQsb0NBQW9DLE9BQWM7UUFDaEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyQixPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUdELHFCQUFxQixDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFJM0MsSUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZUFBZSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDekMsSUFBSSxHQUFHLHVCQUF1QixDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLElBQUksRUFBRSxDQUFDO0lBQ1QsQ0FBQztJQUdELE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFHeEMsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDdkUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDMUMsSUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLElBQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFNLGFBQWEsR0FDZCxVQUFVLENBQUMsWUFBWSxDQUFDLHFCQUFxQixDQUFZO2FBQ3JELEtBQUssQ0FBQyxHQUFHLENBQUM7YUFDVixHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUFDO1FBR25DLElBQU0sY0FBYyxHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN0RSwwQkFBMEIsQ0FDdEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVELEVBQUUsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDO1NBQ3JCLEtBQUssQ0FBQyxNQUFNLEVBQ1gsVUFBUyxDQUFLO1FBQ1osSUFBTSxhQUFhLEdBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JKLElBQU0sU0FBUyxHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNqRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakMsQ0FBQyxDQUFDLENBQUM7SUFHVixFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUVqRCxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUNiLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDWixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO1NBQ2YsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUNkLElBQUksQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDO1NBQ3pCLElBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDO1NBQ3pCLEtBQUssQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDO1NBRXRCLElBQUksQ0FBQyxPQUFPLEdBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDYixNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ1osSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztTQUNmLElBQUksQ0FBQyxHQUFHLEVBQUcsRUFBRSxDQUFDO1NBQ2QsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUM7U0FDekIsSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUM7U0FDekIsS0FBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUM7U0FFdEIsSUFBSSxDQUFDLE9BQU8sR0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxFQUFDLHFCQUFxQixFQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUN2RSxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUNmLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDWixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO1NBQ2YsSUFBSSxDQUFDLEdBQUcsRUFBRyxFQUFFLENBQUM7U0FDZCxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQztTQUN6QixJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQztTQUN6QixLQUFLLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQztTQUV0QixJQUFJLENBQUMsT0FBTyxHQUFDLFNBQVMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsRUFBQyxxQkFBcUIsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFFaEYsRUFBRSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUM7U0FDckIsSUFBSSxDQUFDLFVBQVMsQ0FBSyxFQUFFLENBQUs7UUFDekIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDWCxNQUFNLENBQUMsTUFBTSxDQUFDO2FBQ2QsSUFBSSxDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUM7YUFDOUIsTUFBTSxDQUFDLFVBQVUsQ0FBQzthQUNsQixJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssR0FBQyxDQUFDLENBQUM7YUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQzthQUNmLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUM7YUFDZixJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDO2FBQzdCLElBQUksQ0FBQyxVQUFTLENBQUssSUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztJQUdQLG1CQUFtQixDQUFVLEVBQUUsQ0FBVTtRQUV2QyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDO0lBQ2xILENBQUM7QUFDSCxDQUFDO0FBRUQsdUJBQXVCLEtBQWM7SUFDbkMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQ3ZDLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDdkMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFFRCxvQ0FDSSxTQUFzQixFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUztJQUN6RCxJQUFNLG1CQUFtQixHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMvRCxTQUFTLENBQUMsV0FBVyxHQUFHLG1CQUFtQixDQUFDO0lBRTVDLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDcEMsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsbUJBQW1CLENBQUM7SUFDaEQsU0FBUyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQ7SUFDRSxJQUFJLFVBQVUsR0FBUyxFQUFFLENBQUM7SUFDMUIsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDdkUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDMUMsSUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLElBQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFNLGFBQWEsR0FDZCxVQUFVLENBQUMsWUFBWSxDQUFDLHFCQUFxQixDQUFZO2FBQ3JELEtBQUssQ0FBQyxHQUFHLENBQUM7YUFDVixHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUFDO1FBR25DLDBCQUEwQixDQUN0QixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUdsRSxJQUFNLFVBQVUsR0FDWix1QkFBdUIsQ0FBQyx5QkFBeUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNyRSwwQkFBMEIsQ0FDdEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFDLEtBQUssRUFBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVELElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7UUFDMUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO1FBQzFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkQsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFTLENBQUssSUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV0RSxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRXBFLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDM0QsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7U0FDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNyQixLQUFLLEVBQUU7U0FDUCxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2QsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakIsS0FBSyxDQUFDLE1BQU0sRUFBRSxVQUFTLENBQUssSUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQSxDQUFDLENBQUM7U0FDcEQsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFTLENBQUssRUFBRSxDQUFLLElBQUUsTUFBTSxDQUFDLElBQUksR0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUM7U0FDbEQsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztJQUVqQyxHQUFHLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQztTQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3JCLEtBQUssRUFBRTtTQUNQLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDZCxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQixLQUFLLENBQUMsTUFBTSxFQUFFLFVBQVMsQ0FBSyxJQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUEsQ0FBQyxDQUFDO1NBQ3RFLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBUyxDQUFLLEVBQUUsQ0FBSyxJQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUMsQ0FBQyxDQUFDLENBQUEsQ0FBQyxDQUFDO1NBQ2xELElBQUksQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFFbkMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7U0FDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNyQixLQUFLLEVBQUU7U0FDUCxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2QsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakIsS0FBSyxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsQ0FBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDM0MsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFTLENBQUssRUFBRSxDQUFLLElBQUUsTUFBTSxDQUFDLElBQUksR0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUM7U0FDbEQsSUFBSSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUVsQyxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztTQUN0QixJQUFJLENBQUMsVUFBUyxDQUFLLEVBQUUsQ0FBSztRQUN6QixHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQzthQUNiLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDO2FBQ3JCLE1BQU0sQ0FBQyxVQUFVLENBQUM7YUFDbEIsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLEdBQUMsQ0FBQyxDQUFDO2FBQzNCLE1BQU0sQ0FBQyxPQUFPLENBQUM7YUFDZixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ2YsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7YUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQzthQUM3QixJQUFJLENBQUMsVUFBUyxDQUFLLElBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUMsQ0FBQztRQUNqRixNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQyxDQUFDLENBQUM7SUFFTCxFQUFFLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQztTQUN4QixJQUFJLENBQUMsVUFBUyxDQUFLLEVBQUUsQ0FBSztRQUN6QixHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQzthQUNiLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDO2FBQ3JCLE1BQU0sQ0FBQyxVQUFVLENBQUM7YUFDbEIsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLEdBQUMsQ0FBQyxDQUFDO2FBQzNCLE1BQU0sQ0FBQyxPQUFPLENBQUM7YUFDZixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ2YsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7YUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQzthQUM3QixJQUFJLENBQUMsVUFBUyxDQUFLLElBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUMsQ0FBQztRQUNqRixNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQyxDQUFDLENBQUM7SUFHTCxJQUFNLFdBQVcsR0FBRyxDQUFDO1lBQ25CLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSx1QkFBdUIsRUFBQztZQUN2QyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUc7WUFDZixFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUc7U0FDbEIsRUFBQztZQUNBLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSxxQ0FBcUMsRUFBQztZQUNyRCxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUc7WUFDZixFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUU7U0FDakIsQ0FBQyxDQUFDO0lBRUgsSUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNqRSxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBRXJGLFVBQVUsQ0FBQztRQUNULElBQU0sV0FBVyxHQUFHLENBQUM7Z0JBQ25CLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSx3QkFBd0IsRUFBQztnQkFDeEMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHO2dCQUNmLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTthQUNoQixDQUFDLEVBQUUsZUFBZSxHQUFHLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFL0QsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN2RixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFLTiwwQkFBMEIsS0FBWTtRQUNwQyxJQUFNLGFBQWEsR0FBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEksSUFBTSxVQUFVLEdBQUcsdUJBQXVCLENBQUMseUJBQXlCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDcEYsTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNuQyxDQUFDO0FBQ0gsQ0FBQztBQUVELElBQU0saUJBQWlCLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUVyQztJQUNFLElBQUksR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDO0lBQ25CLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFDLEtBQUssQ0FBQztBQUM3RCxDQUFDO0FBRUQsWUFBWSxFQUFFLENBQUM7QUFHZixVQUFVLENBQUMsY0FBZSxxQkFBcUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUEsQ0FBQyxDQUFDLENBQUM7OztBQzVoQnhFOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5pbXBvcnQge0FycmF5MUQsIENvc3RSZWR1Y3Rpb24sIEZlZWRFbnRyeSwgR3JhcGgsIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgTkRBcnJheU1hdGgsIE5EQXJyYXlNYXRoR1BVLCBTZXNzaW9uLCBNb21lbnR1bU9wdGltaXplciwgVGVuc29yfSBmcm9tICdkZWVwbGVhcm4nO1xuZGVjbGFyZSB2YXIgZDM6YW55O1xuXG5jbGFzcyBDb21wbGVtZW50YXJ5Q29sb3JNb2RlbCB7XG4gIC8vIFJ1bnMgdHJhaW5pbmcuXG4gIHNlc3Npb246IFNlc3Npb247XG5cbiAgLy8gRW5jYXBzdWxhdGVzIG1hdGggb3BlcmF0aW9ucyBvbiB0aGUgQ1BVIGFuZCBHUFUuXG4gIG1hdGg6IE5EQXJyYXlNYXRoID0gbmV3IE5EQXJyYXlNYXRoR1BVKCk7XG5cbiAgLy8gQW4gb3B0aW1pemVyIHdpdGggYSBjZXJ0YWluIGluaXRpYWwgbGVhcm5pbmcgcmF0ZS4gVXNlZCBmb3IgdHJhaW5pbmcuXG4gIGluaXRpYWxMZWFybmluZ1JhdGUgPSAwLjA0MjtcbiAgb3B0aW1pemVyOiBNb21lbnR1bU9wdGltaXplcjtcbiAgLy8gTW9tZW50dW0gcGFyYW1ldGVyIGZvciBNb21lbnR1bU9wdGltaXplciwgdXN1YWxseSBzZXQgdG8gfjAuOVxuICBtb21lbnR1bSA9IDAuOTtcblxuICAvLyBFYWNoIHRyYWluaW5nIGJhdGNoIHdpbGwgYmUgb24gdGhpcyBtYW55IGV4YW1wbGVzLlxuICBiYXRjaFNpemUgPSAzMDA7XG5cbiAgaW5wdXRUZW5zb3I6IFRlbnNvcjtcbiAgdGFyZ2V0VGVuc29yOiBUZW5zb3I7XG4gIGNvc3RUZW5zb3I6IFRlbnNvcjtcbiAgcHJlZGljdGlvblRlbnNvcjogVGVuc29yO1xuXG4gIC8vIE1hcHMgdGVuc29ycyB0byBJbnB1dFByb3ZpZGVycy5cbiAgZmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub3B0aW1pemVyID0gbmV3IE1vbWVudHVtT3B0aW1pemVyKHRoaXMuaW5pdGlhbExlYXJuaW5nUmF0ZSwgdGhpcy5tb21lbnR1bSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBncmFwaCBvZiB0aGUgbW9kZWwuIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHRyYWluaW5nLlxuICAgKi9cbiAgc2V0dXBTZXNzaW9uKCk6IHZvaWQge1xuICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKCk7XG5cbiAgICAvLyBUaGlzIHRlbnNvciBjb250YWlucyB0aGUgaW5wdXQuIEluIHRoaXMgY2FzZSwgaXQgaXMgYSBzY2FsYXIuXG4gICAgdGhpcy5pbnB1dFRlbnNvciA9IGdyYXBoLnBsYWNlaG9sZGVyKCdpbnB1dCBSR0IgdmFsdWUnLCBbM10pO1xuXG4gICAgLy8gVGhpcyB0ZW5zb3IgY29udGFpbnMgdGhlIHRhcmdldC5cbiAgICB0aGlzLnRhcmdldFRlbnNvciA9IGdyYXBoLnBsYWNlaG9sZGVyKCdvdXRwdXQgUkdCIHZhbHVlJywgWzNdKTtcbi8qKi9cbiAgICAvLyBDcmVhdGUgMyBmdWxseSBjb25uZWN0ZWQgbGF5ZXJzLCBlYWNoIHdpdGggaGFsZiB0aGUgbnVtYmVyIG9mIG5vZGVzIG9mXG4gICAgLy8gdGhlIHByZXZpb3VzIGxheWVyLiBUaGUgZmlyc3Qgb25lIGhhcyA2NCBub2Rlcy5cbiAgICBsZXQgZnVsbHlDb25uZWN0ZWRMYXllciA9XG4gICAgICAgIHRoaXMuY3JlYXRlRnVsbHlDb25uZWN0ZWRMYXllcihncmFwaCwgdGhpcy5pbnB1dFRlbnNvciwgMCwgNjQpO1xuXG4gICAgLy8gQ3JlYXRlIGZ1bGx5IGNvbm5lY3RlZCBsYXllciAxLCB3aGljaCBoYXMgMzIgbm9kZXMuXG4gICAgZnVsbHlDb25uZWN0ZWRMYXllciA9XG4gICAgICAgIHRoaXMuY3JlYXRlRnVsbHlDb25uZWN0ZWRMYXllcihncmFwaCwgZnVsbHlDb25uZWN0ZWRMYXllciwgMSwgMzIpO1xuXG4gICAgLy8gQ3JlYXRlIGZ1bGx5IGNvbm5lY3RlZCBsYXllciAyLCB3aGljaCBoYXMgMTYgbm9kZXMuXG4gICAgZnVsbHlDb25uZWN0ZWRMYXllciA9XG4gICAgICAgIHRoaXMuY3JlYXRlRnVsbHlDb25uZWN0ZWRMYXllcihncmFwaCwgZnVsbHlDb25uZWN0ZWRMYXllciwgMiwgMTYpO1xuXG4gICAgdGhpcy5wcmVkaWN0aW9uVGVuc29yID1cbiAgICAgICAgdGhpcy5jcmVhdGVGdWxseUNvbm5lY3RlZExheWVyKGdyYXBoLCBmdWxseUNvbm5lY3RlZExheWVyLCAzLCAzKTtcblxuICAgIC8vIFdlIHdpbGwgb3B0aW1pemUgdXNpbmcgbWVhbiBzcXVhcmVkIGxvc3MuXG4gICAgdGhpcy5jb3N0VGVuc29yID1cbiAgICAgICAgZ3JhcGgubWVhblNxdWFyZWRDb3N0KHRoaXMudGFyZ2V0VGVuc29yLCB0aGlzLnByZWRpY3Rpb25UZW5zb3IpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBzZXNzaW9uIG9ubHkgYWZ0ZXIgY29uc3RydWN0aW5nIHRoZSBncmFwaC5cbiAgICB0aGlzLnNlc3Npb24gPSBuZXcgU2Vzc2lvbihncmFwaCwgdGhpcy5tYXRoKTtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHRyYWluIHRoZSBtb2RlbC5cbiAgICB0aGlzLmdlbmVyYXRlVHJhaW5pbmdEYXRhKDFlNCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhaW5zIG9uZSBiYXRjaCBmb3Igb25lIGl0ZXJhdGlvbi4gQ2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0b1xuICAgKiBwcm9ncmVzc2l2ZWx5IHRyYWluLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gdHJhbnNmZXJzIGRhdGEgZnJvbSB0aGUgR1BVIGluXG4gICAqIG9yZGVyIHRvIG9idGFpbiB0aGUgY3VycmVudCBsb3NzIG9uIHRyYWluaW5nIGRhdGEuXG4gICAqXG4gICAqIElmIHNob3VsZEZldGNoQ29zdCBpcyB0cnVlLCByZXR1cm5zIHRoZSBtZWFuIGNvc3QgYWNyb3NzIGV4YW1wbGVzIGluIHRoZVxuICAgKiBiYXRjaC4gT3RoZXJ3aXNlLCByZXR1cm5zIC0xLiBXZSBzaG91bGQgb25seSByZXRyaWV2ZSB0aGUgY29zdCBub3cgYW5kIHRoZW5cbiAgICogYmVjYXVzZSBkb2luZyBzbyByZXF1aXJlcyB0cmFuc2ZlcnJpbmcgZGF0YSBmcm9tIHRoZSBHUFUuXG4gICAqL1xuICB0cmFpbjFCYXRjaChzaG91bGRGZXRjaENvc3Q6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIC8vIEV2ZXJ5IDQyIHN0ZXBzLCBsb3dlciB0aGUgbGVhcm5pbmcgcmF0ZSBieSAxNSUuXG4gICAgY29uc3QgbGVhcm5pbmdSYXRlID1cbiAgICAgICAgdGhpcy5pbml0aWFsTGVhcm5pbmdSYXRlICogTWF0aC5wb3coMC44NSwgTWF0aC5mbG9vcihzdGVwIC8gNDIpKTtcbiAgICB0aGlzLm9wdGltaXplci5zZXRMZWFybmluZ1JhdGUobGVhcm5pbmdSYXRlKTtcblxuICAgIC8vIFRyYWluIDEgYmF0Y2guXG4gICAgbGV0IGNvc3RWYWx1ZSA9IC0xO1xuICAgIHRoaXMubWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICBjb25zdCBjb3N0ID0gdGhpcy5zZXNzaW9uLnRyYWluKFxuICAgICAgICAgIHRoaXMuY29zdFRlbnNvciwgdGhpcy5mZWVkRW50cmllcywgdGhpcy5iYXRjaFNpemUsIHRoaXMub3B0aW1pemVyLFxuICAgICAgICAgIHNob3VsZEZldGNoQ29zdCA/IENvc3RSZWR1Y3Rpb24uTUVBTiA6IENvc3RSZWR1Y3Rpb24uTk9ORSk7XG5cbiAgICAgIGlmICghc2hvdWxkRmV0Y2hDb3N0KSB7XG4gICAgICAgIC8vIFdlIG9ubHkgdHJhaW4uIFdlIGRvIG5vdCBjb21wdXRlIHRoZSBjb3N0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIGNvc3QgKGJ5IGNhbGxpbmcgZ2V0KSwgd2hpY2ggcmVxdWlyZXMgdHJhbnNmZXJyaW5nIGRhdGFcbiAgICAgIC8vIGZyb20gdGhlIEdQVS5cbiAgICAgIGNvc3RWYWx1ZSA9IGNvc3QuZ2V0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvc3RWYWx1ZTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUNvbG9yKHJnYkNvbG9yOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gcmdiQ29sb3IubWFwKHYgPT4gdiAvIDI1NSk7XG4gIH1cblxuICBkZW5vcm1hbGl6ZUNvbG9yKG5vcm1hbGl6ZWRSZ2JDb2xvcjogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRSZ2JDb2xvci5tYXAodiA9PiB2ICogMjU1KTtcbiAgfVxuXG4gIHByZWRpY3QocmdiQ29sb3I6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGxldCBjb21wbGVtZW50Q29sb3I6IG51bWJlcltdID0gW107XG4gICAgdGhpcy5tYXRoLnNjb3BlKChrZWVwLCB0cmFjaykgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZyA9IFt7XG4gICAgICAgIHRlbnNvcjogdGhpcy5pbnB1dFRlbnNvcixcbiAgICAgICAgZGF0YTogQXJyYXkxRC5uZXcodGhpcy5ub3JtYWxpemVDb2xvcihyZ2JDb2xvcikpLFxuICAgICAgfV07XG4gICAgICBjb25zdCBldmFsT3V0cHV0ID0gdGhpcy5zZXNzaW9uLmV2YWwodGhpcy5wcmVkaWN0aW9uVGVuc29yLCBtYXBwaW5nKTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGV2YWxPdXRwdXQuZ2V0VmFsdWVzKCk7XG4gICAgICBjb25zdCBjb2xvcnMgPSB0aGlzLmRlbm9ybWFsaXplQ29sb3IoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWVzKSk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWVzIGFyZSB3aXRoaW4gcmFuZ2UuXG4gICAgICBjb21wbGVtZW50Q29sb3IgPVxuICAgICAgICAgIGNvbG9ycy5tYXAodiA9PiBNYXRoLnJvdW5kKE1hdGgubWF4KE1hdGgubWluKHYsIDI1NSksIDApKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBsZW1lbnRDb2xvcjtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRnVsbHlDb25uZWN0ZWRMYXllcihcbiAgICAgIGdyYXBoOiBHcmFwaCwgaW5wdXRMYXllcjogVGVuc29yLCBsYXllckluZGV4OiBudW1iZXIsXG4gICAgICBzaXplT2ZUaGlzTGF5ZXI6IG51bWJlcikge1xuICAgIC8vIFVzZXMgbGVha3lSZWx1IHRvIGF2b2lkIGR5aW5nIFJlTFVcbiAgICAvLyBKdXN0IGEgc21hbGwgdGlsdCAoMC4wMDEpIHNob3VsZCBiZSBlbm91Z2hcbiAgICByZXR1cm4gZ3JhcGgubGF5ZXJzLmRlbnNlKFxuICAgICAgICBgZnVsbHlfY29ubmVjdGVkXyR7bGF5ZXJJbmRleH1gLCBpbnB1dExheWVyLCBzaXplT2ZUaGlzTGF5ZXIsXG4gICAgICAgICh4KSA9PiBncmFwaC5sZWFreVJlbHUoeCwgMC4wMDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZGF0YSB1c2VkIHRvIHRyYWluLiBDcmVhdGVzIGEgZmVlZCBlbnRyeSB0aGF0IHdpbGwgbGF0ZXIgYmUgdXNlZFxuICAgKiB0byBwYXNzIGRhdGEgaW50byB0aGUgbW9kZWwuIEdlbmVyYXRlcyBgZXhhbXBsZUNvdW50YCBkYXRhIHBvaW50cy5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVUcmFpbmluZ0RhdGEoZXhhbXBsZUNvdW50OiBudW1iZXIpIHtcbiAgICB0aGlzLm1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgY29uc3QgcmF3SW5wdXRzID0gbmV3IEFycmF5KGV4YW1wbGVDb3VudCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4YW1wbGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHJhd0lucHV0c1tpXSA9IFtcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlUmFuZG9tQ2hhbm5lbFZhbHVlKCksIHRoaXMuZ2VuZXJhdGVSYW5kb21DaGFubmVsVmFsdWUoKSxcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlUmFuZG9tQ2hhbm5lbFZhbHVlKClcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgd2l0aGluIEFycmF5MURzIHNvIHRoYXQgbGVhcm5qcyBjYW4gdXNlIGl0LlxuICAgICAgY29uc3QgaW5wdXRBcnJheTogQXJyYXkxRFtdID1cbiAgICAgICAgICByYXdJbnB1dHMubWFwKGMgPT4gQXJyYXkxRC5uZXcodGhpcy5ub3JtYWxpemVDb2xvcihjKSkpO1xuICAgICAgY29uc3QgdGFyZ2V0QXJyYXk6IEFycmF5MURbXSA9IHJhd0lucHV0cy5tYXAoXG4gICAgICAgICAgYyA9PiBBcnJheTFELm5ldyhcbiAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmNvbXB1dGVDb21wbGVtZW50YXJ5Q29sb3IoYykpKSk7XG5cbiAgICAgIC8vIFRoaXMgcHJvdmlkZXIgd2lsbCBzaHVmZmxlIHRoZSB0cmFpbmluZyBkYXRhIChhbmQgd2lsbCBkbyBzbyBpbiBhIHdheVxuICAgICAgLy8gdGhhdCBkb2VzIG5vdCBzZXBhcmF0ZSB0aGUgaW5wdXQtdGFyZ2V0IHJlbGF0aW9uc2hpcCkuXG4gICAgICBjb25zdCBzaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID1cbiAgICAgICAgICBuZXcgSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKFxuICAgICAgICAgICAgICBbaW5wdXRBcnJheSwgdGFyZ2V0QXJyYXldKTtcbiAgICAgIGNvbnN0IFtpbnB1dFByb3ZpZGVyLCB0YXJnZXRQcm92aWRlcl0gPVxuICAgICAgICAgIHNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIuZ2V0SW5wdXRQcm92aWRlcnMoKTtcblxuICAgICAgLy8gTWFwcyB0ZW5zb3JzIHRvIElucHV0UHJvdmlkZXJzLlxuICAgICAgdGhpcy5mZWVkRW50cmllcyA9IFtcbiAgICAgICAge3RlbnNvcjogdGhpcy5pbnB1dFRlbnNvciwgZGF0YTogaW5wdXRQcm92aWRlcn0sXG4gICAgICAgIHt0ZW5zb3I6IHRoaXMudGFyZ2V0VGVuc29yLCBkYXRhOiB0YXJnZXRQcm92aWRlcn1cbiAgICAgIF07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlUmFuZG9tQ2hhbm5lbFZhbHVlKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgY29tcHV0aW5nIHRoZSBjb21wbGVtZW50YXJ5IGNvbG9yIGNhbWUgZnJvbSBhblxuICAgKiBhbnN3ZXIgYnkgRWRkIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzY1Nzk0MFxuICAgKi9cbiAgY29tcHV0ZUNvbXBsZW1lbnRhcnlDb2xvcihyZ2JDb2xvcjogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgbGV0IHIgPSByZ2JDb2xvclswXTtcbiAgICBsZXQgZyA9IHJnYkNvbG9yWzFdO1xuICAgIGxldCBiID0gcmdiQ29sb3JbMl07XG5cbiAgICAvLyBDb252ZXJ0IFJHQiB0byBIU0xcbiAgICAvLyBBZGFwdGVkIGZyb20gYW5zd2VyIGJ5IDB4MDAwZiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDk0NjA5Mi80OTM5NjMwXG4gICAgciAvPSAyNTUuMDtcbiAgICBnIC89IDI1NS4wO1xuICAgIGIgLz0gMjU1LjA7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgbGV0IGggPSAobWF4ICsgbWluKSAvIDIuMDtcbiAgICBsZXQgcyA9IGg7XG4gICAgY29uc3QgbCA9IGg7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDsgIC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSAobCA+IDAuNSA/IGQgLyAoMi4wIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKSk7XG5cbiAgICAgIGlmIChtYXggPT09IHIgJiYgZyA+PSBiKSB7XG4gICAgICAgIGggPSAxLjA0NzIgKiAoZyAtIGIpIC8gZDtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSByICYmIGcgPCBiKSB7XG4gICAgICAgIGggPSAxLjA0NzIgKiAoZyAtIGIpIC8gZCArIDYuMjgzMjtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICAgIGggPSAxLjA0NzIgKiAoYiAtIHIpIC8gZCArIDIuMDk0NDtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBiKSB7XG4gICAgICAgIGggPSAxLjA0NzIgKiAociAtIGcpIC8gZCArIDQuMTg4ODtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoID0gaCAvIDYuMjgzMiAqIDM2MC4wICsgMDtcblxuICAgIC8vIFNoaWZ0IGh1ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIHdoZWVsIGFuZCBjb252ZXJ0IHRvIFswLTFdIHZhbHVlXG4gICAgaCArPSAxODA7XG4gICAgaWYgKGggPiAzNjApIHtcbiAgICAgIGggLT0gMzYwO1xuICAgIH1cbiAgICBoIC89IDM2MDtcblxuICAgIC8vIENvbnZlcnQgaCBzIGFuZCBsIHZhbHVlcyBpbnRvIHIgZyBhbmQgYiB2YWx1ZXNcbiAgICAvLyBBZGFwdGVkIGZyb20gYW5zd2VyIGJ5IE1vaHNlbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDkzMDYwLzQ5Mzk2MzBcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gbDsgIC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHVlMnJnYiA9IChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYl0ubWFwKHYgPT4gTWF0aC5yb3VuZCh2ICogMjU1KSk7XG4gIH1cbn1cblxuY29uc3QgY29tcGxlbWVudGFyeUNvbG9yTW9kZWwgPSBuZXcgQ29tcGxlbWVudGFyeUNvbG9yTW9kZWwoKTtcblxuLy8gQ3JlYXRlIHRoZSBncmFwaCBvZiB0aGUgbW9kZWwuXG5jb21wbGVtZW50YXJ5Q29sb3JNb2RlbC5zZXR1cFNlc3Npb24oKTtcblxuLy8gT24gZXZlcnkgZnJhbWUsIHdlIHRyYWluIGFuZCB0aGVuIG1heWJlIHVwZGF0ZSB0aGUgVUkuXG5sZXQgc3RlcCA9IDA7XG5sZXQgY29zdCA9ICtJbmZpbml0eTtcblxuZnVuY3Rpb24gdHJhaW5BbmRNYXliZVJlbmRlcigpIHtcbiAgLy8gU3RvcHMgYXQgYSBjZXJ0YWluIHNldHBMaW1pdCBvciBjb3N0VGFyZ2V0LCB3aGF0ZXZlciBoYXBwZW5zIGZpcnN0XG4gIGNvbnN0IHN0ZXBMaW1pdCA9IDQyNDI7XG4gIGNvbnN0IGNvc3RUYXJnZXQgPSAxLjJlLTQ7XG4gIGlmIChzdGVwID49IHN0ZXBMaW1pdCkge1xuICAgIGZpbmlzaFRyYWluaW5nQW5kUmVuZGVyaW5nKGBSZWFjaGVkIHN0ZXAgbGltaXQgKCR7c3RlcExpbWl0fSlgKTtcbiAgICAvLyBTdG9wIHRyYWluaW5nLlxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29zdCA8PSBjb3N0VGFyZ2V0KSB7XG4gICAgZmluaXNoVHJhaW5pbmdBbmRSZW5kZXJpbmcoYFJlYWNoZWQgY29zdCB0YXJnZXQgKCR7Y29zdFRhcmdldH0pXFxuQ29zdDogJHtjb3N0fSBTdGVwOiR7c3RlcH1gKTtcbiAgICAvLyBTdG9wIHRyYWluaW5nXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhaW5pbmdBbmRSZW5kZXJpbmcobWVzc2FnZTpTdHJpbmcpOnZvaWQge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUubG9nKHRvdGFsVGltZSgpKTtcbiAgfVxuXG4gIC8vIFNjaGVkdWxlIHRoZSBuZXh0IGJhdGNoIHRvIGJlIHRyYWluZWQuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0cmFpbkFuZE1heWJlUmVuZGVyKTtcblxuICAvLyBXZSBvbmx5IGZldGNoIHRoZSBjb3N0IGV2ZXJ5IDUgc3RlcHMgYmVjYXVzZSBkb2luZyBzbyByZXF1aXJlcyBhIHRyYW5zZmVyXG4gIC8vIG9mIGRhdGEgZnJvbSB0aGUgR1BVLlxuICBjb25zdCBsb2NhbFN0ZXBzVG9SdW4gPSA1O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RlcHNUb1J1bjsgaSsrKSB7XG4gICAgY29zdCA9IGNvbXBsZW1lbnRhcnlDb2xvck1vZGVsLnRyYWluMUJhdGNoKGkgPT09IGxvY2FsU3RlcHNUb1J1biAtIDEpO1xuICAgIHN0ZXArKztcbiAgfVxuXG4gIC8vIFByaW50IGRhdGEgdG8gY29uc29sZSBzbyB0aGUgdXNlciBjYW4gaW5zcGVjdC5cbiAgY29uc29sZS5sb2coJ3N0ZXAnLCBzdGVwLCAnY29zdCcsIGNvc3QpO1xuXG4gIC8vIFZpc3VhbGl6ZSB0aGUgcHJlZGljdGVkIGNvbXBsZW1lbnQuXG4gIGNvbnN0IGNvbG9yUm93cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyW2RhdGEtb3JpZ2luYWwtY29sb3JdJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgcm93RWxlbWVudCA9IGNvbG9yUm93c1tpXTtcbiAgICBjb25zdCB0ZHMgPSByb3dFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RkJyk7XG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvciA9XG4gICAgICAgIChyb3dFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1jb2xvcicpIGFzIHN0cmluZylcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcblxuICAgIC8vIFZpc3VhbGl6ZSB0aGUgcHJlZGljdGVkIGNvbG9yLlxuICAgIGNvbnN0IHByZWRpY3RlZENvbG9yID0gY29tcGxlbWVudGFyeUNvbG9yTW9kZWwucHJlZGljdChvcmlnaW5hbENvbG9yKTtcbiAgICBwb3B1bGF0ZUNvbnRhaW5lcldpdGhDb2xvcihcbiAgICAgICAgdGRzWzJdLCBwcmVkaWN0ZWRDb2xvclswXSwgcHJlZGljdGVkQ29sb3JbMV0sIHByZWRpY3RlZENvbG9yWzJdKTtcbiAgfVxuICAvLyBVcGRhdGVzIG91dGVyIHJpbmcgb2YgcHJlZGljdGVkIGNvbG9yc1xuICBkMy5zZWxlY3RBbGwoXCIucHJlZGljdGVkXCIpXG4gICAgICAuc3R5bGUoXCJmaWxsXCIsXG4gICAgICAgIGZ1bmN0aW9uKGQ6YW55KXtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbENvbG9yOm51bWJlcltdID0gW3BhcnNlSW50KGQuZGF0YS5jb2xvci5zbGljZSgxLDMpLCAxNiksIHBhcnNlSW50KGQuZGF0YS5jb2xvci5zbGljZSgzLDUpLCAxNiksIHBhcnNlSW50KGQuZGF0YS5jb2xvci5zbGljZSg1LDcpLCAxNildO1xuICAgICAgICAgIGNvbnN0IHByZWRpY3RlZCA9IGNvbXBsZW1lbnRhcnlDb2xvck1vZGVsLnByZWRpY3Qob3JpZ2luYWxDb2xvcik7XG4gICAgICAgICAgZC5kYXRhLmNvc3QgPSBjb2xvckNvc3Qob3JpZ2luYWxDb2xvciwgcHJlZGljdGVkKTtcbiAgICAgICAgICByZXR1cm4gc2hhcnBSR0JDb2xvcihwcmVkaWN0ZWQpO1xuICAgICAgICAgfSk7XG5cbiAgLy8gRGVsZXRlcyBhbGwgdGVtcG9yYXJ5IHRleHRcbiAgZDMuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi50ZW1wVGV4dFwiKS5yZW1vdmUoKTtcbiAgLy8gQW5kIGNyZWF0ZSBuZXcgbGFiZWxzXG4gIGQzLnNlbGVjdChcInN2Z1wiKVxuICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcInhcIiwgLTEyMClcbiAgICAgIC5hdHRyKFwieVwiLCAtMzApXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwidGVtcFRleHRcIilcbiAgICAgIC5hdHRyKFwiZm9udC1zaXplXCIsIFwiMzZweFwiKVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcImJsYWNrXCIpXG4gICAgICAvLyBTdGVwIENvdW50XG4gICAgICAudGV4dChcIlN0ZXAgXCIrc3RlcCk7XG4gIGQzLnNlbGVjdChcInN2Z1wiKVxuICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcInhcIiwgLTEyMClcbiAgICAgIC5hdHRyKFwieVwiLCAgMjApXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwidGVtcFRleHRcIilcbiAgICAgIC5hdHRyKFwiZm9udC1zaXplXCIsIFwiMzZweFwiKVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcImJsYWNrXCIpXG4gICAgICAvLyBDdXJyZW50IGNvc3RcbiAgICAgIC50ZXh0KFwiQ29zdCBcIitjb3N0LnRvTG9jYWxlU3RyaW5nKFwiZW5cIiwge21heGltdW1GcmFjdGlvbkRpZ2l0czogOH0pKTtcbiAgICBkMy5zZWxlY3QoXCJzdmdcIilcbiAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgLmF0dHIoXCJ4XCIsIC0xMjApXG4gICAgICAuYXR0cihcInlcIiwgIDcwKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRlbXBUZXh0XCIpXG4gICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCBcIjM2cHhcIilcbiAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJibGFja1wiKVxuICAgICAgLy8gQ3VycmVudCBjb3N0XG4gICAgICAudGV4dChcIlRpbWUgXCIrdG90YWxUaW1lKCkudG9Mb2NhbGVTdHJpbmcoXCJlblwiLCB7bWF4aW11bUZyYWN0aW9uRGlnaXRzOiA4fSkpO1xuICAvLyBVcGRhdGVzIGNvbG9yIGxhYmVsc1xuICBkMy5zZWxlY3RBbGwoXCIucHJlZGljdGVkXCIpXG4gICAgICAuZWFjaChmdW5jdGlvbihkOmFueSwgaTphbnkpe1xuICAgICAgICBkMy5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidGVtcFRleHQgdHhQclwiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgXCIjcHJcIitpKVxuICAgICAgICAgICAgLmFwcGVuZChcInRzcGFuXCIpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIC0xMClcbiAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgOTUpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbihkOmFueSl7cmV0dXJuIGQzLnNlbGVjdChcIiNwclwiK2kpLnN0eWxlKFwiZmlsbFwiKS5zbGljZSg0LC0xKTt9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgLy8gRXN0aW1hdGVzIHRoZSBjb3N0IGZvciBhIHNpbmdsZSBvdXRwdXQgKGEgbGFiZWwsIGIgcHJlZGljdGVkKVxuICBmdW5jdGlvbiBjb2xvckNvc3QoYTpudW1iZXJbXSwgYjpudW1iZXJbXSk6bnVtYmVyIHtcbiAgICAvLyBOb3JtYWxpemUgY29sb3IgY2hhbm5lbHMgYmVmb3JlIGVzdGltYXRpbmcgc2luZ2xlIGNvbG9yIGxvc3NcbiAgICByZXR1cm4gTWF0aC5wb3coKE1hdGgucG93KChhWzBdLWJbMF0pLzI1NSwgMikrTWF0aC5wb3coKGFbMV0tYlsxXSkvMjU1LCAyKStNYXRoLnBvdygoYVsyXS1iWzJdKS8yNTUsIDIpKSwwLjUpLzM7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhcnBSR0JDb2xvcihjb2xvcjpudW1iZXJbXSk6U3RyaW5nIHtcbiAgcmV0dXJuIFwiI1wiICsgKFwiMFwiICsgY29sb3JbMF0udG9TdHJpbmcoMTYpKS5zbGljZSgtMilcbiAgICAgICAgICAgICArIChcIjBcIiArIGNvbG9yWzFdLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpXG4gICAgICAgICAgICAgKyAoXCIwXCIgKyBjb2xvclsyXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVDb250YWluZXJXaXRoQ29sb3IoXG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCwgcjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikge1xuICBjb25zdCBvcmlnaW5hbENvbG9yU3RyaW5nID0gJ3JnYignICsgW3IsIGcsIGJdLmpvaW4oJywnKSArICcpJztcbiAgY29udGFpbmVyLnRleHRDb250ZW50ID0gb3JpZ2luYWxDb2xvclN0cmluZztcblxuICBjb25zdCBjb2xvckJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb2xvckJveC5jbGFzc0xpc3QuYWRkKCdjb2xvci1ib3gnKTtcbiAgY29sb3JCb3guc3R5bGUuYmFja2dyb3VuZCA9IG9yaWdpbmFsQ29sb3JTdHJpbmc7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb2xvckJveCk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVaSgpIHtcbiAgdmFyIHRlc3RDb2xvcnM6YW55W10gPSBbXTtcbiAgY29uc3QgY29sb3JSb3dzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgndHJbZGF0YS1vcmlnaW5hbC1jb2xvcl0nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvclJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3dFbGVtZW50ID0gY29sb3JSb3dzW2ldO1xuICAgIGNvbnN0IHRkcyA9IHJvd0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndGQnKTtcbiAgICBjb25zdCBvcmlnaW5hbENvbG9yID1cbiAgICAgICAgKHJvd0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvbG9yJykgYXMgc3RyaW5nKVxuICAgICAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAodiA9PiBwYXJzZUludCh2LCAxMCkpO1xuXG4gICAgLy8gVmlzdWFsaXplIHRoZSBvcmlnaW5hbCBjb2xvci5cbiAgICBwb3B1bGF0ZUNvbnRhaW5lcldpdGhDb2xvcihcbiAgICAgICAgdGRzWzBdLCBvcmlnaW5hbENvbG9yWzBdLCBvcmlnaW5hbENvbG9yWzFdLCBvcmlnaW5hbENvbG9yWzJdKTtcblxuICAgIC8vIFZpc3VhbGl6ZSB0aGUgY29tcGxlbWVudGFyeSBjb2xvci5cbiAgICBjb25zdCBjb21wbGVtZW50ID1cbiAgICAgICAgY29tcGxlbWVudGFyeUNvbG9yTW9kZWwuY29tcHV0ZUNvbXBsZW1lbnRhcnlDb2xvcihvcmlnaW5hbENvbG9yKTtcbiAgICBwb3B1bGF0ZUNvbnRhaW5lcldpdGhDb2xvcihcbiAgICAgICAgdGRzWzFdLCBjb21wbGVtZW50WzBdLCBjb21wbGVtZW50WzFdLCBjb21wbGVtZW50WzJdKTtcbiAgICB0ZXN0Q29sb3JzLnB1c2goe2NvbG9yOnNoYXJwUkdCQ29sb3Iob3JpZ2luYWxDb2xvciksIHZhbHVlOiA0Mn0pO1xuICB9XG5cbiAgdmFyIHN2ZyA9IGQzLnNlbGVjdChcInN2Z1wiKTtcbiAgdmFyIGFyYyA9IFtkMy5hcmMoKS5pbm5lclJhZGl1cygyNTApLm91dGVyUmFkaXVzKDMyMCksXG4gICAgICAgICAgICAgZDMuYXJjKCkuaW5uZXJSYWRpdXMoMzUwKS5vdXRlclJhZGl1cyg0MjApLFxuICAgICAgICAgICAgIGQzLmFyYygpLmlubmVyUmFkaXVzKDQ1MCkub3V0ZXJSYWRpdXMoNTIwKV07XG4gIHZhciBwaWUgPSBkMy5waWUoKS52YWx1ZShmdW5jdGlvbihkOmFueSl7cmV0dXJuIGQudmFsdWU7fSkuc29ydChudWxsKTtcbiAgLy8gQ3JlYXRlcyB0aGUgaW5uZXIgY29sb3IgZG9udXRcbiAgY29uc3Qgd2lkdGhIZWlnaHQgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgLy8gU2V0cyBTVkcgcGFyYW1ldGVycyBhbmQgZHJhd3MgdGhlIHRocmVlIGNvbG9yIGRvbnV0c1xuICBzdmcuYXR0cihcIndpZHRoXCIsIHdpZHRoSGVpZ2h0KS5hdHRyKFwiaGVpZ2h0XCIsIHdpZHRoSGVpZ2h0KTtcbiAgc3ZnLnNlbGVjdEFsbChcIm9yaWdpbmFsXCIpXG4gICAgICAgIC5kYXRhKHBpZSh0ZXN0Q29sb3JzKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyY1swXSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkOmFueSl7cmV0dXJuIGQuZGF0YS5jb2xvcjt9KVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQ6YW55LCBpOmFueSl7cmV0dXJuIFwib3JcIitpO30pXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJvcmlnaW5hbFwiKTtcbiAgLy8gQ3JlYXRlcyB0aGUgbWlkZGxlIGNvbXBsZW1lbnRhcnkgY29sb3IgZG9udXRcbiAgc3ZnLnNlbGVjdEFsbChcImNvbXBsZW1lbnRcIilcbiAgICAgICAgLmRhdGEocGllKHRlc3RDb2xvcnMpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJjWzFdKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQ6YW55KXtyZXR1cm4gYWN0dWFsQ29tcGxlbWVudChkLmRhdGEuY29sb3IpO30pXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZDphbnksIGk6YW55KXtyZXR1cm4gXCJjb1wiK2k7fSlcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNvbXBsZW1lbnRcIik7XG4gIC8vIENyZWF0ZXMgdGhlIG91dGVyIHByZWRpY3RlZCBjb2xvciBkb251dFxuICBzdmcuc2VsZWN0QWxsKFwicHJlZGljdGVkXCIpXG4gICAgICAgIC5kYXRhKHBpZSh0ZXN0Q29sb3JzKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyY1syXSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBzaGFycFJHQkNvbG9yKFsyNTUsMjU1LDI1NV0pKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQ6YW55LCBpOmFueSl7cmV0dXJuIFwicHJcIitpO30pXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwcmVkaWN0ZWRcIik7XG4gIC8vIENyZWF0ZXMgdGhlIGxhYmVscyBmb3IgdGhlIG9yaWdpbmFsIGNvbG9yc1xuICBkMy5zZWxlY3RBbGwoXCIub3JpZ2luYWxcIilcbiAgICAuZWFjaChmdW5jdGlvbihkOmFueSwgaTphbnkpe1xuICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidHhPclwiKVxuICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBcIiNvclwiK2kpXG4gICAgICAgICAgLmFwcGVuZChcInRzcGFuXCIpXG4gICAgICAgICAgLmF0dHIoXCJkeVwiLCAtMTApXG4gICAgICAgICAgLmF0dHIoXCJkeFwiLCA1OClcbiAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZDphbnkpe3JldHVybiBkMy5zZWxlY3QoXCIjb3JcIitpKS5zdHlsZShcImZpbGxcIikuc2xpY2UoNCwtMSk7fSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIC8vIENyZWF0ZXMgdGhlIGxhYmVscyBmb3IgdGhlIGNvbXBsZW1lbnRhcnkgY29sb3JzXG4gIGQzLnNlbGVjdEFsbChcIi5jb21wbGVtZW50XCIpXG4gICAgLmVhY2goZnVuY3Rpb24oZDphbnksIGk6YW55KXtcbiAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInR4Q29cIilcbiAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgXCIjY29cIitpKVxuICAgICAgICAgIC5hcHBlbmQoXCJ0c3BhblwiKVxuICAgICAgICAgIC5hdHRyKFwiZHlcIiwgLTEwKVxuICAgICAgICAgIC5hdHRyKFwiZHhcIiwgNzgpXG4gICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQ6YW55KXtyZXR1cm4gZDMuc2VsZWN0KFwiI2NvXCIraSkuc3R5bGUoXCJmaWxsXCIpLnNsaWNlKDQsLTEpO30pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gIC8vIEFkZCBhbm5vdGF0aW9uc1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IFt7XG4gICAgbm90ZTogeyBsYWJlbDogXCJPcmlnaW5hbCBjb2xvcnMgKFJHQilcIn0sXG4gICAgeDogMjcyLCB5OiAtMjEyLFxuICAgIGR5OiAtMjM1LCBkeDogMTA1XG4gIH0se1xuICAgIG5vdGU6IHsgbGFiZWw6IFwiQ29tcHV0ZWQgY29tcGxlbWVudGFyeSBjb2xvcnMgKFJHQilcIn0sXG4gICAgeDogNDI1LCB5OiAtMTMwLFxuICAgIGR5OiAtMTYwLCBkeDogNTVcbiAgfV07XG5cbiAgY29uc3QgbWFrZUFubm90YXRpb25zID0gZDMuYW5ub3RhdGlvbigpLmFubm90YXRpb25zKGFubm90YXRpb25zKTtcbiAgZDMuc2VsZWN0KFwic3ZnXCIpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiYW5ub3RhdGlvbi1ncm91cFwiKS5jYWxsKG1ha2VBbm5vdGF0aW9ucyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgIGNvbnN0IGFubm90YXRpb25HID0gW3tcbiAgICAgIG5vdGU6IHsgbGFiZWw6IFwiR2VuZXJhdGVkIGNvbG9ycyAoUkdCKVwifSxcbiAgICAgIHg6IDQzOCwgeTogLTMyOCxcbiAgICAgIGR5OiAtODAsIGR4OiA2NVxuICAgIH1dLCBtYWtlQW5ub3RhdGlvbkcgPSBkMy5hbm5vdGF0aW9uKCkuYW5ub3RhdGlvbnMoYW5ub3RhdGlvbkcpO1xuXG4gICAgZDMuc2VsZWN0KFwic3ZnXCIpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiYW5ub3RhdGlvbi1ncm91cFwiKS5jYWxsKG1ha2VBbm5vdGF0aW9uRyk7XG4gIH0sIDEpO1xuICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZDMuc2VsZWN0QWxsKFwiLmFubm90YXRpb25zXCIpLnN0eWxlKFwib3BhY2l0eVwiLCAwKTt9LCAzMDAwMDApO1xuXG4gIC8vIENvbXB1dGVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbG9yIG9mIGFuIGlucHV0IHN0cmluZyBpbiB0aGUgI3JyZ2diYiBmb3JtYXQgYW5kIHJldHVybnNcbiAgLy8gdGhlIGNvbXBsZW1lbnRhcnkgY29sb3Igb24gdGhlIHNhbWUgbm90YXRpb25cbiAgZnVuY3Rpb24gYWN0dWFsQ29tcGxlbWVudChjb2xvcjpTdHJpbmcpOlN0cmluZyB7XG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvcjpudW1iZXJbXSA9IFtwYXJzZUludChjb2xvci5zbGljZSgxLDMpLCAxNiksIHBhcnNlSW50KGNvbG9yLnNsaWNlKDMsNSksIDE2KSwgcGFyc2VJbnQoY29sb3Iuc2xpY2UoNSw3KSwgMTYpXTtcbiAgICBjb25zdCBjb21wbGVtZW50ID0gY29tcGxlbWVudGFyeUNvbG9yTW9kZWwuY29tcHV0ZUNvbXBsZW1lbnRhcnlDb2xvcihvcmlnaW5hbENvbG9yKTtcbiAgICByZXR1cm4gc2hhcnBSR0JDb2xvcihjb21wbGVtZW50KTtcbiAgfVxufVxuXG5jb25zdCBzdGFydFRyYWluaW5nVGltZSA9IG5ldyBEYXRlKCk7XG4vLyBUb3RhbCB0aW1lIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIHRvdGFsVGltZSgpIHtcbiAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICByZXR1cm4gKG5vdy5nZXRUaW1lKCkgLSBzdGFydFRyYWluaW5nVGltZS5nZXRUaW1lKCkpLzYwMDAwO1xufVxuLy8gS2ljayBvZmYgdHJhaW5pbmcuXG5pbml0aWFsaXplVWkoKTtcbi8vIENhbGxpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRocm91Z2ggc2V0VGltZW91dFxuLy8gZ2l2ZXMgcm9vbSBmb3IgdGhlIGJyb3dzZXIgc2NyZWVuIGluaXRpYWxpemF0aW9uXG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCk6YW55e3JlcXVlc3RBbmltYXRpb25GcmFtZSh0cmFpbkFuZE1heWJlUmVuZGVyKTt9KTsiLCIiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIE1BTklGRVNUX0ZJTEUgPSAnbWFuaWZlc3QuanNvbic7XG52YXIgQ2hlY2twb2ludExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hlY2twb2ludExvYWRlcih1cmxQYXRoKSB7XG4gICAgICAgIHRoaXMudXJsUGF0aCA9IHVybFBhdGg7XG4gICAgICAgIGlmICh0aGlzLnVybFBhdGguY2hhckF0KHRoaXMudXJsUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLnVybFBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmxvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBfdGhpcy51cmxQYXRoICsgTUFOSUZFU1RfRklMRSk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BTklGRVNUX0ZJTEUgKyBcIiBub3QgZm91bmQgYXQgXCIgKyBfdGhpcy51cmxQYXRoICsgXCIuIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0Q2hlY2twb2ludE1hbmlmZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRBbGxWYXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5nZXRDaGVja3BvaW50TWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uIChjaGVja3BvaW50RGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZU5hbWVzID0gT2JqZWN0LmtleXMoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZVByb21pc2VzLnB1c2goX3RoaXMuZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCh2YXJpYWJsZVByb21pc2VzKS50aGVuKGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXNbdmFyaWFibGVOYW1lc1tpXV0gPSB2YXJpYWJsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISh2YXJOYW1lIGluIHRoaXMuY2hlY2twb2ludE1hbmlmZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCBub24tZXhpc3RhbnQgdmFyaWFibGUgJyArIHZhck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBfdGhpcy5jaGVja3BvaW50TWFuaWZlc3RbdmFyTmFtZV0uZmlsZW5hbWU7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgX3RoaXMudXJsUGF0aCArIGZuYW1lKTtcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmRhcnJheSA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLnNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmRhcnJheSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggdmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCI6IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRNYW5pZmVzdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSh2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QpO1xuICAgIH07XG4gICAgcmV0dXJuIENoZWNrcG9pbnRMb2FkZXI7XG59KCkpO1xuZXhwb3J0cy5DaGVja3BvaW50TG9hZGVyID0gQ2hlY2twb2ludExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcG9pbnRfbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFID0gMC4xO1xudmFyIEluTWVtb3J5RGF0YXNldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlEYXRhc2V0KGRhdGFTaGFwZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhU2hhcGVzID0gZGF0YVNoYXBlcztcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mbyA9IHt9O1xuICAgIH1cbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldERhdGFTaGFwZSA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNoYXBlc1tkYXRhSW5kZXhdO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0O1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0Lm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuZ2V0U3RhdHNGb3JEYXRhKGQpOyB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0U3RhdHNGb3JEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGlucHV0TWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgaW5wdXRNYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBleGFtcGxlSW5kaWNlcyA9IGRhdGEubWFwKGZ1bmN0aW9uIChleGFtcGxlLCBpKSB7IHJldHVybiBpOyB9KTtcbiAgICAgICAgdXRpbC5zaHVmZmxlKGV4YW1wbGVJbmRpY2VzKTtcbiAgICAgICAgZXhhbXBsZUluZGljZXMgPVxuICAgICAgICAgICAgZXhhbXBsZUluZGljZXMuc2xpY2UoZXhhbXBsZUluZGljZXMubGVuZ3RoICogU1RBVFNfU0FNUExFX1BFUkNFTlRBR0UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBkYXRhW2V4YW1wbGVJbmRpY2VzW2ldXS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRWYWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1pbiA9IE1hdGgubWluKGlucHV0TWluLCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRNYXggPSBNYXRoLm1heChpbnB1dE1heCwgaW5wdXRWYWx1ZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dE1pbjogaW5wdXRNaW4sXG4gICAgICAgICAgICBpbnB1dE1heDogaW5wdXRNYXgsXG4gICAgICAgICAgICBleGFtcGxlQ291bnQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgc2hhcGU6IGRhdGFbMF0uc2hhcGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZSA9IGZ1bmN0aW9uIChleGFtcGxlcywgY3VyTG93ZXJCb3VuZHMsIGN1clVwcGVyQm91bmRzLCBuZXdMb3dlckJvdW5kcywgbmV3VXBwZXJCb3VuZHMpIHtcbiAgICAgICAgdmFyIGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID0gKGN1clVwcGVyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIHZhciBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA9IChuZXdMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJlxuICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpO1xuICAgICAgICB2YXIgaW5wdXRTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGV4YW1wbGVzWzBdLnNoYXBlKTtcbiAgICAgICAgdmFyIG5ld0V4YW1wbGVzID0gW107XG4gICAgICAgIGV4YW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKGV4YW1wbGUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlcyA9IGV4YW1wbGUuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5wdXRTaXplKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyTG93ZXJCb3VuZCA9IGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHNbal0gOlxuICAgICAgICAgICAgICAgICAgICBjdXJMb3dlckJvdW5kcztcbiAgICAgICAgICAgICAgICB2YXIgY3VyVXBwZXJCb3VuZCA9IGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHNbal0gOlxuICAgICAgICAgICAgICAgICAgICBjdXJVcHBlckJvdW5kcztcbiAgICAgICAgICAgICAgICB2YXIgY3VyUmFuZ2UgPSBjdXJVcHBlckJvdW5kIC0gY3VyTG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TG93ZXJCb3VuZCA9IG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgICAgICAgICAgbmV3TG93ZXJCb3VuZHNbal0gOlxuICAgICAgICAgICAgICAgICAgICBuZXdMb3dlckJvdW5kcztcbiAgICAgICAgICAgICAgICB2YXIgbmV3VXBwZXJCb3VuZCA9IG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHNbal0gOlxuICAgICAgICAgICAgICAgICAgICBuZXdVcHBlckJvdW5kcztcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBuZXdVcHBlckJvdW5kIC0gbmV3TG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICBpZiAoY3VyUmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tqXSA9IG5ld0xvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZCArXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZSAqIChpbnB1dFZhbHVlc1tqXSAtIGN1ckxvd2VyQm91bmQpIC8gY3VyUmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RXhhbXBsZXMucHVzaChuZGFycmF5XzEuTkRBcnJheS5tYWtlKGV4YW1wbGUuc2hhcGUsIHsgdmFsdWVzOiBub3JtYWxpemVkVmFsdWVzIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdFeGFtcGxlcztcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuY29tcHV0ZUJvdW5kcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLmRhdGFzZXRbZGF0YUluZGV4XVswXS5zaGFwZSk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XSA9IHtcbiAgICAgICAgICAgIGlzTm9ybWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICBtaW5WYWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSksXG4gICAgICAgICAgICBtYXhWYWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNbaV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2ldID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKGV4YW1wbGUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlcyA9IGV4YW1wbGUuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdID0gTWF0aC5taW4oX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1trXSA9IE1hdGgubWF4KF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5ub3JtYWxpemVXaXRoaW5Cb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFJbmRleCA+PSB0aGlzLmRhdGFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGFJbmRleCBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRzKGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICB2YXIgY3VyVXBwZXJCb3VuZHM7XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kO1xuICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcztcbiAgICAgICAgICAgIGN1clVwcGVyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSA9IHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmlzTm9ybWFsaXplZCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkluZm8gIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUucmVtb3ZlTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYWluaW5nIG9yIHRlc3QgZGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UodGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcyk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUudW5ub3JtYWxpemVFeGFtcGxlcyA9IGZ1bmN0aW9uIChleGFtcGxlcywgZGF0YUluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShleGFtcGxlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhc2V0W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0W2ldW2pdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeURhdGFzZXQ7XG59KCkpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBJbk1lbW9yeURhdGFzZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhc2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoaW5wdXRzKSB7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5lcG9jaCA9IDA7XG4gICAgICAgIHRoaXMuc2h1ZmZsZWRJbmRpY2VzID0gdXRpbC5jcmVhdGVTaHVmZmxlZEluZGljZXMoaW5wdXRzWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubnVtSW5wdXRzID0gaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG51bUV4YW1wbGVzID0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuaW5wdXRzW2ldLmxlbmd0aCA9PT0gbnVtRXhhbXBsZXMsICdOdW1iZXIgb2YgZXhhbXBsZXMgbXVzdCBtYXRjaCBhY3Jvc3MgZGlmZmVyZW50IGlucHV0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gdGhpcy5pbnB1dHNbaV1bMF0uc2hhcGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW5wdXRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChpbnB1dFNoYXBlLCB0aGlzLmlucHV0c1tpXVtqXS5zaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRDdXJyZW50RXhhbXBsZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0dXJuSWR4ID0gdGhpcy5pZHg7XG4gICAgICAgIHRoaXMuaW5wdXRDb3VudGVyKys7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Q291bnRlciA+PSB0aGlzLm51bUlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5pZHgrKztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCA+PSB0aGlzLmlucHV0c1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5JZHg7XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldE5leHRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dElkKSB7XG4gICAgICAgIHZhciBjdXJyZW50RXhhbXBsZUluZGV4ID0gdGhpcy5nZXRDdXJyZW50RXhhbXBsZUluZGV4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0c1tpbnB1dElkXVt0aGlzLnNodWZmbGVkSW5kaWNlc1tjdXJyZW50RXhhbXBsZUluZGV4XV07XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldEVwb2NoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcG9jaDtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRQcm92aWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dFByb3ZpZGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIGlucHV0UHJvdmlkZXJzLnB1c2godGhpcy5nZXRJbnB1dFByb3ZpZGVyKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRQcm92aWRlcnM7XG4gICAgfTtcbiAgICByZXR1cm4gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xudmFyIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVyID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIHNodWZmbGVkSW5wdXRQcm92aWRlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROZXh0Q29weTogZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubGlrZShzaHVmZmxlZElucHV0UHJvdmlkZXIuZ2V0TmV4dElucHV0KGlucHV0SWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKG1hdGgsIGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXIgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5leHRDb3B5OiBmdW5jdGlvbiAobWF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRoLmNsb25lKHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3Bvc2VDb3B5OiBmdW5jdGlvbiAobWF0aCwgY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbn0oSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKSk7XG5leHBvcnRzLkluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0X3Byb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YXNldFwiKTtcbnZhciBQQVJTSU5HX0lNQUdFX0NBTlZBU19IRUlHSFRfUFggPSAxMDAwO1xuZnVuY3Rpb24gZ2V0WGhyRGF0YXNldENvbmZpZyhqc29uQ29uZmlnUGF0aCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGpzb25Db25maWdQYXRoKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRYaHJEYXRhc2V0Q29uZmlnID0gZ2V0WGhyRGF0YXNldENvbmZpZztcbnZhciBYaHJEYXRhc2V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWGhyRGF0YXNldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYaHJEYXRhc2V0KHhockRhdGFzZXRDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeGhyRGF0YXNldENvbmZpZy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhockRhdGFzZXRDb25maWcgPSB4aHJEYXRhc2V0Q29uZmlnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhockRhdGFzZXQucHJvdG90eXBlLmdldE5EQXJyYXkgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICB2YXIgZGF0YVByb21pc2UgPSBpbmZvLmRhdGFUeXBlID09PSAncG5nJyA/XG4gICAgICAgICAgICBwYXJzZVR5cGVkQXJyYXlGcm9tUG5nKGluZm8sIGluZm8uc2hhcGUpIDpcbiAgICAgICAgICAgIHBhcnNlVHlwZWRBcnJheUZyb21CaW5hcnkoaW5mbyk7XG4gICAgICAgIHJldHVybiBkYXRhUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGluZm8uc2hhcGUpO1xuICAgICAgICAgICAgdmFyIG5kYXJyYXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC8gaW5wdXRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gZGF0YS5zdWJhcnJheShpICogaW5wdXRTaXplLCAoaSArIDEpICogaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgbmRhcnJheSA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoaW5mby5zaGFwZSwgeyB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKSB9KTtcbiAgICAgICAgICAgICAgICBuZGFycmF5cy5wdXNoKG5kYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFhockRhdGFzZXQucHJvdG90eXBlLmZldGNoRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IF90aGlzLnhockRhdGFzZXRDb25maWcuZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF90aGlzLmdldE5EQXJyYXkoeCk7IH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhc2V0ID0gZGF0YTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWGhyRGF0YXNldDtcbn0oZGF0YXNldF8xLkluTWVtb3J5RGF0YXNldCkpO1xuZXhwb3J0cy5YaHJEYXRhc2V0ID0gWGhyRGF0YXNldDtcbmZ1bmN0aW9uIHBhcnNlVHlwZWRBcnJheUZyb21CaW5hcnkoaW5mbykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGluZm8ucGF0aCk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IChpbmZvLmRhdGFUeXBlID09PSAnZmxvYXQzMicpID9cbiAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHhoci5yZXNwb25zZSkgOlxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VHcmF5c2NhbGVJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCByZXN1bHRPZmZzZXQpIHtcbiAgICB2YXIgaWR4ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHRbaWR4KytdID0gZGF0YVtpXTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJHQkltYWdlRGF0YShkYXRhLCByZXN1bHQsIHJlc3VsdE9mZnNldCkge1xuICAgIHZhciBpZHggPSByZXN1bHRPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdFtpZHhdID0gZGF0YVtpXTtcbiAgICAgICAgcmVzdWx0W2lkeCArIDFdID0gZGF0YVtpICsgMV07XG4gICAgICAgIHJlc3VsdFtpZHggKyAyXSA9IGRhdGFbaSArIDJdO1xuICAgICAgICBpZHggKz0gMztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUltYWdlKGltZywgc2hhcGUpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBOID0gaW1nLmhlaWdodDtcbiAgICB2YXIgaW5wdXRTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTiAqIGlucHV0U2l6ZSk7XG4gICAgaWYgKGltZy53aWR0aCAhPT0gc2hhcGVbMF0gKiBzaGFwZVsxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSB3aWR0aCAoXCIgKyBpbWcud2lkdGggKyBcIikgbXVzdCBiZSBtdWx0aXBsZSBvZiBcIiArXG4gICAgICAgICAgICAoXCJyb3dzKmNvbHVtbnMgKFwiICsgc2hhcGVbMF0gKyBcIipcIiArIHNoYXBlWzFdICsgXCIpIG9mIHRoZSBuZGFycmF5XCIpKTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBQQVJTSU5HX0lNQUdFX0NBTlZBU19IRUlHSFRfUFg7XG4gICAgdmFyIHN4ID0gMDtcbiAgICB2YXIgc1dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHZhciBzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB2YXIgZHggPSAwO1xuICAgIHZhciBkeSA9IDA7XG4gICAgdmFyIGRXaWR0aCA9IHNXaWR0aDtcbiAgICB2YXIgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgdmFyIGRlcHRoID0gc2hhcGVbMl07XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIG51bVBhc3NlcyA9IE1hdGguY2VpbChOIC8gY2FudmFzLmhlaWdodCk7XG4gICAgZm9yICh2YXIgcGFzcyA9IDA7IHBhc3MgPCBudW1QYXNzZXM7ICsrcGFzcykge1xuICAgICAgICB2YXIgc3kgPSBwYXNzICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgaWYgKChwYXNzID09PSBudW1QYXNzZXMgLSAxKSAmJiAoTiAlIGNhbnZhcy5oZWlnaHQgPiAwKSkge1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IE4gJSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBkSGVpZ2h0ID0gc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsIGR4LCBkeSwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkuZGF0YTtcbiAgICAgICAgKGRlcHRoID09PSAxKSA/IHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgb2Zmc2V0KSA6XG4gICAgICAgICAgICBwYXJzZVJHQkltYWdlRGF0YShkYXRhLCByZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjYW52YXMuaGVpZ2h0ICogaW5wdXRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VUeXBlZEFycmF5RnJvbVBuZyhpbmZvLCBzaGFwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCAnJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbWFnZShpbWcsIHNoYXBlKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSAnJztcbiAgICAgICAgICAgIGltZyA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSBpbmZvLnBhdGg7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD14aHItZGF0YXNldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICAgIHZhciBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcbiAgICByZXR1cm4gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pXG4gICAgICAgIC50ZXN0KGEpIHx8XG4gICAgICAgIC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pXG4gICAgICAgICAgICAudGVzdChhLnN1YnN0cigwLCA0KSk7XG59XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXZpY2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZXZpY2VfdXRpbCA9IHJlcXVpcmUoXCIuL2RldmljZV91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJOVU1CRVJcIl0gPSAwXSA9IFwiTlVNQkVSXCI7XG4gICAgVHlwZVtUeXBlW1wiQk9PTEVBTlwiXSA9IDFdID0gXCJCT09MRUFOXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZXhwb3J0cy5VUkxfUFJPUEVSVElFUyA9IFtcbiAgICB7IG5hbWU6ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX1ZFUlNJT04nLCB0eXBlOiBUeXBlLk5VTUJFUiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LCB7XG4gICAgICAgIG5hbWU6ICdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJyxcbiAgICAgICAgdHlwZTogVHlwZS5CT09MRUFOXG4gICAgfVxuXTtcbmZ1bmN0aW9uIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBXZWJHTCByZW5kZXJpbmcgY29udGV4dCwgV2ViR0wgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHZhciB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fFxuICAgICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xufVxuZnVuY3Rpb24gbG9zZUNvbnRleHQoZ2wpIHtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9zZUNvbnRleHRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZiAobG9zZUNvbnRleHRFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gV0VCR0xfbG9zZV9jb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXZWJHTFZlcnNpb25FbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzV2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJFbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIHZhciBleHRlbnNpb25OYW1lID0gd2ViR0xWZXJzaW9uID09PSAxID8gJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScgOlxuICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMic7XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgICB2YXIgaXNFeHRFbmFibGVkID0gZXh0ICE9IG51bGw7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgIH1cbiAgICByZXR1cm4gaXNFeHRFbmFibGVkO1xufVxuZnVuY3Rpb24gaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBpZiAoZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IHdlYkdMVmVyc2lvbiA9PT0gMiA/IGdsLlJHQkEzMkYgOiBnbC5SR0JBO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHZhciBmcmFtZUJ1ZmZlckNvbXBsZXRlID0gKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBnbC5SR0JBLCBnbC5GTE9BVCwgbmV3IEZsb2F0MzJBcnJheSg0KSk7XG4gICAgdmFyIHJlYWRQaXhlbHNOb0Vycm9yID0gZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG4gICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgIHJldHVybiBmcmFtZUJ1ZmZlckNvbXBsZXRlICYmIHJlYWRQaXhlbHNOb0Vycm9yO1xufVxuZnVuY3Rpb24gaXNXZWJHTEdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbkVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMnKTtcbiAgICB2YXIgaXNFbmFibGVkID0gZXh0ICE9IG51bGw7XG4gICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgIHJldHVybiBpc0VuYWJsZWQ7XG59XG52YXIgRW52aXJvbm1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudmlyb25tZW50KGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcbiAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgaW4gdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWF0dXJlc1tmZWF0dXJlXSA9IHRoaXMuZXZhbHVhdGVGZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5ldmFsdWF0ZUZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJykge1xuICAgICAgICAgICAgdmFyIHdlYkdMVmVyc2lvbiA9IHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgICAgICAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzV2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJFbmFibGVkKHdlYkdMVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSAmJlxuICAgICAgICAgICAgICAgICFkZXZpY2VfdXRpbC5pc01vYmlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9WRVJTSU9OJykge1xuICAgICAgICAgICAgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQodGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNXZWJHTEdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbkVuYWJsZWQodGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmZWF0dXJlIFwiICsgZmVhdHVyZSArIFwiLlwiKTtcbiAgICB9O1xuICAgIHJldHVybiBFbnZpcm9ubWVudDtcbn0oKSk7XG5leHBvcnRzLkVudmlyb25tZW50ID0gRW52aXJvbm1lbnQ7XG52YXIgREVFUExFQVJOSlNfRkxBR1NfUFJFRklYID0gJ2RsanNmbGFncyc7XG5mdW5jdGlvbiBnZXRGZWF0dXJlc0Zyb21VUkwoKSB7XG4gICAgdmFyIGZlYXR1cmVzID0ge307XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgdmFyIHVybFBhcmFtcyA9IHV0aWwuZ2V0UXVlcnlQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgaWYgKERFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWCBpbiB1cmxQYXJhbXMpIHtcbiAgICAgICAgdmFyIHVybEZsYWdzXzEgPSB7fTtcbiAgICAgICAgdmFyIGtleVZhbHVlcyA9IHVybFBhcmFtc1tERUVQTEVBUk5KU19GTEFHU19QUkVGSVhdLnNwbGl0KCcsJyk7XG4gICAgICAgIGtleVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hID0ga2V5VmFsdWUuc3BsaXQoJzonKSwga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICB1cmxGbGFnc18xW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydHMuVVJMX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAodXJsUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS5uYW1lIGluIHVybEZsYWdzXzEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIiArIHVybFByb3BlcnR5Lm5hbWUgKyBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIHVybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV0pKTtcbiAgICAgICAgICAgICAgICBpZiAodXJsUHJvcGVydHkudHlwZSA9PT0gVHlwZS5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSArdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUHJvcGVydHkudHlwZSA9PT0gVHlwZS5CT09MRUFOKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBVUkwgcGFyYW06IFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5leHBvcnRzLkVOViA9IG5ldyBFbnZpcm9ubWVudChnZXRGZWF0dXJlc0Zyb21VUkwoKSk7XG5mdW5jdGlvbiBzZXRFbnZpcm9ubWVudChlbnZpcm9ubWVudCkge1xuICAgIGV4cG9ydHMuRU5WID0gZW52aXJvbm1lbnQ7XG59XG5leHBvcnRzLnNldEVudmlyb25tZW50ID0gc2V0RW52aXJvbm1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi9tYXRoL2NvbmNhdF91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuLi9tYXRoL2NvbnZfdXRpbFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBHcmFwaExheWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhMYXllcnMoZykge1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgIH1cbiAgICBHcmFwaExheWVycy5wcm90b3R5cGUuZGVuc2UgPSBmdW5jdGlvbiAobmFtZSwgeCwgdW5pdHMsIGFjdGl2YXRpb24sIHVzZUJpYXMsIGtlcm5lbEluaXRpYWxpemVyLCBiaWFzSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBhY3RpdmF0aW9uID0gbnVsbDsgfVxuICAgICAgICBpZiAodXNlQmlhcyA9PT0gdm9pZCAwKSB7IHVzZUJpYXMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChrZXJuZWxJbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IGtlcm5lbEluaXRpYWxpemVyID0gbmV3IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyKCk7IH1cbiAgICAgICAgaWYgKGJpYXNJbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IGJpYXNJbml0aWFsaXplciA9IG5ldyBpbml0aWFsaXplcnNfMS5aZXJvc0luaXRpYWxpemVyKCk7IH1cbiAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLmcudmFyaWFibGUobmFtZSArICctd2VpZ2h0cycsIGtlcm5lbEluaXRpYWxpemVyLmluaXRpYWxpemUoW3guc2hhcGVbMF0sIHVuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuZy5tYXRtdWwoeCwgd2VpZ2h0cyk7XG4gICAgICAgIGlmICh1c2VCaWFzKSB7XG4gICAgICAgICAgICB2YXIgYmlhcyA9IHRoaXMuZy52YXJpYWJsZShuYW1lICsgJy1iaWFzJywgYmlhc0luaXRpYWxpemVyLmluaXRpYWxpemUoW3VuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcbiAgICAgICAgICAgIG91dCA9IHRoaXMuZy5hZGQob3V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQgPSBhY3RpdmF0aW9uKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaExheWVycztcbn0oKSk7XG5leHBvcnRzLkdyYXBoTGF5ZXJzID0gR3JhcGhMYXllcnM7XG52YXIgR3JhcGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoKCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IEdyYXBoTGF5ZXJzKHRoaXMpO1xuICAgIH1cbiAgICBHcmFwaC5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBWYXJpYWJsZU5vZGUodGhpcywgbmFtZSwgZGF0YSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKG5hbWUsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFBsYWNlaG9sZGVyTm9kZSh0aGlzLCBuYW1lLCBzaGFwZSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbnN0YW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdmFyIGZsYXRWYWx1ZXMgPSB1dGlsLmZsYXR0ZW4odmFsdWUpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRWYWx1ZXMpO1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UodXRpbC5pbmZlclNoYXBlKHZhbHVlKSwgeyB2YWx1ZXM6IHZhbHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgY29uc3RhbnQgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25zdGFudE5vZGUodGhpcywgZmluYWxWYWx1ZSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAoeCwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUmVzaGFwZU5vZGUodGhpcywgJ1Jlc2hhcGUnLCB4LCBzaGFwZSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmZ1c2VkTGluZWFyQ29tYmluYXRpb24gPSBmdW5jdGlvbiAoeDEsIHgyLCBjMSwgYzIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUodGhpcywgeDEsIHgyLCBjMSwgYzIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEFkZE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFN1YnRyYWN0Tm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTXVsdGlwbHlOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRGl2aWRlTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZWR1Y2VTdW0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZWR1Y2VTdW1Ob2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5jb25jYXQzZCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uY2F0M0ROb2RlKHRoaXMsIHgxLCB4MiwgYXhpcykpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm1hdG11bCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTWF0TXVsTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5jb252MmQgPSBmdW5jdGlvbiAoeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbnZvbHV0aW9uMkROb2RlKHRoaXMsIHgsIHcsIGIsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgZmllbGRTaXplLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTWF4UG9vbE5vZGUodGhpcywgeCwgZmllbGRTaXplLCBzdHJpZGUsIHplcm9QYWQpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBFeHBOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBMb2dOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUmVMVU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmxlYWt5UmVsdSA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBMZWFreVJlTFVOb2RlKHRoaXMsIHgsIGFscGhhKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFRhbkhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU2lnbW9pZE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNxdWFyZU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNvZnRtYXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTb2Z0bWF4Tm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc29mdG1heENyb3NzRW50cm9weUNvc3QgPSBmdW5jdGlvbiAoeCwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSh0aGlzLCB4LCB0YXJnZXQpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tZWFuU3F1YXJlZENvc3QgPSBmdW5jdGlvbiAobGFiZWwsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTWVhblNxdWFyZWRDb3N0Tm9kZSh0aGlzLCBsYWJlbCwgcHJlZGljdGlvbikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFyZ21heCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEFyZ01heE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFyZ21heEVxdWFscyA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4RXF1YWxzTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hZGROb2RlQW5kUmV0dXJuT3V0cHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiBub2RlLm91dHB1dDtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGg7XG59KCkpO1xuZXhwb3J0cy5HcmFwaCA9IEdyYXBoO1xudmFyIFRlbnNvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yKHNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5pZCA9IFRlbnNvci5uZXh0SUQrKztcbiAgICB9XG4gICAgVGVuc29yLm5leHRJRCA9IDA7XG4gICAgcmV0dXJuIFRlbnNvcjtcbn0oKSk7XG5leHBvcnRzLlRlbnNvciA9IFRlbnNvcjtcbnZhciBOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKGdyYXBoLCBuYW1lLCBpbnB1dHMsIG91dHB1dCkge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgdGhpcy5pZCA9IE5vZGUubmV4dElEKys7XG4gICAgICAgIG91dHB1dC5ub2RlID0gdGhpcztcbiAgICB9XG4gICAgTm9kZS5uZXh0SUQgPSAwO1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG52YXIgVmFyaWFibGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFyaWFibGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhcmlhYmxlTm9kZShncmFwaCwgbmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZhcmlhYmxlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuZGF0YSAhPSBudWxsLCAnRXJyb3IgYWRkaW5nIHZhcmlhYmxlIG9wOiBEYXRhIGZvciB2YXJpYWJsZSBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuVmFyaWFibGVOb2RlID0gVmFyaWFibGVOb2RlO1xudmFyIFBsYWNlaG9sZGVyTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYWNlaG9sZGVyTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQbGFjZWhvbGRlck5vZGUoZ3JhcGgsIG5hbWUsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3Ioc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQbGFjZWhvbGRlck5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlck5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUGxhY2Vob2xkZXJOb2RlID0gUGxhY2Vob2xkZXJOb2RlO1xudmFyIENvbnN0YW50Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudE5vZGUoZ3JhcGgsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25zdGFudCcsIHt9LCBuZXcgVGVuc29yKGRhdGEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25zdGFudE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmRhdGEgIT0gbnVsbCwgJ0Vycm9yIGFkZGluZyBjb25zdGFudDogZGF0YSBmb3IgcGxhY2Vob2xkZXIgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uc3RhbnROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbnN0YW50Tm9kZSA9IENvbnN0YW50Tm9kZTtcbnZhciBSZXNoYXBlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc2hhcGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2hhcGVOb2RlKGdyYXBoLCBuYW1lLCB4LCBzaGFwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwgeyB4OiB4IH0sIG5ldyBUZW5zb3Ioc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzaGFwZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy54LnNoYXBlKTtcbiAgICAgICAgdmFyIHNoYXBlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnNoYXBlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeFNpemUgPT09IHNoYXBlU2l6ZSwgXCJFcnJvciBtYWtpbmcgcmVzaGFwZSBvcGVyYXRpb246IGlucHV0IHRvIHJlc2hhcGUgJ1wiICsgdGhpcy5uYW1lICsgXCInXCIgK1xuICAgICAgICAgICAgKFwiIG9mIHNoYXBlIChcIiArIHRoaXMueC5zaGFwZSArIFwiKSBkb2VzIG5vdCBtYXRjaCBzaXplIG9mIFwiKSArXG4gICAgICAgICAgICAoXCJyZXF1ZXN0ZWQgc2hhcGUgXCIgKyB0aGlzLnNoYXBlICsgXCIuXCIpKTtcbiAgICB9O1xuICAgIFJlc2hhcGVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlc2hhcGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlc2hhcGVOb2RlID0gUmVzaGFwZU5vZGU7XG52YXIgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZShncmFwaCwgdDEsIHQyLCBjMSwgYzIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMaW5lYXIgQ29tYmluYXRpb24nLCB7IHQxOiB0MSwgdDI6IHQyLCBjMTogYzEsIGMyOiBjMiB9LCBuZXcgVGVuc29yKHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgX3RoaXMuYzEgPSBjMTtcbiAgICAgICAgX3RoaXMuYzIgPSBjMjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSk7XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhclNoYXBlKHRoaXMuYzEuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBmdXNlZExpbmVhckNvbWJpbmF0aW9uOiBjMSBpcyBub3QgYSBzY2FsYXIsIGdvdCAnICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZTogXCIgKyB0aGlzLmMxLnNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMi5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMyIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICAgICAgIChcInNoYXBlOiBcIiArIHRoaXMuYzIuc2hhcGUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDEgPSAndDEnO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQyID0gJ3QyJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMSA9ICdjMSc7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzIgPSAnYzInO1xuICAgIHJldHVybiBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSA9IEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlO1xudmFyIEFkZE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkZE5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0FkZCcsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRkTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIGFkZCBvcGVyYXRpb24gb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIFwiICsgdGhpcy50MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMudDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBBZGROb2RlLlQxID0gJ3QxJztcbiAgICBBZGROb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gQWRkTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5BZGROb2RlID0gQWRkTm9kZTtcbnZhciBTdWJ0cmFjdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJ0cmFjdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VidHJhY3ROb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTdWJ0cmFjdCcsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidHJhY3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgc3VidHJhY3Qgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIFwiICsgdGhpcy50MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMudDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBTdWJ0cmFjdE5vZGUuVDEgPSAndDEnO1xuICAgIFN1YnRyYWN0Tm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIFN1YnRyYWN0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TdWJ0cmFjdE5vZGUgPSBTdWJ0cmFjdE5vZGU7XG52YXIgTXVsdGlwbHlOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlwbHlOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpcGx5Tm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTXVsdGlwbHknLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE11bHRpcGx5Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIG11bHRpcGx5IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgTXVsdGlwbHlOb2RlLlQxID0gJ3QxJztcbiAgICBNdWx0aXBseU5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBNdWx0aXBseU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTXVsdGlwbHlOb2RlID0gTXVsdGlwbHlOb2RlO1xudmFyIERpdmlkZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXZpZGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpdmlkZU5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0RpdmlkZScsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGl2aWRlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIGRpdmlkZSBvcDogb25lIG9mIGlucHV0cyBtdXN0IGJlIHNjYWxhciBvciB0aGUgJyArXG4gICAgICAgICAgICAoXCJzaGFwZXMgXCIgKyB0aGlzLnQxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy50Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICB9O1xuICAgIERpdmlkZU5vZGUuVDEgPSAndDEnO1xuICAgIERpdmlkZU5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBEaXZpZGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkRpdmlkZU5vZGUgPSBEaXZpZGVOb2RlO1xudmFyIFJlZHVjZVN1bU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWR1Y2VTdW1Ob2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZHVjZVN1bU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnUmVkdWNlU3VtJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoW10pKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWR1Y2VTdW1Ob2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBSZWR1Y2VTdW1Ob2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlZHVjZVN1bU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUmVkdWNlU3VtTm9kZSA9IFJlZHVjZVN1bU5vZGU7XG52YXIgQ29uY2F0M0ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNETm9kZShncmFwaCwgeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uY2F0M0QnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcykpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQzRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXModGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSwgdGhpcy5heGlzKTtcbiAgICB9O1xuICAgIENvbmNhdDNETm9kZS5YMSA9ICd4MSc7XG4gICAgQ29uY2F0M0ROb2RlLlgyID0gJ3gyJztcbiAgICBDb25jYXQzRE5vZGUuQVhJUyA9ICdheGlzJztcbiAgICByZXR1cm4gQ29uY2F0M0ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbmNhdDNETm9kZSA9IENvbmNhdDNETm9kZTtcbmZ1bmN0aW9uIGdldE1hdE11bE91dHB1dFNoYXBlKHgxU2hhcGUsIHgyU2hhcGUpIHtcbiAgICBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIFt4MlNoYXBlWzFdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDIgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFt4MVNoYXBlWzBdXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MVNoYXBlWzBdLCB4MlNoYXBlWzFdXTtcbn1cbnZhciBNYXRNdWxOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0TXVsTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWxOb2RlKGdyYXBoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNYXRNdWwnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF0TXVsTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVsxXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IGlubmVyIHNoYXBlcyBvZiBtYXRyaWNlcyB3aXRoIHNoYXBlcyAnICtcbiAgICAgICAgICAgICAgICAodGhpcy54MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMueDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMV0gPT09IHRoaXMueDIuc2hhcGVbMF0sICdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBzZWNvbmQgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIHNoYXBlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMueDEuc2hhcGUudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgKFwiIG11c3QgbWF0Y2ggc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSBcIiArIHRoaXMueDIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAxICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLngxLnNoYXBlWzBdID09PSB0aGlzLngyLnNoYXBlWzBdLCBcIkVycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNpemUgb2YgdmVjdG9yIHdpdGggc2hhcGUgXCIgKyB0aGlzLngxLnNoYXBlICtcbiAgICAgICAgICAgICAgICBcIiBtdXN0IG1hdGNoIGZpcnN0IGRpbWVuc2lvbiBvZiBtYXRyaXggd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgKFwic2hhcGUgXCIgKyB0aGlzLngyLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5wdXRzIG11c3QgYmUgdmVjdG9ycyBvciBtYXRyaWNlcy4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0TXVsTm9kZS5YMSA9ICd4MSc7XG4gICAgTWF0TXVsTm9kZS5YMiA9ICd4Mic7XG4gICAgcmV0dXJuIE1hdE11bE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWF0TXVsTm9kZSA9IE1hdE11bE5vZGU7XG52YXIgQ29udm9sdXRpb24yRE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252b2x1dGlvbjJETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252b2x1dGlvbjJETm9kZShncmFwaCwgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29udm9sdXRpb24gMkQnLCB7IHg6IHgsIHc6IHcsIGI6IGIgfSwgbmV3IFRlbnNvcihjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoeC5zaGFwZSwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy53ID0gdztcbiAgICAgICAgX3RoaXMuYiA9IGI7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMub3V0cHV0RGVwdGggPSBvdXRwdXREZXB0aDtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBfdGhpcy56ZXJvUGFkID0gemVyb1BhZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252b2x1dGlvbjJETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDMsICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy54LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy53LnNoYXBlLmxlbmd0aCA9PT0gNCwgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IHdlaWdodHMgbXVzdCBiZSBvZiByYW5rIDQsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgKHRoaXMudy5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuYi5zaGFwZS5sZW5ndGggPT09IDEsICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiBiaWFzZXMgbXVzdCBiZSBvZiByYW5rIDEsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgKHRoaXMuYi5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZVsyXSA9PT0gdGhpcy53LnNoYXBlWzJdLCBcIkVycm9yIGFkZGluZyBjb252MmQgb3A6IGRlcHRoIG9mIGlucHV0IChcIiArIHRoaXMueC5zaGFwZVsyXSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciB3ZWlnaHRzIChcIiArIHRoaXMudy5zaGFwZVsyXSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRE5vZGUuWCA9ICd4JztcbiAgICBDb252b2x1dGlvbjJETm9kZS5XID0gJ3cnO1xuICAgIENvbnZvbHV0aW9uMkROb2RlLkIgPSAnYic7XG4gICAgcmV0dXJuIENvbnZvbHV0aW9uMkROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbnZvbHV0aW9uMkROb2RlID0gQ29udm9sdXRpb24yRE5vZGU7XG52YXIgTWF4UG9vbE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhQb29sTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhQb29sTm9kZShncmFwaCwgeCwgZmllbGRTaXplLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNYXggcG9vbCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmaWVsZFNpemUsIHguc2hhcGVbMl0sIHN0cmlkZSwgemVyb1BhZCkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1heFBvb2xOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMywgJ0Vycm9yIGFkZGluZyBtYXhQb29sIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy54LnNoYXBlICsgXCIuXCIpKTtcbiAgICB9O1xuICAgIE1heFBvb2xOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIE1heFBvb2xOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk1heFBvb2xOb2RlID0gTWF4UG9vbE5vZGU7XG52YXIgUmVMVU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZUxVTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUxVTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdSZUxVJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlTFVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBSZUxVTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBSZUxVTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5SZUxVTm9kZSA9IFJlTFVOb2RlO1xudmFyIExlYWt5UmVMVU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWFreVJlTFVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlYWt5UmVMVU5vZGUoZ3JhcGgsIHgsIGFscGhhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTGVha3lSZUxVJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFscGhhID0gYWxwaGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGVha3lSZUxVTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTGVha3lSZUxVTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBMZWFreVJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkxlYWt5UmVMVU5vZGUgPSBMZWFreVJlTFVOb2RlO1xudmFyIEV4cE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHBOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnRXhwJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIEV4cE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEV4cE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gRXhwTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5FeHBOb2RlID0gRXhwTm9kZTtcbnZhciBMb2dOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2dOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0xvZycsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMb2dOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBMb2dOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIExvZ05vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTG9nTm9kZSA9IExvZ05vZGU7XG52YXIgVGFuSE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYW5ITm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYW5ITm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdUYW5IJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhbkhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBUYW5ITm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBUYW5ITm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5UYW5ITm9kZSA9IFRhbkhOb2RlO1xudmFyIFNpZ21vaWROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbW9pZE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbW9pZE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU2lnbW9pZCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTaWdtb2lkTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgU2lnbW9pZE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU2lnbW9pZE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU2lnbW9pZE5vZGUgPSBTaWdtb2lkTm9kZTtcbnZhciBTcXVhcmVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3F1YXJlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTcXVhcmVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NxdWFyZScsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTcXVhcmVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBTcXVhcmVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFNxdWFyZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU3F1YXJlTm9kZSA9IFNxdWFyZU5vZGU7XG52YXIgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZShncmFwaCwgeCwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU29mdG1heENyb3NzRW50cm9weUNvc3QnLCB7IHg6IHgsIHRhcmdldDogdGFyZ2V0IH0sIG5ldyBUZW5zb3IoW10pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy54LnNoYXBlLCB0aGlzLnRhcmdldC5zaGFwZSksIFwiRXJyb3IgYWRkaW5nIHNvZnRtYXhDcm9zc0VudHJvcHlDb3N0IG9wOiB4IHNoYXBlIChcIiArIHRoaXMueC5zaGFwZSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIHRhcmdldCBzaGFwZSAoXCIgKyB0aGlzLnRhcmdldC5zaGFwZSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlggPSAneCc7XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlRBUkdFVCA9ICd0YXJnZXQnO1xuICAgIHJldHVybiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlID0gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlO1xudmFyIFNvZnRtYXhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdG1heE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTb2Z0bWF4JywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMSwgJ1RoZSBpbnB1dCB0byBhIHNvZnRtYXggbXVzdCBiZSBhIDEtRCB0ZW5zb3InKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlWzBdID49IDIsICdUaGUgaW5wdXQgdG8gYSBzb2Z0bWF4IG11c3QgaGF2ZSBhdCBsZWFzdCAyIHZhbHVlcycpO1xuICAgIH07XG4gICAgU29mdG1heE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU29mdG1heE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU29mdG1heE5vZGUgPSBTb2Z0bWF4Tm9kZTtcbnZhciBNZWFuU3F1YXJlZENvc3ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhblNxdWFyZWRDb3N0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWFuU3F1YXJlZENvc3ROb2RlKGdyYXBoLCBsYWJlbCwgcHJlZGljdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01lYW4gU3F1YXJlZCBDb3N0JywgeyBsYWJlbDogbGFiZWwsIHByZWRpY3Rpb246IHByZWRpY3Rpb24gfSwgbmV3IFRlbnNvcihbXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIF90aGlzLnByZWRpY3Rpb24gPSBwcmVkaWN0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMubGFiZWwuc2hhcGUsIHRoaXMucHJlZGljdGlvbi5zaGFwZSksIFwiRXJyb3IgYWRkaW5nIG1lYW5TcXVhcmVkQ29zdCBvcDogbGFiZWwgc2hhcGUgKFwiICsgdGhpcy5sYWJlbC5zaGFwZSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIHByZWRpY3Rpb24gc2hhcGUgKFwiICsgdGhpcy5wcmVkaWN0aW9uLnNoYXBlICsgXCIpLlwiKSk7XG4gICAgfTtcbiAgICBNZWFuU3F1YXJlZENvc3ROb2RlLkxBQkVMID0gJ2xhYmVsJztcbiAgICBNZWFuU3F1YXJlZENvc3ROb2RlLlBSRURJQ1RJT04gPSAncHJlZGljdGlvbic7XG4gICAgcmV0dXJuIE1lYW5TcXVhcmVkQ29zdE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWVhblNxdWFyZWRDb3N0Tm9kZSA9IE1lYW5TcXVhcmVkQ29zdE5vZGU7XG52YXIgQXJnTWF4Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4Tm9kZShncmFwaCwgeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0FyZ01heCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKFsxXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy54LnNoYXBlKSA+IDAsICdFcnJvciBhZGRpbmcgYXJnbWF4IG9wOiBpbnB1dCB0ZW5zb3IgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICB9O1xuICAgIEFyZ01heE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gQXJnTWF4Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5BcmdNYXhOb2RlID0gQXJnTWF4Tm9kZTtcbnZhciBBcmdNYXhFcXVhbHNOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4RXF1YWxzTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhFcXVhbHNOb2RlKGdyYXBoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdBcmdNYXhFcXVhbHMnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoWzFdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhFcXVhbHNOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLngxLnNoYXBlLCB0aGlzLngyLnNoYXBlKSwgXCJFcnJvciBhZGRpbmcgQXJnTWF4RXF1YWxzIG9wOiB4MSBzaGFwZSAoXCIgKyB0aGlzLngxLnNoYXBlICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggeDIgc2hhcGUgKFwiICsgdGhpcy54Mi5zaGFwZSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5YMSA9ICd4MSc7XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5YMiA9ICd4Mic7XG4gICAgcmV0dXJuIEFyZ01heEVxdWFsc05vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQXJnTWF4RXF1YWxzTm9kZSA9IEFyZ01heEVxdWFsc05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG52YXIgcHJpb3JpdHlfcXVldWUgPSByZXF1aXJlKFwiLi9wcmlvcml0eV9xdWV1ZVwiKTtcbnZhciBwcmlvcml0eV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcHJpb3JpdHlfcXVldWVcIik7XG5mdW5jdGlvbiBnZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KG5vZGVzLCB0ZXJtaW5hdGluZ05vZGVzKSB7XG4gICAgdmFyIHRlcm1pbmF0aW5nTm9kZU1hcCA9IHt9O1xuICAgIHZhciBzZWVuID0ge307XG4gICAgdmFyIHNldCA9IFtdO1xuICAgIHZhciB2aXNpdCA9IG5vZGVzLnNsaWNlKCk7XG4gICAgdGVybWluYXRpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXJtaW5hdGluZ05vZGVNYXBbbm9kZS5pZF0gPSBub2RlOyB9KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1ciA9IHZpc2l0LnBvcCgpO1xuICAgICAgICBpZiAoc2VlbltjdXIuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hdGluZ05vZGVNYXBbY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VyLmlucHV0cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5wdXROYW1lKSB7IHJldHVybiBjdXIuaW5wdXRzW2lucHV0TmFtZV07IH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gdmlzaXQucHVzaChpbnB1dC5ub2RlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQucHVzaChjdXIpO1xuICAgICAgICAgICAgc2VlbltjdXIuaWRdID0gY3VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAodmlzaXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIF9sb29wXzEoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbmV4cG9ydHMuZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldCA9IGdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIHNldCA9IFtdO1xuICAgIHZhciBub2RlSW5kaWNlcyA9IHt9O1xuICAgIHZhciBwZW5kaW5nRGVwZW5kZW5jaWVzID0ge307XG4gICAgdmFyIG5vZGVRdWV1ZSA9IG5ldyBwcmlvcml0eV9xdWV1ZV8xLlByaW9yaXR5UXVldWUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHByaW9yaXR5X3F1ZXVlLmRlZmF1bHRDb21wYXJlKHBlbmRpbmdEZXBlbmRlbmNpZXNbYS5pZF0sIHBlbmRpbmdEZXBlbmRlbmNpZXNbYi5pZF0pOyB9LCBmdW5jdGlvbiAobm9kZSwgbmV3SW5kZXgpIHsgcmV0dXJuIG5vZGVJbmRpY2VzW25vZGUuaWRdID0gbmV3SW5kZXg7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcGVuZGluZ0RlcGVuZGVuY2llc1tub2RlLmlkXSA9IDA7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbm9kZS5pbnB1dHNba2V5XTsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmluZGV4T2YoaW5wdXQubm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2lucHV0Lm5vZGUuaWRdKys7XG4gICAgICAgIH1cbiAgICB9KTsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlUXVldWUuZW5xdWV1ZShub2RlKTsgfSk7XG4gICAgd2hpbGUgKCFub2RlUXVldWUuZW1wdHkoKSkge1xuICAgICAgICBzZXQudW5zaGlmdChub2RlUXVldWUuZGVxdWV1ZSgpKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc2V0WzBdLmlucHV0cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNldFswXS5pbnB1dHNba2V5XTsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmluZGV4T2YoaW5wdXQubm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1tpbnB1dC5ub2RlLmlkXS0tO1xuICAgICAgICAgICAgbm9kZVF1ZXVlLnVwZGF0ZShpbnB1dC5ub2RlLCBub2RlSW5kaWNlc1tpbnB1dC5ub2RlLmlkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuZXhwb3J0cy5nZXRPcmRlcmVkRXZhbHVhdGlvblNldCA9IGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gaXNJbnB1dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhub2RlLmlucHV0cykubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc0lucHV0Tm9kZSA9IGlzSW5wdXROb2RlO1xuZnVuY3Rpb24gc2hvdWxkQmFja1Byb3AodCkge1xuICAgIHJldHVybiAhKHQubm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uc3RhbnROb2RlKTtcbn1cbmV4cG9ydHMuc2hvdWxkQmFja1Byb3AgPSBzaG91bGRCYWNrUHJvcDtcbmZ1bmN0aW9uIGlzUGFzc3Rocm91Z2hOb2RlKG5vZGUsIG1hcCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKG1hcC5nZXQoaW5wdXQsIHRydWUpID09PSBtYXAuZ2V0KG5vZGUub3V0cHV0LCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1Bhc3N0aHJvdWdoTm9kZSA9IGlzUGFzc3Rocm91Z2hOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuL2dyYXBoX3V0aWxcIik7XG52YXIgYWRkXzEgPSByZXF1aXJlKFwiLi9vcHMvYWRkXCIpO1xudmFyIGFyZ21heF8xID0gcmVxdWlyZShcIi4vb3BzL2FyZ21heFwiKTtcbnZhciBhcmdtYXhlcXVhbHNfMSA9IHJlcXVpcmUoXCIuL29wcy9hcmdtYXhlcXVhbHNcIik7XG52YXIgY29uY2F0M2RfMSA9IHJlcXVpcmUoXCIuL29wcy9jb25jYXQzZFwiKTtcbnZhciBjb252b2x1dGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2NvbnZvbHV0aW9uXCIpO1xudmFyIGRpdmlkZV8xID0gcmVxdWlyZShcIi4vb3BzL2RpdmlkZVwiKTtcbnZhciBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXCIpO1xudmFyIGVsZW1lbnRfd2lzZV9jb3N0XzEgPSByZXF1aXJlKFwiLi9vcHMvZWxlbWVudF93aXNlX2Nvc3RcIik7XG52YXIgZXhwXzEgPSByZXF1aXJlKFwiLi9vcHMvZXhwXCIpO1xudmFyIGxpbmVhcl9jb21iaW5hdGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2xpbmVhcl9jb21iaW5hdGlvblwiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuL29wcy9sb2dcIik7XG52YXIgbWF0bXVsXzEgPSByZXF1aXJlKFwiLi9vcHMvbWF0bXVsXCIpO1xudmFyIG1heF9wb29sXzEgPSByZXF1aXJlKFwiLi9vcHMvbWF4X3Bvb2xcIik7XG52YXIgbXVsdGlwbHlfMSA9IHJlcXVpcmUoXCIuL29wcy9tdWx0aXBseVwiKTtcbnZhciByZWR1Y2Vfc3VtXzEgPSByZXF1aXJlKFwiLi9vcHMvcmVkdWNlX3N1bVwiKTtcbnZhciByZXNoYXBlXzEgPSByZXF1aXJlKFwiLi9vcHMvcmVzaGFwZVwiKTtcbnZhciBzb2Z0bWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvc29mdG1heFwiKTtcbnZhciBzdWJ0cmFjdF8xID0gcmVxdWlyZShcIi4vb3BzL3N1YnRyYWN0XCIpO1xuZnVuY3Rpb24gZW1pdEZyb21HcmFwaE5vZGVzKG5vZGVzKSB7XG4gICAgdmFyIG9wcyA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG9wcywgZW1pdE9wRnJvbU5vZGUobm9kZSkpOyB9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuZXhwb3J0cy5lbWl0RnJvbUdyYXBoTm9kZXMgPSBlbWl0RnJvbUdyYXBoTm9kZXM7XG5mdW5jdGlvbiBlbWl0T3BGcm9tTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlJlc2hhcGVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHJlc2hhcGVfMS5SZXNoYXBlKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVzaGFwZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk1hdE11bE5vZGUpIHtcbiAgICAgICAgdmFyIHgxID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXRNdWxOb2RlLlgxXTtcbiAgICAgICAgdmFyIHgyID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXRNdWxOb2RlLlgyXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbWF0bXVsXzEuTWF0TXVsKHgxLCB4Miwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUpIHtcbiAgICAgICAgdmFyIHcgPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLlddO1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuWF07XG4gICAgICAgIHZhciBiID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5CXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgY29udm9sdXRpb25fMS5Db252b2x1dGlvbjJEKHcsIHgsIGIsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5vdXRwdXREZXB0aCwgbm9kZS5zdHJpZGUsIG5vZGUuemVyb1BhZCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NYXhQb29sTm9kZSkge1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF4UG9vbE5vZGUuWF07XG4gICAgICAgIHJldHVybiBbbmV3IG1heF9wb29sXzEuTWF4UG9vbCh4LCBub2RlLm91dHB1dCwgbm9kZS5maWVsZFNpemUsIG5vZGUuc3RyaWRlLCBub2RlLnplcm9QYWQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRXhwTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBleHBfMS5FeHAobm9kZS5pbnB1dHNbZ3JhcGhfMS5FeHBOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Mb2dOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGxvZ18xLkxvZyhub2RlLmlucHV0c1tncmFwaF8xLkxvZ05vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlJlTFVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuUmVMVShub2RlLmlucHV0c1tncmFwaF8xLlJlTFVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5MZWFreVJlTFVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuTGVha3lSZUxVKG5vZGUuaW5wdXRzW2dyYXBoXzEuTGVha3lSZUxVTm9kZS5YXSwgbm9kZS5vdXRwdXQsIG5vZGUuYWxwaGEpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuVGFuSE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5UYW5IKG5vZGUuaW5wdXRzW2dyYXBoXzEuVGFuSE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlNpZ21vaWROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuU2lnbW9pZChub2RlLmlucHV0c1tncmFwaF8xLlNpZ21vaWROb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUpIHtcbiAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5YXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlRBUkdFVF07XG4gICAgICAgIHJldHVybiBbbmV3IHNvZnRtYXhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCh4LCB0YXJnZXQsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlNvZnRtYXhOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHNvZnRtYXhfMS5Tb2Z0bWF4KG5vZGUuaW5wdXRzW2dyYXBoXzEuU29mdG1heE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk1lYW5TcXVhcmVkQ29zdE5vZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlLkxBQkVMXTtcbiAgICAgICAgdmFyIHByZWRpY3Rpb24gPSBub2RlLmlucHV0c1tncmFwaF8xLk1lYW5TcXVhcmVkQ29zdE5vZGUuUFJFRElDVElPTl07XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9jb3N0XzEuTWVhblNxdWFyZWRDb3N0KGxhYmVsLCBwcmVkaWN0aW9uLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGFyZ21heGVxdWFsc18xLkFyZ01heEVxdWFscyhub2RlLmlucHV0c1tncmFwaF8xLkFyZ01heEVxdWFsc05vZGUuWDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkFyZ01heEVxdWFsc05vZGUuWDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5BcmdNYXhOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGFyZ21heF8xLkFyZ01heChub2RlLngsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGxpbmVhcl9jb21iaW5hdGlvbl8xLkxpbmVhckNvbWJpbmF0aW9uKG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQyXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25jYXQzRE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgY29uY2F0M2RfMS5Db25jYXQzRChub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDNETm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0M0ROb2RlLlgyXSwgbm9kZS5heGlzLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TcXVhcmVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuU3F1YXJlKG5vZGUuaW5wdXRzW2dyYXBoXzEuU3F1YXJlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQWRkTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhZGRfMS5BZGQobm9kZS5pbnB1dHNbZ3JhcGhfMS5BZGROb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5BZGROb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU3VidHJhY3ROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHN1YnRyYWN0XzEuU3VidHJhY3Qobm9kZS5pbnB1dHNbZ3JhcGhfMS5TdWJ0cmFjdE5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLlN1YnRyYWN0Tm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk11bHRpcGx5Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBtdWx0aXBseV8xLk11bHRpcGx5KG5vZGUuaW5wdXRzW2dyYXBoXzEuTXVsdGlwbHlOb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5NdWx0aXBseU5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5EaXZpZGVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGRpdmlkZV8xLkRpdmlkZShub2RlLmlucHV0c1tncmFwaF8xLkRpdmlkZU5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkRpdmlkZU5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZWR1Y2VTdW1Ob2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHJlZHVjZV9zdW1fMS5SZWR1Y2VTdW0obm9kZS5pbnB1dHNbZ3JhcGhfMS5SZWR1Y2VTdW1Ob2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiBcIiArIG5vZGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0aW9uX2VtaXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEFkZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGQoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkZC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyUGx1c0FycmF5KHgxLCB4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDIsIHgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguYWRkKHgxLCB4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWRkLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5keVNpemVTY2FsYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHlTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmRpdmlkZShzdW0sIF90aGlzLmR5U2l6ZVNjYWxhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmNsb25lKGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MlRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5keVNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguZGl2aWRlKHN1bSwgX3RoaXMuZHlTaXplU2NhbGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWRkLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5keVNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5keVNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWRkO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5BZGQgPSBBZGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQXJnTWF4ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXgucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGguYXJnTWF4KHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJnTWF4LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJnTWF4IGJhY2twcm9wIHVuaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBBcmdNYXg7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFyZ01heCA9IEFyZ01heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBcmdNYXhFcXVhbHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhFcXVhbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhFcXVhbHMucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXhFcXVhbHMoeDEsIHgyKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFyZ01heEVxdWFscy5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01heEVxdWFscyBiYWNrcHJvcCB1bmltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJnTWF4RXF1YWxzO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5BcmdNYXhFcXVhbHMgPSBBcmdNYXhFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmdtYXhlcXVhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2NvbmNhdF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb25jYXQzRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDNELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNEKHgxVGVuc29yLCB4MlRlbnNvciwgYXhpcywgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDNELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGNvbmNhdFJlc3VsdCA9IG1hdGguY29uY2F0M0QoeDEsIHgyLCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChjb25jYXRSZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXQzRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmNhdDNEIGJhY2twcm9wIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQzRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0M0QgPSBDb25jYXQzRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdDNkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQ29udm9sdXRpb24yRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnZvbHV0aW9uMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udm9sdXRpb24yRCh3VGVuc29yLCB4VGVuc29yLCBiVGVuc29yLCB5VGVuc29yLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud1RlbnNvciA9IHdUZW5zb3I7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy5iVGVuc29yID0gYlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMub3V0cHV0RGVwdGggPSBvdXRwdXREZXB0aDtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBfdGhpcy5hc3NlcnRXZWlnaHRzU2hhcGUod1RlbnNvci5zaGFwZSk7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkICE9IG51bGwgP1xuICAgICAgICAgICAgemVyb1BhZCA6XG4gICAgICAgICAgICBjb252X3V0aWwuY29tcHV0ZURlZmF1bHRQYWQoX3RoaXMueFRlbnNvci5zaGFwZSwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUpO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KF90aGlzLnplcm9QYWQpLCBcIlRoZSB6ZXJvIHBhZGRpbmcgKFwiICsgX3RoaXMuemVyb1BhZCArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICAgICAgXCJzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB3ZWlnaHRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLndUZW5zb3IpO1xuICAgICAgICB2YXIgYmlhc2VzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmJUZW5zb3IpO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGguY29udjJkKHgsIHdlaWdodHMsIGJpYXNlcywgX3RoaXMuc3RyaWRlLCBfdGhpcy56ZXJvUGFkKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnZvbHV0aW9uMkQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcik7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBtYXRoLmNvbnYyZEJhY2tQcm9wKHgsIGR5LCB3ZWlnaHRzLCBfdGhpcy5zdHJpZGUsIF90aGlzLnplcm9QYWQpLCBkdyA9IF9hLmR3LCBkYiA9IF9hLmRiLCBkeCA9IF9hLmR4O1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLndUZW5zb3IsIGR3KTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5iVGVuc29yLCBkYik7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgZHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnZvbHV0aW9uMkQucHJvdG90eXBlLmFzc2VydFdlaWdodHNTaGFwZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQod2VpZ2h0c1NoYXBlWzBdID09PSB0aGlzLmZpZWxkU2l6ZSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzFdID09PSB0aGlzLmZpZWxkU2l6ZSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzJdID09PSB0aGlzLnhUZW5zb3Iuc2hhcGVbMl0gJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVszXSA9PT0gdGhpcy5vdXRwdXREZXB0aCwgXCJ3ZWlnaHRzIG11c3QgYmUgb2Ygc2hhcGUgW1wiICsgdGhpcy5maWVsZFNpemUgKyBcIixcIiArIHRoaXMuZmllbGRTaXplICsgXCIsXCIgK1xuICAgICAgICAgICAgKHRoaXMueFRlbnNvci5zaGFwZVsyXSArIFwiLFwiICsgdGhpcy5vdXRwdXREZXB0aCArIFwiXSBidXQgdGhleSBhcmUgb2ZcIikgK1xuICAgICAgICAgICAgKFwic2hhcGUgW1wiICsgd2VpZ2h0c1NoYXBlICsgXCJdXCIpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb252b2x1dGlvbjJEO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Db252b2x1dGlvbjJEID0gQ29udm9sdXRpb24yRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZvbHV0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRGl2aWRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGl2aWRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpdmlkZSh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGl2aWRlLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJEaXZpZGVkQnlBcnJheSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguYXJyYXlEaXZpZGVkQnlTY2FsYXIodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguZGl2aWRlKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGl2aWRlLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgeDFJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSk7XG4gICAgICAgIHZhciB4MklzU2NhbGFyID0gdXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gbWF0aC5kaXZpZGUoZHksIHgyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnN1bShkaXYpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDJJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguYXJyYXlEaXZpZGVkQnlTY2FsYXIoZHksIHgyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZGl2aWRlKGR5LCB4MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciB4MlNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCB4Mik7XG4gICAgICAgICAgICAgICAgdmFyIHgxT3ZlclgyU3F1YXJlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoeDJJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4MUlzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLmRpdmlkZSh4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGR4MiA9IG1hdGgubmVnKHgxT3ZlclgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgdmFyIGR5VGltZXNEZXJpdmF0aXZlID0gbWF0aC5lbGVtZW50V2lzZU11bChkeSwgZHgyKTtcbiAgICAgICAgICAgICAgICBpZiAoeDJJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc3VtKGR5VGltZXNEZXJpdmF0aXZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIGR5VGltZXNEZXJpdmF0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERpdmlkZTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRGl2aWRlID0gRGl2aWRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGl2aWRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2FjdGl2YXRpb25fZnVuY3Rpb25zXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFbGVtZW50V2lzZUFjdGl2YXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50V2lzZUFjdGl2YXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFdpc2VBY3RpdmF0aW9uKHhUZW5zb3IsIHlUZW5zb3IsIGZ1bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKF90aGlzLmZ1bmMub3V0cHV0KG1hdGgsIHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudFdpc2VBY3RpdmF0aW9uLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgeSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5ZHggPSBfdGhpcy5mdW5jLmRlcihtYXRoLCB4LCB5KTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCBkeWR4KSk7XG4gICAgICAgICAgICBkeWR4LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVuYy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFdpc2VBY3RpdmF0aW9uO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FbGVtZW50V2lzZUFjdGl2YXRpb24gPSBFbGVtZW50V2lzZUFjdGl2YXRpb247XG52YXIgUmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlTFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVMVSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5SZUxVRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVMVTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlJlTFUgPSBSZUxVO1xudmFyIExlYWt5UmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFreVJlTFUoeFRlbnNvciwgeVRlbnNvciwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLkxlYWt5UmVsdUZ1bmMoYWxwaGEpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGVha3lSZUxVO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuTGVha3lSZUxVID0gTGVha3lSZUxVO1xudmFyIFRhbkggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYW5ILCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhbkgoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuVGFuSEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhbkg7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5UYW5IID0gVGFuSDtcbnZhciBTaWdtb2lkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbW9pZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWdtb2lkKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlNpZ21vaWRGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWdtb2lkO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU2lnbW9pZCA9IFNpZ21vaWQ7XG52YXIgU3F1YXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3F1YXJlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNxdWFyZSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5TcXVhcmVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTcXVhcmU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TcXVhcmUgPSBTcXVhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X3dpc2VfYWN0aXZhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvc3RfZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb3N0X2Z1bmN0aW9uc1wiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEVsZW1lbnRXaXNlQ29zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRXaXNlQ29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50V2lzZUNvc3QoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yLCBmdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgX3RoaXMub25lT3Zlck5TY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxIC8gdXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFdpc2VDb3N0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRXaXNlQ29zdCA9IF90aGlzLmZ1bmMuY29zdChtYXRoLCB4MSwgeDIpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGVsZW1lbnRXaXNlQ29zdCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KF90aGlzLm9uZU92ZXJOU2NhbGFyLCBzdW0pO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgX3RoaXMuZnVuYy5kZXIobWF0aCwgeDEsIHgyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgyLCB4MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVPdmVyTlNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFdpc2VDb3N0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FbGVtZW50V2lzZUNvc3QgPSBFbGVtZW50V2lzZUNvc3Q7XG52YXIgTWVhblNxdWFyZWRDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhblNxdWFyZWRDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYW5TcXVhcmVkQ29zdCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgbmV3IGNvc3RfZnVuY3Rpb25zXzEuU3F1YXJlQ29zdEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lYW5TcXVhcmVkQ29zdDtcbn0oRWxlbWVudFdpc2VDb3N0KSk7XG5leHBvcnRzLk1lYW5TcXVhcmVkQ29zdCA9IE1lYW5TcXVhcmVkQ29zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfd2lzZV9jb3N0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFeHAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5leHAoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFeHAucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHkgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnhUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeSwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FeHAgPSBFeHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIExpbmVhckNvbWJpbmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZWFyQ29tYmluYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29tYmluYXRpb24oeDFUZW5zb3IsIHgyVGVuc29yLCBjMVRlbnNvciwgYzJUZW5zb3IsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5jMVRlbnNvciA9IGMxVGVuc29yO1xuICAgICAgICBfdGhpcy5jMlRlbnNvciA9IGMyVGVuc29yO1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGluZWFyQ29tYmluYXRpb24ucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgYzEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzFUZW5zb3IpLmFzU2NhbGFyKCk7XG4gICAgICAgIHZhciBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcikuYXNTY2FsYXIoKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAobWF0aC5zY2FsZWRBcnJheUFkZChjMSwgeDEsIGMyLCB4MikpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW5lYXJDb21iaW5hdGlvbi5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgYzEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzFUZW5zb3IpO1xuICAgICAgICB2YXIgYzIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KGMxLCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzIsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy5jMVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZHVjdDEgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmMxVGVuc29yLCBtYXRoLnN1bShkb3RQcm9kdWN0MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMuYzJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvdFByb2R1Y3QyID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5jMlRlbnNvciwgbWF0aC5zdW0oZG90UHJvZHVjdDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFyQ29tYmluYXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkxpbmVhckNvbWJpbmF0aW9uID0gTGluZWFyQ29tYmluYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lYXJfY29tYmluYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2coeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9nLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmxvZyh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueFRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5kaXZpZGUoZHksIHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Mb2cgPSBMb2c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9tYXRoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTWF0TXVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0TXVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdE11bCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF0TXVsLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5tYXRNdWwoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLm1hdHJpeFRpbWVzVmVjdG9yKHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC52ZWN0b3JUaW1lc01hdHJpeCh4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0TXVsLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB4MSA9IHgxLnJlc2hhcGUoWzEsIHgxLnNpemVdKTtcbiAgICAgICAgICAgIGR5ID0gZHkucmVzaGFwZShbMSwgZHkuc2l6ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHgyID0geDIucmVzaGFwZShbeDIuc2l6ZSwgMV0pO1xuICAgICAgICAgICAgZHkgPSBkeS5yZXNoYXBlKFtkeS5zaXplLCAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHgxID0gbWF0aC5tYXRNdWwoZHksIHgyLCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUiwgbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgX3RoaXMueDFUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAxID8gZHgxLmFzMUQoKSA6IGR4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHgyID0gbWF0aC5tYXRNdWwoeDEsIGR5LCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCwgbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgX3RoaXMueDJUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAxID8gZHgyLmFzMUQoKSA6IGR4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdE11bDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTWF0TXVsID0gTWF0TXVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0bXVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTWF4UG9vbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heFBvb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4UG9vbCh4VGVuc29yLCB5VGVuc29yLCBmaWVsZFNpemUsIHN0cmlkZSwgcGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIGlmIChwYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMucGFkID0gcGFkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMucGFkID0gY29udl91dGlsLmNvbXB1dGVEZWZhdWx0UGFkKHhUZW5zb3Iuc2hhcGUsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KF90aGlzLnBhZCksIFwiVGhlIHplcm8gcGFkZGluZyAoXCIgKyBfdGhpcy5wYWQgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1heFBvb2wucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF4UG9vbCh4LCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSwgX3RoaXMucGFkKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1heFBvb2wucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLm1heFBvb2xCYWNrcHJvcChkeSwgeCwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUsIF90aGlzLnBhZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXhQb29sO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NYXhQb29sID0gTWF4UG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heF9wb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTXVsdGlwbHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseSh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDIsIHQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguZWxlbWVudFdpc2VNdWwodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNdWx0aXBseS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngxVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gbWF0aC5lbGVtZW50V2lzZU11bChkeSwgeDIpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguc3VtKG11bCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KHgyLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4MSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5zdW0obXVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDEsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeDEsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aXBseTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTXVsdGlwbHkgPSBNdWx0aXBseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGx5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9wZXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uKCkge1xuICAgIH1cbiAgICBPcGVyYXRpb24ucHJvdG90eXBlLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMgPSBmdW5jdGlvbiAoaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykgeyB9O1xuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gT3BlcmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gT3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFJlZHVjZVN1bSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VTdW0oeCwgb3V0VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gob3V0VGVuc29yLnNoYXBlLCBbXSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVkdWNlU3VtLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueCk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBrZWVwKG1hdGguc3VtKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVkdWNlU3VtLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQoX3RoaXMub3V0VGVuc29yKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vbmVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgeEFycmF5ID0gaW5mZXJlbmNlQXJyYXlzLmdldChfdGhpcy54KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmVzID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3NMaWtlKHhBcnJheSk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25lcy5maWxsKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngsIG1hdGguc2NhbGFyVGltZXNBcnJheShkeSwgX3RoaXMub25lcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWR1Y2VTdW07XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlJlZHVjZVN1bSA9IFJlZHVjZVN1bTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV9zdW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFJlc2hhcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNoYXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2hhcGUoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHZhciB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh4VGVuc29yLnNoYXBlKTtcbiAgICAgICAgdmFyIHlTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHlUZW5zb3Iuc2hhcGUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2l6ZSA9PT0geVNpemUsIFwiVGhlIGlucHV0IHNpemUgKFwiICsgeFNpemUgKyBcIikgYW5kIG91dHB1dCBzaXplIChcIiArIHlTaXplICsgXCIpIG11c3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzaGFwZS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgY2xvbmUgPSBtYXRoLmNsb25lKHgpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY2xvbmUucmVzaGFwZShfdGhpcy55VGVuc29yLnNoYXBlKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBjbG9uZSA9IG1hdGguY2xvbmUoZHkpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBjbG9uZS5yZXNoYXBlKF90aGlzLnhUZW5zb3Iuc2hhcGUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzaGFwZTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuUmVzaGFwZSA9IFJlc2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNoYXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU29mdG1heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heChsb2dpdHNUZW5zb3IsIG91dHB1dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dpdHNUZW5zb3IgPSBsb2dpdHNUZW5zb3I7XG4gICAgICAgIF90aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpO1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRwdXQsIGtlZXAobWF0aC5zb2Z0bWF4KGxvZ2l0cykpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1NvZnRtYXggYmFja3Byb3AgaXMgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFNvZnRtYXg7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXggPSBTb2Z0bWF4O1xudmFyIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdG1heENyb3NzRW50cm9weUNvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heENyb3NzRW50cm9weUNvc3QobG9naXRzVGVuc29yLCBsYWJlbFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dpdHNUZW5zb3IgPSBsb2dpdHNUZW5zb3I7XG4gICAgICAgIF90aGlzLmxhYmVsVGVuc29yID0gbGFiZWxUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNSk7XG4gICAgICAgIF90aGlzLnNvZnRtYXhUZW5zb3IgPSBuZXcgZ3JhcGhfMS5UZW5zb3IobG9naXRzVGVuc29yLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKTtcbiAgICAgICAgdmFyIGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHNvZnRtYXhSZXN1bHQgPSBtYXRoLnNvZnRtYXgobG9naXRzKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMuc29mdG1heFRlbnNvciwga2VlcChzb2Z0bWF4UmVzdWx0KSk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY3Jvc3NFbnRyb3B5Q29zdChtYXRoLCBzb2Z0bWF4UmVzdWx0LCBsYWJlbCwgX3RoaXMuZXBzaWxvbikpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc29mdG1heCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5zb2Z0bWF4VGVuc29yKTtcbiAgICAgICAgdmFyIGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMubG9naXRzVGVuc29yLCBtYXRoLnN1YnRyYWN0KHNvZnRtYXgsIGxhYmVsKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMgPSBmdW5jdGlvbiAoaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICBpbmZlcmVuY2VBcnJheXMuZGlzcG9zZUFycmF5KHRoaXMuc29mdG1heFRlbnNvcik7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lcHNpbG9uLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU29mdG1heENyb3NzRW50cm9weUNvc3QgPSBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdDtcbmZ1bmN0aW9uIGNyb3NzRW50cm9weUNvc3QobWF0aCwgeSwgdGFyZ2V0LCBlcHNpbG9uKSB7XG4gICAgdXRpbC5hc3NlcnQoeS5zaXplID09PSB0YXJnZXQuc2l6ZSwgJ1RoZSBvdXRwdXQgYW5kIHRhcmdldCBtdXN0IGJlIHRoZSBzYW1lIHNpemUnKTtcbiAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5UGx1c0VwcyA9IG1hdGguc2NhbGFyUGx1c0FycmF5KGVwc2lsb24sIHkpO1xuICAgICAgICB2YXIgbG9nT3V0cHV0ID0gbWF0aC5sb2coeVBsdXNFcHMpO1xuICAgICAgICB2YXIgdGFyTG9nT3V0cHV0ID0gbWF0aC5lbGVtZW50V2lzZU11bCh0YXJnZXQsIGxvZ091dHB1dCk7XG4gICAgICAgIHZhciBjb3N0VmVjdG9yID0gbWF0aC5uZWcodGFyTG9nT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG1hdGguc3VtKGNvc3RWZWN0b3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcm9zc0VudHJvcHlDb3N0ID0gY3Jvc3NFbnRyb3B5Q29zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvZnRtYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFN1YnRyYWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidHJhY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VidHJhY3QodDEsIHQyLCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHQxLnNoYXBlLCB0Mi5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnRyYWN0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQxKTtcbiAgICAgICAgdmFyIHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQyKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJNaW51c0FycmF5KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hcnJheU1pbnVzU2NhbGFyKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnN1YnRyYWN0KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJ0cmFjdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnQxKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMudDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5keVNpemVTY2FsYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHlTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQxLCBtYXRoLmRpdmlkZShzdW0sIF90aGlzLmR5U2l6ZVNjYWxhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQxLCBtYXRoLmNsb25lKGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMudDIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy50Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ1N1bSA9IG1hdGgubmVnKHN1bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5keVNpemVTY2FsYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHlTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQyLCBtYXRoLmRpdmlkZShuZWdTdW0sIF90aGlzLmR5U2l6ZVNjYWxhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQyLCBtYXRoLm5lZyhkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJ0cmFjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnRyYWN0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5TdWJ0cmFjdCA9IFN1YnRyYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VidHJhY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYWRlbHRhT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZGVsdGFPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhZGVsdGFPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBnYW1tYSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmdhbW1hID0gZ2FtbWE7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS02KTtcbiAgICAgICAgX3RoaXMuZyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmdhbW1hKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVXBkYXRlcyA9IF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmcsIG9sZENhY2hlLCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuZyksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcyA9IG1hdGgubXVsdGlwbHkobWF0aC5kaXZpZGUobWF0aC5zcXJ0KG1hdGguYWRkKG9sZFVwZGF0ZXMsIF90aGlzLmVwcykpLCBtYXRoLnNxcnQobWF0aC5hZGQob2xkQ2FjaGUsIF90aGlzLmVwcykpKSwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgdXBkYXRlcywgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVNxdWFyZSA9IG1hdGgubXVsdGlwbHkodXBkYXRlcywgdXBkYXRlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VwZGF0ZXMgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmcsIG9sZFVwZGF0ZXMsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5nKSwgdXBkYXRlU3F1YXJlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLnNldChub2RlLm91dHB1dCwga2VlcChuZXdVcGRhdGVzKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVXBkYXRlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYWRlbHRhT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBBZGFkZWx0YU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWRlbHRhX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhZ3JhZE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWdyYWRPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhZ3JhZE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTYpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IG1hdGguYWRkKG9sZENhY2hlLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhZ3JhZE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBBZGFncmFkT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhZ3JhZF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYW1PcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFtT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5iZXRhMSA9IGJldGExO1xuICAgICAgICBfdGhpcy5iZXRhMiA9IGJldGEyO1xuICAgICAgICBfdGhpcy5maXJzdE1vbWVudCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS04KTtcbiAgICAgICAgX3RoaXMuYjEgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMSk7XG4gICAgICAgIF90aGlzLmIyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTIpO1xuICAgICAgICBfdGhpcy5hY2NCMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYWNjQjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RNb21lbnQuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlY29uZE1vbWVudC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50LnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEZpcnN0TW9tZW50ID0gX3RoaXMuZmlyc3RNb21lbnQuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2Vjb25kTW9tZW50ID0gX3RoaXMuc2Vjb25kTW9tZW50LmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iMSwgb2xkRmlyc3RNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5iMSksIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlY29uZE1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYjIsIG9sZFNlY29uZE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmIyKSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkRmlyc3RNb21lbnQgPSBtYXRoLmRpdmlkZShuZXdGaXJzdE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmFjY0IxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpYXNDb3JyZWN0ZWRTZWNvbmRNb21lbnQgPSBtYXRoLmRpdmlkZShuZXdTZWNvbmRNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5hY2NCMikpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgbWF0aC5kaXZpZGUoYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCksIF90aGlzLmVwcykpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld0ZpcnN0TW9tZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdTZWNvbmRNb21lbnQpKTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZEZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRTZWNvbmRNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb2xkQWNjQjEgPSBfdGhpcy5hY2NCMTtcbiAgICAgICAgICAgIHZhciBvbGRBY2NCMiA9IF90aGlzLmFjY0IyO1xuICAgICAgICAgICAgX3RoaXMuYWNjQjEgPSBrZWVwKG1hdGgubXVsdGlwbHkoX3RoaXMuYWNjQjEsIF90aGlzLmIxKSk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMiA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMiwgX3RoaXMuYjIpKTtcbiAgICAgICAgICAgIG9sZEFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIG9sZEFjY0IyLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZmlyc3RNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnNlY29uZE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCMi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhbU9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1PcHRpbWl6ZXIgPSBBZGFtT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhbV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYW1heE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1heE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFtYXhPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5iZXRhMSA9IGJldGExO1xuICAgICAgICBfdGhpcy5iZXRhMiA9IGJldGEyO1xuICAgICAgICBfdGhpcy5maXJzdE1vbWVudCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMud2VpZ2h0ZWRJbmZOb3JtID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS04KTtcbiAgICAgICAgX3RoaXMuYjEgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMSk7XG4gICAgICAgIF90aGlzLmIyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTIpO1xuICAgICAgICBfdGhpcy5hY2NCMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0TW9tZW50LnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53ZWlnaHRlZEluZk5vcm0uc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybS5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEZpcnN0TW9tZW50ID0gX3RoaXMuZmlyc3RNb21lbnQuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkV2VpZ2h0ZWRJbmZOb3JtID0gX3RoaXMud2VpZ2h0ZWRJbmZOb3JtLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iMSwgb2xkRmlyc3RNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5iMSksIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdXQwID0gbWF0aC5tdWx0aXBseShfdGhpcy5iMiwgb2xkV2VpZ2h0ZWRJbmZOb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgdXQxID0gbWF0aC5hYnMoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdXZWlnaHRlZEluZk5vcm0gPSBtYXRoLmFkZChtYXRoLnJlbHUobWF0aC5zdWJ0cmFjdCh1dDAsIHV0MSkpLCB1dDEpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMub25lLCBvbGRWYXJpYWJsZSwgbWF0aC5kaXZpZGUoX3RoaXMuYywgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmFjY0IxKSksIG1hdGguZGl2aWRlKG5ld0ZpcnN0TW9tZW50LCBtYXRoLmFkZChfdGhpcy5lcHMsIG5ld1dlaWdodGVkSW5mTm9ybSkpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld0ZpcnN0TW9tZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMud2VpZ2h0ZWRJbmZOb3JtLnNldChub2RlLm91dHB1dCwga2VlcChuZXdXZWlnaHRlZEluZk5vcm0pKTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZEZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRXZWlnaHRlZEluZk5vcm0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb2xkQWNjQjEgPSBfdGhpcy5hY2NCMTtcbiAgICAgICAgICAgIF90aGlzLmFjY0IxID0ga2VlcChtYXRoLm11bHRpcGx5KF90aGlzLmFjY0IxLCBfdGhpcy5iMSkpO1xuICAgICAgICAgICAgb2xkQWNjQjEuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy53ZWlnaHRlZEluZk5vcm0uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQjEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmIxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhbWF4T3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhbWF4T3B0aW1pemVyID0gQWRhbWF4T3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhbWF4X29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vc2dkX29wdGltaXplclwiKTtcbnZhciBNb21lbnR1bU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbWVudHVtT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbWVudHVtT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgbW9tZW50dW0sIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgICAgICBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLm0gPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5tb21lbnR1bSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRWZWxvY2l0eSA9IF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMubSwgb2xkVmVsb2NpdHksIF90aGlzLm9uZSwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgdmVsb2NpdHksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmVsb2NpdHkpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFZlbG9jaXR5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVWZWxvY2l0aWVzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5zZXRNb21lbnR1bSA9IGZ1bmN0aW9uIChtb21lbnR1bSkge1xuICAgICAgICB0aGlzLm1vbWVudHVtID0gbW9tZW50dW07XG4gICAgfTtcbiAgICByZXR1cm4gTW9tZW50dW1PcHRpbWl6ZXI7XG59KHNnZF9vcHRpbWl6ZXJfMS5TR0RPcHRpbWl6ZXIpKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBNb21lbnR1bU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbWVudHVtX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuLi9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgT3B0aW1pemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIHRoaXMub25lID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSk7XG4gICAgICAgIGlmIChzcGVjaWZpZWRWYXJpYWJsZUxpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzID0gc3BlY2lmaWVkVmFyaWFibGVMaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzID0gdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzID09IG51bGwgP1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChydW50aW1lLm5vZGVzKSA6XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXM7XG4gICAgICAgIGlmIChiYXRjaFNpemUgIT09IHRoaXMucHJldkJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldkJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KC10aGlzLmxlYXJuaW5nUmF0ZSAvIGJhdGNoU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTsgfSk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyRXhhbXBsZSA9IGZ1bmN0aW9uIChtYXRoLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gZ3JhZGllbnRBcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAobWF0aC5hZGQoZ3JhZGllbnQsIGFjY3VtdWxhdGVkR3JhZGllbnQpKSk7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRHcmFkaWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gT3B0aW1pemVyO1xufSgpKTtcbmV4cG9ydHMuT3B0aW1pemVyID0gT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBSTVNQcm9wT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUk1TUHJvcE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSTVNQcm9wT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgZ2FtbWEsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5nYW1tYSA9IGdhbW1hO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTYpO1xuICAgICAgICBfdGhpcy5nID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuZ2FtbWEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuZywgb2xkQ2FjaGUsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5nKSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgbWF0aC5kaXZpZGUoZ3JhZGllbnQsIG1hdGguYWRkKG1hdGguc3FydChjYWNoZSksIF90aGlzLmVwcykpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5nLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJNU1Byb3BPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5STVNQcm9wT3B0aW1pemVyID0gUk1TUHJvcE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJtc3Byb3Bfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgU0dET3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU0dET3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNHRE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgZ3JhZGllbnQsIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuc2V0TGVhcm5pbmdSYXRlID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBTR0RPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBTR0RPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZ2Rfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRDb21wYXJlID0gZGVmYXVsdENvbXBhcmU7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZShjb21wYXJhdG9yLCBpbmRleE9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuaW5kZXhPYnNlcnZlciA9IGluZGV4T2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgIH1cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5oZWFwLnB1c2godCk7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLnNpZnRVcCh0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcXVldWUgY2FsbGVkIG9uIGVtcHR5IHByaW9yaXR5IHF1ZXVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICB0aGlzLnN3YXAoMCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIHRoaXMuc2lmdERvd24oMCk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5ld1QsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYXN0ID0gKGluZGV4ID09PSB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFwLnBvcCgpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZnRVcEluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZnRVcChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lmdERvd24oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5xdWV1ZShuZXdUKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLm9uSW5kZXhDaGFuZ2VkID0gZnVuY3Rpb24gKHQsIG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhPYnNlcnZlcih0LCBuZXdJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFBhcmVudEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMik7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRMZWZ0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gaW5kZXggKiAyICsgMTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFJpZ2h0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gaW5kZXggKiAyICsgMjtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShwYXJlbnRJbmRleCwgaW5kZXgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgICAgIHdoaWxlIChzaWZ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHNpZnRJbmRleCk7XG4gICAgICAgICAgICBpbmRleCA9IHNpZnRJbmRleDtcbiAgICAgICAgICAgIHNpZnRJbmRleCA9IHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0RG93bkluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhcmdlc3RDaGlsZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHZhciBsZWZ0Q2hpbGRJbmRleCA9IHRoaXMuZ2V0TGVmdENoaWxkSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoKGxlZnRDaGlsZEluZGV4ICE9PSAtMSkgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBhcmUobGVmdENoaWxkSW5kZXgsIGxhcmdlc3RDaGlsZEluZGV4KSA8IDApKSB7XG4gICAgICAgICAgICBsYXJnZXN0Q2hpbGRJbmRleCA9IGxlZnRDaGlsZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodENoaWxkSW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgICAgIGlmICgocmlnaHRDaGlsZEluZGV4ICE9PSAtMSkgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBhcmUocmlnaHRDaGlsZEluZGV4LCBsYXJnZXN0Q2hpbGRJbmRleCkgPCAwKSkge1xuICAgICAgICAgICAgbGFyZ2VzdENoaWxkSW5kZXggPSByaWdodENoaWxkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChsYXJnZXN0Q2hpbGRJbmRleCA9PT0gaW5kZXgpID8gLTEgOiBsYXJnZXN0Q2hpbGRJbmRleDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnREb3duID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzaWZ0SW5kZXggPSB0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpO1xuICAgICAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICAgICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGFJbmRleCwgYkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IodGhpcy5oZWFwW2FJbmRleF0sIHRoaXMuaGVhcFtiSW5kZXhdKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuaGVhcFthXTtcbiAgICAgICAgdGhpcy5oZWFwW2FdID0gdGhpcy5oZWFwW2JdO1xuICAgICAgICB0aGlzLmhlYXBbYl0gPSB0ZW1wO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHRoaXMuaGVhcFthXSwgYSk7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2JdLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xufSgpKTtcbmV4cG9ydHMuUHJpb3JpdHlRdWV1ZSA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmlvcml0eV9xdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fZW1pdHRlciA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbl9lbWl0dGVyXCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuL3Nlc3Npb25fdXRpbFwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIEZlZWREaWN0aW9uYXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICAgICAgaWYgKGZlZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICBmZWVkRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gX3RoaXMuZGljdFtlbnRyeS50ZW5zb3IuaWRdID0gZW50cnk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGZWVkRGljdGlvbmFyeTtcbn0oKSk7XG5leHBvcnRzLkZlZWREaWN0aW9uYXJ5ID0gRmVlZERpY3Rpb25hcnk7XG52YXIgQ29zdFJlZHVjdGlvbjtcbihmdW5jdGlvbiAoQ29zdFJlZHVjdGlvbikge1xuICAgIENvc3RSZWR1Y3Rpb25bQ29zdFJlZHVjdGlvbltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIENvc3RSZWR1Y3Rpb25bQ29zdFJlZHVjdGlvbltcIlNVTVwiXSA9IDFdID0gXCJTVU1cIjtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJNRUFOXCJdID0gMl0gPSBcIk1FQU5cIjtcbn0pKENvc3RSZWR1Y3Rpb24gPSBleHBvcnRzLkNvc3RSZWR1Y3Rpb24gfHwgKGV4cG9ydHMuQ29zdFJlZHVjdGlvbiA9IHt9KSk7XG52YXIgU2Vzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbihncmFwaCwgbWF0aCkge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25BcnJheU1hcCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEFycmF5TWFwID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5TdW1tZWRUZW5zb3JBcnJheU1hcCh0aGlzLm1hdGgpO1xuICAgIH1cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25BcnJheU1hcC5kaXNwb3NlKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucnVudGltZUNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gX3RoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAocnVudGltZS5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ldmFsQWxsID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZlZWQgPSBuZXcgRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpO1xuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSBfdGhpcy5nZXRPckNyZWF0ZVJ1bnRpbWUodGVuc29ycywgZmVlZCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZhdGlvbnMgPSBfdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXA7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKHJ1bnRpbWUub3BlcmF0aW9ucywgX3RoaXMuYWN0aXZhdGlvbkFycmF5TWFwLCBfdGhpcy5ncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5mZWVkRm9yd2FyZChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucyk7IH0pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWN0aXZhdGlvbnMuZ2V0KHgpOyB9KTtcbiAgICAgICAgICAgIHRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWN0aXZhdGlvbnMuZGVsZXRlKHgpOyB9KTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWxBbGwoW3RlbnNvcl0sIGZlZWRFbnRyaWVzKVswXTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gKGNvc3RUZW5zb3IsIGZlZWRFbnRyaWVzLCBiYXRjaFNpemUsIG9wdGltaXplciwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IGNvc3RSZWR1Y3Rpb24gPSBDb3N0UmVkdWN0aW9uLk5PTkU7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc1NjYWxhclNoYXBlKGNvc3RUZW5zb3Iuc2hhcGUpLCAnQ29zdCB0ZW5zb3IgZm9yIHRyYWluaW5nIG11c3QgYmUgYSBzY2FsYXIgdmFsdWUuJyk7XG4gICAgICAgIGlmICh0aGlzLnByZXZCYXRjaFNpemUgIT09IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhiYXRjaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZWVkID0gbmV3IEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKTtcbiAgICAgICAgc2Vzc2lvbl91dGlsLnRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoZmVlZCk7XG4gICAgICAgIHZhciBydW50aW1lID0gdGhpcy5nZXRPckNyZWF0ZVJ1bnRpbWUoW2Nvc3RUZW5zb3JdLCBmZWVkKTtcbiAgICAgICAgdmFyIGluZmVyZW5jZU9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnM7XG4gICAgICAgIHZhciBiYWNrUHJvcE9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBhY3RpdmF0aW9ucyA9IHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwO1xuICAgICAgICB2YXIgZ3JhZGllbnRzID0gdGhpcy5ncmFkaWVudEFycmF5TWFwO1xuICAgICAgICBncmFkaWVudHMubnVsbGlmeShjb3N0VGVuc29yKTtcbiAgICAgICAgZ3JhZGllbnRzLmFkZChjb3N0VGVuc29yLCB0aGlzLm9uZVNjYWxhcik7XG4gICAgICAgIHNlc3Npb25fdXRpbC5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgIG9wdGltaXplci5iZWZvcmVCYXRjaCh0aGlzLm1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXAsIHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgY29zdCA9IHRyYWNrKG5kYXJyYXlfMS5TY2FsYXIubmV3KDApKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hTaXplOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhydW50aW1lLm5vZGVzLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKHJ1bnRpbWUub3BlcmF0aW9ucywgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VPcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5mZWVkRm9yd2FyZChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucyk7IH0pO1xuICAgICAgICAgICAgICAgIGJhY2tQcm9wT3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuYmFja1Byb3AoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7IH0pO1xuICAgICAgICAgICAgICAgIG9wdGltaXplci5hZnRlckV4YW1wbGUoX3RoaXMubWF0aCwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICAgICAgY29zdCA9IF90aGlzLnVwZGF0ZUNvc3RGb3JFeGFtcGxlKGNvc3QsIGFjdGl2YXRpb25zLmdldChjb3N0VGVuc29yKSwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpbWl6ZXIuYWZ0ZXJCYXRjaChfdGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUNvc3RGb3JCYXRjaChjb3N0LCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS51cGRhdGVDb3N0Rm9yRXhhbXBsZSA9IGZ1bmN0aW9uICh0b3RhbENvc3QsIGN1cnJDb3N0LCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLk1FQU4gfHxcbiAgICAgICAgICAgIGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uU1VNKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRoLmFkZCh0b3RhbENvc3QsIGN1cnJDb3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxDb3N0O1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlQ29zdEZvckJhdGNoID0gZnVuY3Rpb24gKHRvdGFsQ29zdCwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRoLmRpdmlkZSh0b3RhbENvc3QsIHRoaXMuYmF0Y2hTaXplU2NhbGFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxDb3N0O1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZ2V0T3JDcmVhdGVSdW50aW1lID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMubWFrZVJ1bnRpbWVDYWNoZUtleSh0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aGlzLnJ1bnRpbWVDYWNoZVtrZXldO1xuICAgICAgICBpZiAocnVudGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBzZXNzaW9uX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcih0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZmVlZCwgbm9kZXMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBvcGVyYXRpb25fZW1pdHRlci5lbWl0RnJvbUdyYXBoTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgcnVudGltZSA9IHsgbm9kZXM6IG5vZGVzLCBvcGVyYXRpb25zOiBvcGVyYXRpb25zIH07XG4gICAgICAgICAgICB0aGlzLnJ1bnRpbWVDYWNoZVtrZXldID0gcnVudGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm1ha2VSdW50aW1lQ2FjaGVLZXkgPSBmdW5jdGlvbiAodGVuc29ycywgZmVlZCkge1xuICAgICAgICByZXR1cm4gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLnNvcnQoKS5qb2luKCdfJykgKyAnX18nICtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZlZWQuZGljdCkuc29ydCgpLmpvaW4oJ18nKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4vZ3JhcGhfdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnkoZmVlZERpY3Rpb25hcnkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmVlZERpY3Rpb25hcnkuZGljdClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodGVuc29ySUQpIHsgcmV0dXJuIGZlZWREaWN0aW9uYXJ5LmRpY3RbK3RlbnNvcklEXS50ZW5zb3Iubm9kZTsgfSk7XG59XG5leHBvcnRzLmdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnkgPSBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5O1xuZnVuY3Rpb24gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcihldmFsVGVuc29ycywgZmVlZERpY3Rpb25hcnkpIHtcbiAgICB2YXIgdGVybWluYXRpbmdOb2RlcyA9IGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnkoZmVlZERpY3Rpb25hcnkpO1xuICAgIHZhciBldmFsTm9kZXMgPSBldmFsVGVuc29ycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubm9kZTsgfSk7XG4gICAgdmFyIHVub3JkZXJlZEV2YWx1YXRpb25TZXQgPSBncmFwaF91dGlsLmdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQoZXZhbE5vZGVzLCB0ZXJtaW5hdGluZ05vZGVzKTtcbiAgICB2YXIgb3JkZXJlZEV2YWx1YXRpb25TZXQgPSBncmFwaF91dGlsLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0KHVub3JkZXJlZEV2YWx1YXRpb25TZXQpO1xuICAgIHJldHVybiBvcmRlcmVkRXZhbHVhdGlvblNldDtcbn1cbmV4cG9ydHMuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvciA9IGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3I7XG5mdW5jdGlvbiBhZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChldmFsdWF0aW9uU2V0LCB0ZW5zb3JBcnJheU1hcCkge1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuVmFyaWFibGVOb2RlIHx8IG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbnN0YW50Tm9kZSkge1xuICAgICAgICAgICAgdGVuc29yQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBub2RlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwID0gYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXA7XG5mdW5jdGlvbiBnZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZXZhbHVhdGlvblNldCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZXhwb3J0cy5nZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQgPSBnZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiB0aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzKGZlZWREaWN0aW9uYXJ5KSB7XG4gICAgT2JqZWN0LmtleXMoZmVlZERpY3Rpb25hcnkuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3RbK3RlbnNvcklEXS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhaW5pbmcgcmVxdWlyZXMgRmVlZERpY3Rpb25hcnkgZW50cmllcyB0byBiZSBJbnB1dFByb3ZpZGVycycgK1xuICAgICAgICAgICAgICAgICdhbmQgbm90IE5EQXJyYXlzLicpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMgPSB0aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzO1xuZnVuY3Rpb24gbG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoYmF0Y2hGZWVkLCBhY3RpdmF0aW9ucywgbWF0aCkge1xuICAgIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICB2YXIgZmVlZEVudHJ5ID0gYmF0Y2hGZWVkLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICBkYXRhID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBwcm92aWRlci5nZXROZXh0Q29weShtYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKGZlZWRFbnRyeS50ZW5zb3Iuc2hhcGUsIGRhdGEuc2hhcGUpLCBcIkVycm9yIGxvYWRpbmcgRmVlZEVudHJ5OiBmZWVkaW5nIE5EQXJyYXkgb2Ygc2hhcGUgXCIgKyBkYXRhLnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwiZG9lcyBub3QgbWF0Y2ggVGVuc29yIChpZDogXCIgKyBmZWVkRW50cnkudGVuc29yLmlkICsgXCIpIHNoYXBlOiBcIikgK1xuICAgICAgICAgICAgKGZlZWRFbnRyeS50ZW5zb3Iuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICBhY3RpdmF0aW9ucy5zZXQoZmVlZEVudHJ5LnRlbnNvciwgZGF0YSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwID0gbG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXA7XG5mdW5jdGlvbiByZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoYmF0Y2hGZWVkLCBhY3RpdmF0aW9ucywgbWF0aCkge1xuICAgIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICB2YXIgZmVlZEVudHJ5ID0gYmF0Y2hGZWVkLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgICAgaWYgKCEoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICAgICAgdmFyIGZlZWRFbnRyeUFycmF5ID0gYWN0aXZhdGlvbnMuZ2V0KGZlZWRFbnRyeS50ZW5zb3IpO1xuICAgICAgICAgICAgcHJvdmlkZXIuZGlzcG9zZUNvcHkobWF0aCwgZmVlZEVudHJ5QXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2YXRpb25zLmRlbGV0ZShmZWVkRW50cnkudGVuc29yKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwID0gcmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwO1xuZnVuY3Rpb24gcmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGZlZWREaWN0aW9uYXJ5LCBldmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgZXZhbHVhdGlvblNldC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmFsdWF0aW9uU2V0W2ldO1xuICAgICAgICBpZiAoZmVlZERpY3Rpb25hcnkuZGljdFtub2RlLm91dHB1dC5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZXZhbHVhdGlvblNldC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldCA9IHJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhldmFsdWF0aW9uU2V0LCB0ZW5zb3JBcnJheU1hcCkge1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIWdyYXBoX3V0aWwuaXNJbnB1dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghZ3JhcGhfdXRpbC5pc1Bhc3N0aHJvdWdoTm9kZShub2RlLCB0ZW5zb3JBcnJheU1hcCkpIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5kaXNwb3NlQXJyYXkobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVuc29yQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMgPSBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHM7XG5mdW5jdGlvbiBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzKGV2YWx1YXRpb25TZXQsIGdyYWRpZW50cykge1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhub2RlLmlucHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXROYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgaWYgKGdyYWRpZW50cy5nZXQoaW5wdXQsIHRydWUpICE9PSBncmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50cy5kaXNwb3NlQXJyYXkoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZGllbnRzLm51bGxpZnkoaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyA9IGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHM7XG5mdW5jdGlvbiBkaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKG9wZXJhdGlvbnMsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpIHtcbiAgICBvcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5kaXNwb3NlVHJhbnNpZW50QXJyYXlzKGFjdGl2YXRpb25zLCBncmFkaWVudHMpOyB9KTtcbn1cbmV4cG9ydHMuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyA9IGRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXM7XG5mdW5jdGlvbiB0aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzKGV2YWx1YXRpb25TZXQpIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlBsYWNlaG9sZGVyTm9kZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gJ1snICsgbm9kZS5vdXRwdXQuc2hhcGUuam9pbignLCAnKSArICddJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxhY2Vob2xkZXIgbm9kZSBcIicgKyBub2RlLm5hbWUgKyAnXCIgJyArIHNoYXBlICtcbiAgICAgICAgICAgICAgICAnIG5vdCBwcmVzZW50IGluIGZlZWQgZGljdGlvbmFyeS4nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy50aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzID0gdGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2Rlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb25fdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRlbnNvckFycmF5TWFwQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXBCYXNlKCkge1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGVuc29yLCBza2lwQ2hlY2tzKSB7XG4gICAgICAgIGlmIChza2lwQ2hlY2tzID09PSB2b2lkIDApIHsgc2tpcENoZWNrcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghc2tpcENoZWNrcyAmJiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBub3QgaW4gYXJyYXkgbWFwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmRhID0gdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgICAgIGlmICghc2tpcENoZWNrcyAmJiBuZGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRlbnNvciBcIiArIHRlbnNvci5pZCArIFwiIGhhcyBudWxsIGFycmF5LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUubnVsbGlmeSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBudWxsO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kaXNwb3NlQXJyYXkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5kYSA9IHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgICAgICBpZiAobmRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmRhLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBudWxsO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kaWN0KS5sZW5ndGg7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgICAgIHZhciBuZGEgPSBfdGhpcy5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgICAgICBpZiAobmRhKSB7XG4gICAgICAgICAgICAgICAgbmRhLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9O1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5oYXNOdWxsQXJyYXkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBub3QgaW4gYXJyYXkgbWFwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXBCYXNlO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yQXJyYXlNYXBCYXNlID0gVGVuc29yQXJyYXlNYXBCYXNlO1xudmFyIFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGFycmF5KSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gYXJyYXk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5UZW5zb3JBcnJheU1hcCA9IFRlbnNvckFycmF5TWFwO1xudmFyIFN1bW1lZFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VtbWVkVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VtbWVkVGVuc29yQXJyYXlNYXAobWF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdW1tZWRUZW5zb3JBcnJheU1hcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlbnNvciwgYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gdGhpcy5tYXRoLmtlZXAoYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXQodGVuc29yKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWF0aC5rZWVwKHRoaXMubWF0aC5hZGRTdHJpY3Qob2xkVmFsdWUsIGFycmF5KSk7XG4gICAgICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgb2xkVmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3VtbWVkVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5TdW1tZWRUZW5zb3JBcnJheU1hcCA9IFN1bW1lZFRlbnNvckFycmF5TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yX2FycmF5X21hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9zZXNzaW9uXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL21hdGgvbmRhcnJheVwiKTtcbnZhciBERUZBVUxUX0VWQUxfSU5URVJWQUxfTVMgPSAxNTAwO1xudmFyIERFRkFVTFRfQ09TVF9JTlRFUlZBTF9NUyA9IDUwMDtcbnZhciBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TID0gMzAwMDtcbnZhciBNZXRyaWNSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKE1ldHJpY1JlZHVjdGlvbikge1xuICAgIE1ldHJpY1JlZHVjdGlvbltNZXRyaWNSZWR1Y3Rpb25bXCJTVU1cIl0gPSAwXSA9IFwiU1VNXCI7XG4gICAgTWV0cmljUmVkdWN0aW9uW01ldHJpY1JlZHVjdGlvbltcIk1FQU5cIl0gPSAxXSA9IFwiTUVBTlwiO1xufSkoTWV0cmljUmVkdWN0aW9uID0gZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gfHwgKGV4cG9ydHMuTWV0cmljUmVkdWN0aW9uID0ge30pKTtcbnZhciBHcmFwaFJ1bm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhSdW5uZXIobWF0aCwgc2Vzc2lvbiwgZXZlbnRPYnNlcnZlcikge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIgPSBldmVudE9ic2VydmVyO1xuICAgICAgICB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMudG90YWxJZGxlVGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRpc3RpY3MoKTtcbiAgICAgICAgdGhpcy56ZXJvU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMCk7XG4gICAgfVxuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXNldFN0YXRpc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZCA9IDA7XG4gICAgICAgIHRoaXMudG90YWxJZGxlVGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U3RvcFRpbWVzdGFtcCA9IG51bGw7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiAoY29zdFRlbnNvciwgdHJhaW5GZWVkRW50cmllcywgYmF0Y2hTaXplLCBvcHRpbWl6ZXIsIG51bUJhdGNoZXMsIG1ldHJpY1RlbnNvciwgbWV0cmljRmVlZEVudHJpZXMsIG1ldHJpY0JhdGNoU2l6ZSwgbWV0cmljUmVkdWN0aW9uLCBldmFsSW50ZXJ2YWxNcywgY29zdEludGVydmFsTXMpIHtcbiAgICAgICAgaWYgKG1ldHJpY1JlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IG1ldHJpY1JlZHVjdGlvbiA9IE1ldHJpY1JlZHVjdGlvbi5NRUFOOyB9XG4gICAgICAgIGlmIChldmFsSW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGV2YWxJbnRlcnZhbE1zID0gREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChjb3N0SW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGNvc3RJbnRlcnZhbE1zID0gREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIHRoaXMuY29zdFRlbnNvciA9IGNvc3RUZW5zb3I7XG4gICAgICAgIHRoaXMudHJhaW5GZWVkRW50cmllcyA9IHRyYWluRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMubWV0cmljVGVuc29yID0gbWV0cmljVGVuc29yO1xuICAgICAgICB0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID0gbWV0cmljRmVlZEVudHJpZXM7XG4gICAgICAgIGlmIChtZXRyaWNCYXRjaFNpemUgIT0gbnVsbCAmJiB0aGlzLm1ldHJpY0JhdGNoU2l6ZSAhPT0gbWV0cmljQmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcobWV0cmljQmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZSA9IG1ldHJpY0JhdGNoU2l6ZTtcbiAgICAgICAgdGhpcy5tZXRyaWNSZWR1Y3Rpb24gPSBtZXRyaWNSZWR1Y3Rpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICB0aGlzLm9wdGltaXplciA9IG9wdGltaXplcjtcbiAgICAgICAgdGhpcy5tZXRyaWNJbnRlcnZhbE1zID0gZXZhbEludGVydmFsTXM7XG4gICAgICAgIHRoaXMuY29zdEludGVydmFsTXMgPSBjb3N0SW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcyA9IG51bUJhdGNoZXM7XG4gICAgICAgIHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuID0gMDtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFpblN0YXJ0VGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudHJhaW5OZXR3b3JrKCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc3RvcFRyYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0U3RvcFRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnJlc3VtZVRyYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5sYXN0U3RvcFRpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMubGFzdFN0b3BUaW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS50cmFpbk5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5zdG9wVHJhaW5pbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNUcmFpbmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciBzaG91bGRDb21wdXRlQ29zdCA9IHRoaXMuZXZlbnRPYnNlcnZlci5hdmdDb3N0Q2FsbGJhY2sgIT0gbnVsbCAmJlxuICAgICAgICAgICAgKHN0YXJ0IC0gdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA+IHRoaXMuY29zdEludGVydmFsTXMpO1xuICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNvc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29zdFJlZHVjdGlvbiA9IHNob3VsZENvbXB1dGVDb3N0ID8gc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb24uTUVBTiA6IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uLk5PTkU7XG4gICAgICAgIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGF2Z0Nvc3QgPSBfdGhpcy5zZXNzaW9uLnRyYWluKF90aGlzLmNvc3RUZW5zb3IsIF90aGlzLnRyYWluRmVlZEVudHJpZXMsIF90aGlzLmJhdGNoU2l6ZSwgX3RoaXMub3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrKGF2Z0Nvc3QpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLnRyYWluRXhhbXBsZXNQZXJTZWNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGFtcGxlc1BlclNlYyA9IChfdGhpcy5iYXRjaFNpemUgKiAxMDAwIC8gdHJhaW5UaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXRyaWNGZWVkRW50cmllcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc3RhcnQgLSBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA+IF90aGlzLm1ldHJpY0ludGVydmFsTXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgPSBfdGhpcy5jb21wdXRlTWV0cmljKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayhfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2soKHN0YXJ0IC0gX3RoaXMudHJhaW5TdGFydFRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1bisrO1xuICAgICAgICAgICAgX3RoaXMudG90YWxCYXRjaGVzVHJhaW5lZCsrO1xuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5iYXRjaGVzVHJhaW5lZENhbGxiYWNrKF90aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRyYWluTmV0d29yaygpOyB9KTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pbmZlciA9IGZ1bmN0aW9uIChpbmZlcmVuY2VUZW5zb3IsIGluZmVyZW5jZUZlZWRFbnRyaWVzLCBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcywgaW5mZXJlbmNlRXhhbXBsZUNvdW50LCBudW1QYXNzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID09PSB2b2lkIDApIHsgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPSBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChpbmZlcmVuY2VFeGFtcGxlQ291bnQgPT09IHZvaWQgMCkgeyBpbmZlcmVuY2VFeGFtcGxlQ291bnQgPSA1OyB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayA9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2UgbG9vcCwgbm8gaW5mZXJlbmNlIGV4YW1wbGUgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2V4YW1wbGVzL3NlYyBvYnNlcnZlciBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVlZEVudHJ5ID0gaW5mZXJlbmNlRmVlZEVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0YXJ0IGluZmVyZW5jZSBvbiB0aGUgbW9kZWwgcnVubmVyIHdpdGggZmVlZCBlbnRyaWVzIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAndHlwZSBOREFycmF5LiBQbGVhc2UgdXNlIElucHV0UHJvdmlkZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPSBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VUZW5zb3IgPSBpbmZlcmVuY2VUZW5zb3I7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXMgPSBpbmZlcmVuY2VGZWVkRW50cmllcztcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ7XG4gICAgICAgIHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMgPSBudW1QYXNzZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luZmVycmluZykge1xuICAgICAgICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuID0gMDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pbmZlck5ldHdvcmsoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0luZmVycmluZyA9IHRydWU7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaW5mZXJOZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcgfHxcbiAgICAgICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50SW5mZXJlbmNlTG9vcE51bVBhc3Nlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCwgdHJhY2spIHtcbiAgICAgICAgICAgIHZhciBmZWVkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGluZmVyZW5jZVZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5kYXJyYXlGZWVkRW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3RoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZlZWRFbnRyeSA9IF90aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENvcHkgPSBmZWVkRW50cnkuZGF0YS5nZXROZXh0Q29weShfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmRhcnJheUZlZWRFbnRyaWVzLnB1c2goeyB0ZW5zb3I6IGZlZWRFbnRyeS50ZW5zb3IsIGRhdGE6IHRyYWNrKG5leHRDb3B5KSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmVlZHMucHVzaChuZGFycmF5RmVlZEVudHJpZXMpO1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZVZhbHVlcy5wdXNoKF90aGlzLnNlc3Npb24uZXZhbChfdGhpcy5pbmZlcmVuY2VUZW5zb3IsIG5kYXJyYXlGZWVkRW50cmllcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlVmFsdWVzW2luZmVyZW5jZVZhbHVlcy5sZW5ndGggLSAxXS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZXNQZXJTZWMgPSAoX3RoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ICogMTAwMCAvIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrKGV4YW1wbGVzUGVyU2VjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayhmZWVkcywgaW5mZXJlbmNlVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGFzdEluZmVyVGltZW91dElEID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW5mZXJOZXR3b3JrKCk7IH0sIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnN0b3BJbmZlcnJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNJbmZlcnJpbmcgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmxhc3RJbmZlclRpbWVvdXRJRCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaXNJbmZlcmVuY2VSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luZmVycmluZztcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5jb21wdXRlTWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5tZXRyaWNGZWVkRW50cmllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIG1ldHJpYywgbm8gbWV0cmljIEZlZWRFbnRyaWVzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRyaWMgPSB0aGlzLnplcm9TY2FsYXI7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubWV0cmljQmF0Y2hTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0cmljVmFsdWUgPSBfdGhpcy5zZXNzaW9uLmV2YWwoX3RoaXMubWV0cmljVGVuc29yLCBfdGhpcy5tZXRyaWNGZWVkRW50cmllcyk7XG4gICAgICAgICAgICAgICAgbWV0cmljID0gX3RoaXMubWF0aC5hZGQobWV0cmljLCBtZXRyaWNWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubWV0cmljUmVkdWN0aW9uID09PSBNZXRyaWNSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgICAgICAgICAgIG1ldHJpYyA9IF90aGlzLm1hdGguZGl2aWRlKG1ldHJpYywgX3RoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmdldFRvdGFsQmF0Y2hlc1RyYWluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQ7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuZ2V0TGFzdENvbXB1dGVkTWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWM7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0TWF0aCA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0SW5mZXJlbmNlVGVuc29yID0gZnVuY3Rpb24gKGluZmVyZW5jZVRlbnNvcikge1xuICAgICAgICB0aGlzLmluZmVyZW5jZVRlbnNvciA9IGluZmVyZW5jZVRlbnNvcjtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRJbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBmdW5jdGlvbiAoaW5mZXJlbmNlRXhhbXBsZUNvdW50KSB7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoUnVubmVyO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhSdW5uZXIgPSBHcmFwaFJ1bm5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoX3J1bm5lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4aHJfZGF0YXNldCA9IHJlcXVpcmUoXCIuL2RhdGEveGhyLWRhdGFzZXRcIik7XG5leHBvcnRzLnhocl9kYXRhc2V0ID0geGhyX2RhdGFzZXQ7XG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL2NvbnZfdXRpbFwiKTtcbmV4cG9ydHMuY29udl91dGlsID0gY29udl91dGlsO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG5leHBvcnRzLmdwZ3B1X3V0aWwgPSBncGdwdV91dGlsO1xudmFyIHJlbmRlcl9uZGFycmF5X2dwdV91dGlsID0gcmVxdWlyZShcIi4vbWF0aC93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbFwiKTtcbmV4cG9ydHMucmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwgPSByZW5kZXJfbmRhcnJheV9ncHVfdXRpbDtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vbWF0aC93ZWJnbC93ZWJnbF91dGlsXCIpO1xuZXhwb3J0cy53ZWJnbF91dGlsID0gd2ViZ2xfdXRpbDtcbnZhciB0ZXN0X3V0aWwgPSByZXF1aXJlKFwiLi90ZXN0X3V0aWxcIik7XG5leHBvcnRzLnRlc3RfdXRpbCA9IHRlc3RfdXRpbDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudXRpbCA9IHV0aWw7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb25fMS52ZXJzaW9uO1xudmFyIGNoZWNrcG9pbnRfbG9hZGVyXzEgPSByZXF1aXJlKFwiLi9kYXRhL2NoZWNrcG9pbnRfbG9hZGVyXCIpO1xuZXhwb3J0cy5DaGVja3BvaW50TG9hZGVyID0gY2hlY2twb2ludF9sb2FkZXJfMS5DaGVja3BvaW50TG9hZGVyO1xudmFyIGRhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGEvZGF0YXNldFwiKTtcbmV4cG9ydHMuSW5NZW1vcnlEYXRhc2V0ID0gZGF0YXNldF8xLkluTWVtb3J5RGF0YXNldDtcbnZhciBpbnB1dF9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vZGF0YS9pbnB1dF9wcm92aWRlclwiKTtcbmV4cG9ydHMuSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gaW5wdXRfcHJvdmlkZXJfMS5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG5leHBvcnRzLkluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IGlucHV0X3Byb3ZpZGVyXzEuSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xudmFyIHhocl9kYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhL3hoci1kYXRhc2V0XCIpO1xuZXhwb3J0cy5YaHJEYXRhc2V0ID0geGhyX2RhdGFzZXRfMS5YaHJEYXRhc2V0O1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuRU5WID0gZW52aXJvbm1lbnRfMS5FTlY7XG5leHBvcnRzLkVudmlyb25tZW50ID0gZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudDtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGgvZ3JhcGhcIik7XG5leHBvcnRzLkdyYXBoID0gZ3JhcGhfMS5HcmFwaDtcbmV4cG9ydHMuVGVuc29yID0gZ3JhcGhfMS5UZW5zb3I7XG52YXIgYWRhZGVsdGFfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBhZGFkZWx0YV9vcHRpbWl6ZXJfMS5BZGFkZWx0YU9wdGltaXplcjtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFncmFkX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IGFkYWdyYWRfb3B0aW1pemVyXzEuQWRhZ3JhZE9wdGltaXplcjtcbnZhciBhZGFtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFtX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IGFkYW1fb3B0aW1pemVyXzEuQWRhbU9wdGltaXplcjtcbnZhciBhZGFtYXhfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IGFkYW1heF9vcHRpbWl6ZXJfMS5BZGFtYXhPcHRpbWl6ZXI7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplclwiKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcjtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBvcHRpbWl6ZXJfMS5PcHRpbWl6ZXI7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXI7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuL2dyYXBoL3Nlc3Npb25cIik7XG5leHBvcnRzLkNvc3RSZWR1Y3Rpb24gPSBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbjtcbmV4cG9ydHMuU2Vzc2lvbiA9IHNlc3Npb25fMS5TZXNzaW9uO1xudmFyIGdyYXBoX3J1bm5lcl8xID0gcmVxdWlyZShcIi4vZ3JhcGhfcnVubmVyXCIpO1xuZXhwb3J0cy5HcmFwaFJ1bm5lciA9IGdyYXBoX3J1bm5lcl8xLkdyYXBoUnVubmVyO1xuZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gPSBncmFwaF9ydW5uZXJfMS5NZXRyaWNSZWR1Y3Rpb247XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi9pbml0aWFsaXplcnNcIik7XG5leHBvcnRzLkNvbnN0YW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5Db25zdGFudEluaXRpYWxpemVyO1xuZXhwb3J0cy5OREFycmF5SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5OREFycmF5SW5pdGlhbGl6ZXI7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLk9uZXNJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xuZXhwb3J0cy5aZXJvc0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuWmVyb3NJbml0aWFsaXplcjtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhcIik7XG5leHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IG1hdGhfMS5OREFycmF5TWF0aDtcbnZhciBtYXRoX2NwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoX2NwdVwiKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhDUFUgPSBtYXRoX2NwdV8xLk5EQXJyYXlNYXRoQ1BVO1xudmFyIG1hdGhfZ3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhfZ3B1XCIpO1xuZXhwb3J0cy5OREFycmF5TWF0aEdQVSA9IG1hdGhfZ3B1XzEuTkRBcnJheU1hdGhHUFU7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xuZXhwb3J0cy5pbml0aWFsaXplR1BVID0gbmRhcnJheV8xLmluaXRpYWxpemVHUFU7XG52YXIgbmRhcnJheV8yID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xuZXhwb3J0cy5BcnJheTFEID0gbmRhcnJheV8yLkFycmF5MUQ7XG5leHBvcnRzLkFycmF5MkQgPSBuZGFycmF5XzIuQXJyYXkyRDtcbmV4cG9ydHMuQXJyYXkzRCA9IG5kYXJyYXlfMi5BcnJheTNEO1xuZXhwb3J0cy5BcnJheTREID0gbmRhcnJheV8yLkFycmF5NEQ7XG5leHBvcnRzLk5EQXJyYXkgPSBuZGFycmF5XzIuTkRBcnJheTtcbmV4cG9ydHMuU2NhbGFyID0gbmRhcnJheV8yLlNjYWxhcjtcbnZhciBncGdwdV9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL2dwZ3B1X2NvbnRleHRcIik7XG5leHBvcnRzLkdQR1BVQ29udGV4dCA9IGdwZ3B1X2NvbnRleHRfMS5HUEdQVUNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9tYXRoL25kYXJyYXlcIik7XG52YXIgVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyKHNjYWxlLCBtb2RlLCBkaXN0cmlidXRpb24pIHtcbiAgICAgICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxLjA7IH1cbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gJ2Zhbl9pbic7IH1cbiAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbiA9PT0gdm9pZCAwKSB7IGRpc3RyaWJ1dGlvbiA9ICdub3JtYWwnOyB9XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb24gPSBkaXN0cmlidXRpb247XG4gICAgfVxuICAgIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZmFuX2luJykge1xuICAgICAgICAgICAgbiA9IGlucHV0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuX291dCcpIHtcbiAgICAgICAgICAgIG4gPSBvdXRwdXRVbml0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdmYW5fYXZnJykge1xuICAgICAgICAgICAgbiA9IChpbnB1dFVuaXRzICsgb3V0cHV0VW5pdHMpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbW9kZSBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogXCIgKyB0aGlzLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kVHJ1bmNhdGVkTm9ybWFsKHdlaWdodHNTaGFwZSwgMC4wLCBNYXRoLnNxcnQodGhpcy5zY2FsZSAvIG4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFVuaWZvcm0od2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCgzICogdGhpcy5zY2FsZSAvIG4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZGlzdHJpYnV0aW9uIGZvciB2YXJpYW5jZSBzY2FsaW5nIGluaXRpYWxpemVyOiBcIiArXG4gICAgICAgICAgICAgICAgKFwiXCIgKyB0aGlzLmRpc3RyaWJ1dGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xudmFyIFplcm9zSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFplcm9zSW5pdGlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIFplcm9zSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBaZXJvc0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuWmVyb3NJbml0aWFsaXplciA9IFplcm9zSW5pdGlhbGl6ZXI7XG52YXIgT25lc0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVzSW5pdGlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIE9uZXNJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YWx1ZXMuZmlsbCgxKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiBPbmVzSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5PbmVzSW5pdGlhbGl6ZXIgPSBPbmVzSW5pdGlhbGl6ZXI7XG52YXIgQ29uc3RhbnRJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnRJbml0aWFsaXplcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDA7IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBDb25zdGFudEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgICAgIHZhbHVlcy5maWxsKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnN0YW50SW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5Db25zdGFudEluaXRpYWxpemVyID0gQ29uc3RhbnRJbml0aWFsaXplcjtcbnZhciBOREFycmF5SW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlJbml0aWFsaXplcihuZGFycmF5KSB7XG4gICAgICAgIHRoaXMubmRhcnJheSA9IG5kYXJyYXk7XG4gICAgfVxuICAgIE5EQXJyYXlJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheUluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheUluaXRpYWxpemVyID0gTkRBcnJheUluaXRpYWxpemVyO1xudmFyIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21Ob3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IFJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyKG1pbnZhbCwgbWF4dmFsKSB7XG4gICAgICAgIGlmIChtaW52YWwgPT09IHZvaWQgMCkgeyBtaW52YWwgPSAtLjA1OyB9XG4gICAgICAgIGlmIChtYXh2YWwgPT09IHZvaWQgMCkgeyBtYXh2YWwgPSAuMDU7IH1cbiAgICAgICAgdGhpcy5taW52YWwgPSBtaW52YWw7XG4gICAgICAgIHRoaXMubWF4dmFsID0gbWF4dmFsO1xuICAgIH1cbiAgICBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFVuaWZvcm0od2VpZ2h0c1NoYXBlLCB0aGlzLm1pbnZhbCwgdGhpcy5tYXh2YWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRpYWxpemVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIFRhbkhGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYW5IRnVuYygpIHtcbiAgICB9XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnRhbmgoeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5U3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeSwgeSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsYXJNaW51c0FycmF5KG5kYXJyYXlfMS5TY2FsYXIuT05FLCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFRhbkhGdW5jO1xufSgpKTtcbmV4cG9ydHMuVGFuSEZ1bmMgPSBUYW5IRnVuYztcbnZhciBSZUxVRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVMVUZ1bmMoKSB7XG4gICAgfVxuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5yZWx1KHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zdGVwKHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBSZUxVRnVuYztcbn0oKSk7XG5leHBvcnRzLlJlTFVGdW5jID0gUmVMVUZ1bmM7XG52YXIgTGVha3lSZWx1RnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGVha3lSZWx1RnVuYyhhbHBoYSkge1xuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIExlYWt5UmVsdUZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmxlYWt5UmVsdSh4LCB0aGlzLmFscGhhKTtcbiAgICB9O1xuICAgIExlYWt5UmVsdUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnN0ZXAoeCwgdGhpcy5hbHBoYSk7XG4gICAgfTtcbiAgICBMZWFreVJlbHVGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBMZWFreVJlbHVGdW5jO1xufSgpKTtcbmV4cG9ydHMuTGVha3lSZWx1RnVuYyA9IExlYWt5UmVsdUZ1bmM7XG52YXIgU2lnbW9pZEZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpZ21vaWRGdW5jKCkge1xuICAgIH1cbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc2lnbW9pZCh4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHlTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh5LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh5LCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFNpZ21vaWRGdW5jO1xufSgpKTtcbmV4cG9ydHMuU2lnbW9pZEZ1bmMgPSBTaWdtb2lkRnVuYztcbnZhciBTcXVhcmVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVGdW5jKCkge1xuICAgIH1cbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5lbGVtZW50V2lzZU11bCh4LCB4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsYXJUaW1lc0FycmF5KG5kYXJyYXlfMS5TY2FsYXIuVFdPLCB4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBTcXVhcmVGdW5jO1xufSgpKTtcbmV4cG9ydHMuU3F1YXJlRnVuYyA9IFNxdWFyZUZ1bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3RpdmF0aW9uX2Z1bmN0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5heGVzQXJlSW5uZXJNb3N0RGltcyA9IGF4ZXNBcmVJbm5lck1vc3REaW1zO1xuZnVuY3Rpb24gY29tYmluZUxvY2F0aW9ucyhvdXRwdXRMb2MsIHJlZHVjZUxvYywgYXhlcykge1xuICAgIHZhciByYW5rID0gb3V0cHV0TG9jLmxlbmd0aCArIHJlZHVjZUxvYy5sZW5ndGg7XG4gICAgdmFyIGxvYyA9IFtdO1xuICAgIHZhciBvdXRJZHggPSAwO1xuICAgIHZhciByZWR1Y2VJZHggPSAwO1xuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxvYy5wdXNoKG91dHB1dExvY1tvdXRJZHgrK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9jLnB1c2gocmVkdWNlTG9jW3JlZHVjZUlkeCsrXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvYztcbn1cbmV4cG9ydHMuY29tYmluZUxvY2F0aW9ucyA9IGNvbWJpbmVMb2NhdGlvbnM7XG5mdW5jdGlvbiBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGFTaGFwZSwgYXhlcykge1xuICAgIHZhciBvdXRTaGFwZSA9IFtdO1xuICAgIHZhciByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBvdXRTaGFwZS5wdXNoKGFTaGFwZVtkaW1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVkdWNlU2hhcGUgPSBheGVzLm1hcChmdW5jdGlvbiAoZGltKSB7IHJldHVybiBhU2hhcGVbZGltXTsgfSk7XG4gICAgcmV0dXJuIFtvdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcztcbmZ1bmN0aW9uIGV4cGFuZFNoYXBlVG9LZWVwRGltKHNoYXBlLCBheGVzKSB7XG4gICAgdmFyIHJlZHVjZVN1YlNoYXBlID0gYXhlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDE7IH0pO1xuICAgIHJldHVybiBjb21iaW5lTG9jYXRpb25zKHNoYXBlLCByZWR1Y2VTdWJTaGFwZSwgYXhlcyk7XG59XG5leHBvcnRzLmV4cGFuZFNoYXBlVG9LZWVwRGltID0gZXhwYW5kU2hhcGVUb0tlZXBEaW07XG5mdW5jdGlvbiBwYXJzZUF4aXNQYXJhbShheGlzLCBzaGFwZSkge1xuICAgIGlmIChheGlzID09IG51bGwpIHtcbiAgICAgICAgYXhpcyA9IHNoYXBlLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoYXhpcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGF4aXMgPSBbYXhpc107XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xufVxuZXhwb3J0cy5wYXJzZUF4aXNQYXJhbSA9IHBhcnNlQXhpc1BhcmFtO1xuZnVuY3Rpb24gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMobXNnLCBheGVzLCByYW5rKSB7XG4gICAgaWYgKCFheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnICsgXCIgc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gXCIgK1xuICAgICAgICAgICAgKFwiR290IGF4ZXMgXCIgKyBheGVzICsgXCIgYW5kIHJhbmstXCIgKyByYW5rICsgXCIgaW5wdXQuXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zID0gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXM7XG5mdW5jdGlvbiBnZXRQZXJtdXRlZEF4ZXMoYXhlcywgcmFuaykge1xuICAgIGlmIChheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBheGVzLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGF4aXMpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRQZXJtdXRlZEF4ZXMgPSBnZXRQZXJtdXRlZEF4ZXM7XG5mdW5jdGlvbiBnZXRJbm5lck1vc3RBeGVzKG51bUF4ZXMsIHJhbmspIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHJhbmsgLSBudW1BeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5nZXRJbm5lck1vc3RBeGVzID0gZ2V0SW5uZXJNb3N0QXhlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF4aXNfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgICAgdmFyIGEgPSBpblNoYXBlW2RpbV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xufVxuZXhwb3J0cy5nZXRCcm9hZGNhc3REaW1zID0gZ2V0QnJvYWRjYXN0RGltcztcbmZ1bmN0aW9uIGJyb2FkY2FzdERpbXNBcmVPdXRlcihkaW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkaW1zW2ldICE9PSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmJyb2FkY2FzdERpbXNBcmVPdXRlciA9IGJyb2FkY2FzdERpbXNBcmVPdXRlcjtcbmZ1bmN0aW9uIGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHNoYXBlQSwgc2hhcGVCKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBlcnJNc2cgPSBcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIgK1xuICAgICAgICAoc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIuXCIpO1xuICAgIHZhciBsID0gTWF0aC5tYXgoc2hhcGVBLmxlbmd0aCwgc2hhcGVCLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBzaGFwZUFbc2hhcGVBLmxlbmd0aCAtIGkgLSAxXSB8fCAxO1xuICAgICAgICB2YXIgYiA9IHNoYXBlQltzaGFwZUIubGVuZ3RoIC0gaSAtIDFdIHx8IDE7XG4gICAgICAgIGlmIChhID4gMSAmJiBiID4gMSAmJiBhICE9PSBiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KE1hdGgubWF4KGEsIGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUgPSBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb2FkY2FzdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2VydFBhcmFtcyhhU2hhcGUsIGJTaGFwZSwgYXhpcykge1xuICAgIHZhciBhUmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgdmFyIGJSYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgICB1dGlsLmFzc2VydChhU2hhcGUubGVuZ3RoID09PSBiU2hhcGUubGVuZ3RoLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IHJhbmsgb2YgeDEgKFwiICsgYVJhbmsgKyBcIikgYW5kIHgyIChcIiArIGJSYW5rICsgXCIpIFwiICtcbiAgICAgICAgXCJtdXN0IGJlIHRoZSBzYW1lLlwiKTtcbiAgICB1dGlsLmFzc2VydChheGlzID49IDAgJiYgYXhpcyA8IGFSYW5rLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IGF4aXMgbXVzdCBiZSBcIiArXG4gICAgICAgIChcImJldHdlZW4gMCBhbmQgXCIgKyAoYVJhbmsgLSAxKSArIFwiLlwiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhUmFuazsgaSsrKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KChpID09PSBheGlzKSB8fCAoYVNoYXBlW2ldID09PSBiU2hhcGVbaV0pLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IFNoYXBlIChcIiArIGFTaGFwZSArIFwiKSBkb2VzIG5vdCBtYXRjaCBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyBiU2hhcGUgKyBcIikgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyBcIiArIGkgKyBcIi5cIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UGFyYW1zID0gYXNzZXJ0UGFyYW1zO1xuZnVuY3Rpb24gY29tcHV0ZU91dFNoYXBlKHgxU2hhcGUsIHgyU2hhcGUsIGF4aXMpIHtcbiAgICB1dGlsLmFzc2VydCh4MVNoYXBlLmxlbmd0aCA9PT0geDJTaGFwZS5sZW5ndGgsICd4MSBhbmQgeDIgc2hvdWxkIGhhdmUgdGhlIHNhbWUgcmFuay4nKTtcbiAgICB2YXIgb3V0cHV0U2hhcGUgPSB4MVNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbYXhpc10gKz0geDJTaGFwZVtheGlzXTtcbiAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG59XG5leHBvcnRzLmNvbXB1dGVPdXRTaGFwZSA9IGNvbXB1dGVPdXRTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aHdpc2VDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBwYWQpIHtcbiAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyU2hhcGVbMF0sIGZpbHRlcldpZHRoID0gZmlsdGVyU2hhcGVbMV0sIGluQ2hhbm5lbHMgPSBmaWx0ZXJTaGFwZVsyXSwgY2hhbm5lbE11bCA9IGZpbHRlclNoYXBlWzNdO1xuICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2FbMF0sIHN0cmlkZVdpZHRoID0gX2FbMV07XG4gICAgdmFyIGluSGVpZ2h0ID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgaW5XaWR0aCA9IGluU2hhcGVbMl07XG4gICAgdmFyIGJhdGNoU2l6ZSA9IGluU2hhcGVbMF07XG4gICAgdmFyIF9iID0gZ2V0UGFkQW5kT3V0SW5mbyhwYWQsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKSwgcGFkSW5mbyA9IF9iLnBhZEluZm8sIG91dEhlaWdodCA9IF9iLm91dEhlaWdodCwgb3V0V2lkdGggPSBfYi5vdXRXaWR0aDtcbiAgICB2YXIgb3V0Q2hhbm5lbHMgPSBpbkNoYW5uZWxzICogY2hhbm5lbE11bDtcbiAgICB2YXIgb3V0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRIZWlnaHQsIG91dFdpZHRoLCBvdXRDaGFubmVsc107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5TaGFwZTogaW5TaGFwZSxcbiAgICAgICAgb3V0U2hhcGU6IG91dFNoYXBlLFxuICAgICAgICBjaGFubmVsTXVsOiBjaGFubmVsTXVsLFxuICAgICAgICBzdHJpZGVIZWlnaHQ6IHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGg6IHN0cmlkZVdpZHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgZmlsdGVyV2lkdGg6IGZpbHRlcldpZHRoLFxuICAgICAgICBwYWRJbmZvOiBwYWRJbmZvXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZURlcHRod2lzZUNvbnYyREluZm8gPSBjb21wdXRlRGVwdGh3aXNlQ29udjJESW5mbztcbmZ1bmN0aW9uIGNvbXB1dGVDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpIHtcbiAgICB2YXIgaW5IZWlnaHQgPSBpblNoYXBlWzBdO1xuICAgIHZhciBpbldpZHRoID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgX2EgPSBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpLCBwYWRJbmZvID0gX2EucGFkSW5mbywgb3V0SGVpZ2h0ID0gX2Eub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IF9hLm91dFdpZHRoO1xuICAgIHZhciBvdXRTaGFwZSA9IFtvdXRIZWlnaHQsIG91dFdpZHRoLCBvdXREZXB0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5TaGFwZTogaW5TaGFwZSxcbiAgICAgICAgb3V0U2hhcGU6IG91dFNoYXBlLFxuICAgICAgICBwYWRJbmZvOiBwYWRJbmZvLFxuICAgICAgICBzdHJpZGVIZWlnaHQ6IHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGg6IHN0cmlkZVdpZHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgZmlsdGVyV2lkdGg6IGZpbHRlcldpZHRoXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUNvbnYyREluZm8gPSBjb21wdXRlQ29udjJESW5mbztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRwdXRTaGFwZTNEKGluU2hhcGUsIGZpZWxkU2l6ZSwgb3V0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgIGlmICh6ZXJvUGFkID09IG51bGwpIHtcbiAgICAgICAgemVyb1BhZCA9IGNvbXB1dGVEZWZhdWx0UGFkKGluU2hhcGUsIGZpZWxkU2l6ZSwgc3RyaWRlKTtcbiAgICB9XG4gICAgdmFyIGlucHV0Um93cyA9IGluU2hhcGVbMF07XG4gICAgdmFyIGlucHV0Q29scyA9IGluU2hhcGVbMV07XG4gICAgdmFyIG91dHB1dFJvd3MgPSAoaW5wdXRSb3dzIC0gZmllbGRTaXplICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlICsgMTtcbiAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KG91dHB1dFJvd3MpLCBcIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIiArIG91dHB1dFJvd3MgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgXCJzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgdmFyIG91dHB1dENvbHMgPSAoaW5wdXRDb2xzIC0gZmllbGRTaXplICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlICsgMTtcbiAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KG91dHB1dENvbHMpLCBcIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIiArIG91dHB1dENvbHMgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgXCIgK1xuICAgICAgICBcInRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgcmV0dXJuIFtvdXRwdXRSb3dzLCBvdXRwdXRDb2xzLCBvdXREZXB0aF07XG59XG5leHBvcnRzLmNvbXB1dGVPdXRwdXRTaGFwZTNEID0gY29tcHV0ZU91dHB1dFNoYXBlM0Q7XG5mdW5jdGlvbiBjb21wdXRlRGVmYXVsdFBhZChpbnB1dFNoYXBlLCBmaWVsZFNpemUsIHN0cmlkZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChpbnB1dFNoYXBlWzBdICogKHN0cmlkZSAtIDEpIC0gc3RyaWRlICsgZmllbGRTaXplKSAvIDIpO1xufVxuZXhwb3J0cy5jb21wdXRlRGVmYXVsdFBhZCA9IGNvbXB1dGVEZWZhdWx0UGFkO1xuZnVuY3Rpb24gY29tcHV0ZVdlaWdodHNTaGFwZTREKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKSB7XG4gICAgcmV0dXJuIFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpbnB1dERlcHRoLCBvdXRwdXREZXB0aF07XG59XG5leHBvcnRzLmNvbXB1dGVXZWlnaHRzU2hhcGU0RCA9IGNvbXB1dGVXZWlnaHRzU2hhcGU0RDtcbmZ1bmN0aW9uIGNvbXB1dGVEaWxhdGVkUkMocmMsIG9yaWdTdHJpZGUpIHtcbiAgICB2YXIgcm93c0RpbGF0ZWQgPSAocmNbMF0gLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIHZhciBjb2xzRGlsYXRlZCA9IChyY1sxXSAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gICAgcmV0dXJuIFtyb3dzRGlsYXRlZCwgY29sc0RpbGF0ZWRdO1xufVxuZXhwb3J0cy5jb21wdXRlRGlsYXRlZFJDID0gY29tcHV0ZURpbGF0ZWRSQztcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbmZ1bmN0aW9uIGdldFBhZEFuZE91dEluZm8ocGFkLCBpbkhlaWdodCwgaW5XaWR0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCkge1xuICAgIHZhciBwYWRJbmZvO1xuICAgIHZhciBvdXRIZWlnaHQ7XG4gICAgdmFyIG91dFdpZHRoO1xuICAgIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCB9O1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGUzRChbaW5IZWlnaHQsIGluV2lkdGgsIDFdLCBmaWx0ZXJIZWlnaHQsIDEsIHN0cmlkZUhlaWdodCwgcGFkKTtcbiAgICAgICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMF07XG4gICAgICAgIG91dFdpZHRoID0gb3V0U2hhcGVbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhZCA9PT0gJ3NhbWUnKSB7XG4gICAgICAgIG91dEhlaWdodCA9IE1hdGguY2VpbChpbkhlaWdodCAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKGluV2lkdGggLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgIHZhciBwYWRBbG9uZ0hlaWdodCA9IChvdXRIZWlnaHQgLSAxKSAqIHN0cmlkZUhlaWdodCArIGZpbHRlckhlaWdodCAtIGluSGVpZ2h0O1xuICAgICAgICB2YXIgcGFkQWxvbmdXaWR0aCA9IChvdXRXaWR0aCAtIDEpICogc3RyaWRlV2lkdGggKyBmaWx0ZXJXaWR0aCAtIGluV2lkdGg7XG4gICAgICAgIHZhciB0b3BfMSA9IE1hdGguZmxvb3IocGFkQWxvbmdIZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHBhZEFsb25nSGVpZ2h0IC0gdG9wXzE7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5mbG9vcihwYWRBbG9uZ1dpZHRoIC8gMik7XG4gICAgICAgIHZhciByaWdodCA9IHBhZEFsb25nV2lkdGggLSBsZWZ0O1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IHRvcF8xLCBib3R0b206IGJvdHRvbSwgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhZCA9PT0gJ3ZhbGlkJykge1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKChpbkhlaWdodCAtIGZpbHRlckhlaWdodCArIDEpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoKGluV2lkdGggLSBmaWx0ZXJXaWR0aCArIDEpIC8gc3RyaWRlV2lkdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIiArIHBhZCk7XG4gICAgfVxuICAgIHJldHVybiB7IHBhZEluZm86IHBhZEluZm8sIG91dEhlaWdodDogb3V0SGVpZ2h0LCBvdXRXaWR0aDogb3V0V2lkdGggfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemUsIGRlc3RTaXplKSB7XG4gICAgdmFyIHNyY0FyZWEgPSBzb3VyY2VTaXplWzBdICogc291cmNlU2l6ZVsxXTtcbiAgICB2YXIgZHN0QXJlYSA9IGRlc3RTaXplWzBdICogZGVzdFNpemVbMV07XG4gICAgaWYgKHNyY0FyZWEgIT09IGRzdEFyZWEpIHtcbiAgICAgICAgdmFyIHNyY1N0ciA9IFwiW1wiICsgc291cmNlU2l6ZVswXSArIFwiLCBcIiArIHNvdXJjZVNpemVbMV0gKyBcIl1cIjtcbiAgICAgICAgdmFyIGRzdFN0ciA9IFwiW1wiICsgZGVzdFNpemVbMF0gKyBcIiwgXCIgKyBkZXN0U2l6ZVsxXSArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3B5MkQgc2hhcGVzIGhhdmUgZGlmZmVyZW50IGFyZWFzOlxcbiAgc291cmNlU2l6ZSBcIiArIHNyY1N0ciArXG4gICAgICAgICAgICAoXCIsIGFyZWEgXCIgKyBzcmNBcmVhICsgXCJcXG4gIGRlc3RTaXplIFwiICsgZHN0U3RyICsgXCIsIGFyZWEgXCIgKyBkc3RBcmVhKSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNoYXBlcyA9IHZhbGlkYXRlU2hhcGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weTJkX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBTcXVhcmVDb3N0RnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3F1YXJlQ29zdEZ1bmMoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDAuNSk7XG4gICAgfVxuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKG1hdGgsIHgxLCB4Mikge1xuICAgICAgICB2YXIgZGlmZiA9IG1hdGguc3ViU3RyaWN0KHgxLCB4Mik7XG4gICAgICAgIHZhciBkaWZmU3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZGlmZiwgZGlmZik7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodGhpcy5oYWxmT25lLCBkaWZmU3F1YXJlZCk7XG4gICAgICAgIGRpZmYuZGlzcG9zZSgpO1xuICAgICAgICBkaWZmU3F1YXJlZC5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTcXVhcmVDb3N0RnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gbWF0aC5zdWJTdHJpY3QoeDEsIHgyKTtcbiAgICB9O1xuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbGZPbmUuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNxdWFyZUNvc3RGdW5jO1xufSgpKTtcbmV4cG9ydHMuU3F1YXJlQ29zdEZ1bmMgPSBTcXVhcmVDb3N0RnVuYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvc3RfZnVuY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbmNhdF91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBjb3B5MmRfdXRpbCA9IHJlcXVpcmUoXCIuL2NvcHkyZF91dGlsXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgc2xpY2VfdXRpbCA9IHJlcXVpcmUoXCIuL3NsaWNlX3V0aWxcIik7XG52YXIgU3VtVHlwZXNNYXA7XG4oZnVuY3Rpb24gKFN1bVR5cGVzTWFwKSB7XG4gICAgU3VtVHlwZXNNYXBbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgU3VtVHlwZXNNYXBbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBTdW1UeXBlc01hcFtcImJvb2xcIl0gPSBcImludDMyXCI7XG59KShTdW1UeXBlc01hcCA9IGV4cG9ydHMuU3VtVHlwZXNNYXAgfHwgKGV4cG9ydHMuU3VtVHlwZXNNYXAgPSB7fSkpO1xudmFyIE5EQXJyYXlNYXRoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOREFycmF5TWF0aChzYWZlTW9kZSkge1xuICAgICAgICB0aGlzLnNhZmVNb2RlID0gc2FmZU1vZGU7XG4gICAgICAgIHRoaXMubmRhcnJheVNjb3BlcyA9IFtdO1xuICAgICAgICB0aGlzLm5kYXJyYXlzVG9LZWVwID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCA9IFtdO1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAoc2NvcGVGbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXJ0U2NvcGUoKTtcbiAgICAgICAgdmFyIGtlZXBGbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7IHJldHVybiBfdGhpcy5rZWVwKG5kYXJyYXkpOyB9O1xuICAgICAgICB2YXIgdHJhY2tGbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7IHJldHVybiBfdGhpcy50cmFjayhuZGFycmF5KTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNjb3BlRm4oa2VlcEZuLCB0cmFja0ZuKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy5lbmRTY29wZShyKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmRTY29wZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVuYWJsZURlYnVnTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsICcgK1xuICAgICAgICAgICAgJ2JlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiAnICtcbiAgICAgICAgICAgICdUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS4nKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdGFydFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3U2NvcGUgPSBbXTtcbiAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzLnB1c2gobmV3U2NvcGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgIHZhciBuZXdOREFycmF5c1RvS2VlcCA9IFtdO1xuICAgICAgICB0aGlzLm5kYXJyYXlzVG9LZWVwLnB1c2gobmV3TkRBcnJheXNUb0tlZXApO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAgPSBuZXdOREFycmF5c1RvS2VlcDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5leHRyYWN0TkRBcnJheXNGcm9tU2NvcGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHZhciByZXN1bHRPYmogPSByZXN1bHQ7XG4gICAgICAgIGZvciAodmFyIGsgaW4gcmVzdWx0T2JqKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gcmVzdWx0T2JqW2tdO1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZW5kU2NvcGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcnJheXNUb0tlZXAgPSB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXA7XG4gICAgICAgIHZhciByZXN1bHRBcnJheXMgPSB0aGlzLmV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdChyZXN1bHQpO1xuICAgICAgICBhcnJheXNUb0tlZXAgPSBhcnJheXNUb0tlZXAuY29uY2F0KHJlc3VsdEFycmF5cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTY29wZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSB0aGlzLmFjdGl2ZVNjb3BlW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOREFycmF5RGF0YUluTGlzdChuZGFycmF5LCBhcnJheXNUb0tlZXApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZGFycmF5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXMucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB0aGlzLm5kYXJyYXlTY29wZXMubGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzW3RoaXMubmRhcnJheVNjb3Blcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmVzdWx0QXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc05EQXJyYXlEYXRhSW5MaXN0KHZhbCwgX3RoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFjayh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcC5wb3AoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gdGhpcy5uZGFycmF5c1RvS2VlcC5sZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICB0aGlzLm5kYXJyYXlzVG9LZWVwW3RoaXMubmRhcnJheXNUb0tlZXAubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuaXNOREFycmF5RGF0YUluTGlzdCA9IGZ1bmN0aW9uIChuZGFycmF5LCBuZGFycmF5TGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5kYXJyYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmRhcnJheUxpc3RbaV0uZ2V0RGF0YSgpID09PSBuZGFycmF5LmdldERhdGEoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5rZWVwID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVTY29wZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zYWZlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSB1c2luZyBtYXRoIGluIHNhZmUgbW9kZS4gRW5jbG9zZSBhbGwgJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLm1ldGhvZCgpIGNhbGxzIGluc2lkZSBhIHNjb3BlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGguc2NvcGUoKCkgPT4ge21hdGgubWV0aG9kKCk7Li4ufSkgdG8gYXZvaWQgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVha3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY2hlY2tGb3JOYU4gPSBmdW5jdGlvbiAodmFscywgZHR5cGUsIG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWxzW2ldLCBkdHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlIGxhc3QgbWF0aC5cIiArIG5hbWUgKyBcIiBoYXMgTmFOcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU2NvcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FmZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgdXNpbmcgbWF0aCBpbiBzYWZlIG1vZGUuIEVuY2xvc2UgYWxsICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLnNjb3BlKCgpID0+IHttYXRoLm1ldGhvZCgpOy4uLn0pIHRvIGF2b2lkIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWtzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGFPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgaWYgKGJPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGJPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgdmFyIGlubmVyU2hhcGVBID0gKGFPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGlubmVyU2hhcGVCID0gKGJPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiLnNoYXBlWzBdIDogYi5zaGFwZVsxXTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSAyICYmIGIucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGJlIHJhbmsgMiwgZ290IHJhbmtzIFwiICsgYS5yYW5rICtcbiAgICAgICAgICAgIChcIiBhbmQgXCIgKyBiLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbm5lclNoYXBlQSA9PT0gaW5uZXJTaGFwZUIsIFwiRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiICsgaW5uZXJTaGFwZUEgKyBcIikgYW5kIChcIiArXG4gICAgICAgICAgICAoaW5uZXJTaGFwZUIgKyBcIikgb2YgTkRBcnJheXMgd2l0aCBzaGFwZXMgXCIgKyBhLnNoYXBlICsgXCIgYW5kIFwiKSArXG4gICAgICAgICAgICAoYi5zaGFwZSArIFwiIGFuZCBvcmllbnRhdGlvbnMgXCIgKyBNYXRyaXhPcmllbnRhdGlvblthT3JpZW50YXRpb25dKSArXG4gICAgICAgICAgICAoXCIgYW5kIFwiICsgTWF0cml4T3JpZW50YXRpb25bYk9yaWVudGF0aW9uXSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXRNdWwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tYXRNdWxJbnRlcm5hbChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmKCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHV0aWwucmlnaHRQYWQocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCArIFwibXNcIiwgOSk7XG4gICAgICAgICAgICB2YXIgcGFkZGVkTmFtZSA9IHV0aWwucmlnaHRQYWQobmFtZSwgMjUpO1xuICAgICAgICAgICAgdmFyIHJhbmsgPSByZXN1bHQucmFuaztcbiAgICAgICAgICAgIHZhciBzaXplID0gcmVzdWx0LnNpemU7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB1dGlsLnJpZ2h0UGFkKHJlc3VsdC5zaGFwZS50b1N0cmluZygpLCAxNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVjXCIgKyBwYWRkZWROYW1lICsgXCJcXHQlY1wiICsgdGltZSArIFwiXFx0JWNcIiArIHJhbmsgKyBcIkQgXCIgKyBzaGFwZSArIFwiXFx0JWNcIiArIHNpemUsICdmb250LXdlaWdodDpib2xkJywgJ2NvbG9yOnJlZCcsICdjb2xvcjpibHVlJywgJ2NvbG9yOiBvcmFuZ2UnKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JOYU4odmFscywgcmVzdWx0LmR0eXBlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFjayhyZXN1bHQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnZlY3RvclRpbWVzTWF0cml4ID0gZnVuY3Rpb24gKHYsIG1hdHJpeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh2LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IGZpcnN0IGlucHV0IG11c3QgYmUgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgYmUgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzBdLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIHZlY3RvciAoXCIgKyB2LnNpemUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IChcIiArIG1hdHJpeC5zaGFwZVswXSArIFwiKVwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bCh2LmFzMkQoMSwgLTEpLCBtYXRyaXgpLmFzMUQoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXRyaXhUaW1lc1ZlY3RvciA9IGZ1bmN0aW9uIChtYXRyaXgsIHYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzZWNvbmQgaW5wdXQgbXVzdCByYW5rIDEsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIHYucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1hdHJpeC5yYW5rID09PSAyLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzFdLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCBcIiArIHYuc2l6ZSArIFwiIFwiICtcbiAgICAgICAgICAgIFwibXVzdCBtYXRjaCBpbm5lciBkaW1lbnNpb24gb2Ygc2Vjb25kIHJhbmsgMiBpbnB1dCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJzaGFwZSBcIiArIG1hdHJpeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bChtYXRyaXgsIHYuYXMyRCgtMSwgMSkpLmFzMUQoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kb3RQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh2MS5yYW5rICsgXCIgYW5kIFwiICsgdjIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnNpemUgPT09IHYyLnNpemUsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogc2l6ZSBvZiBpbnB1dHMgKFwiICsgdjEuc2l6ZSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgICh2Mi5zaXplICsgXCIpIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0TXVsKHYxLmFzMkQoMSwgLTEpLCB2Mi5hczJEKC0xLCAxKSkuYXNTY2FsYXIoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5vdXRlclByb2R1Y3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSwgXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRNdWwodjEuYXMyRCgtMSwgMSksIHYyLmFzMkQoMSwgLTEpKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY2xvbmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbG9uZUludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKG5kYXJyYXksIG5ld1NoYXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWF0aC5yZXNoYXBlKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGNhbGwgcmVzaGFwZSgpICcgK1xuICAgICAgICAgICAgJ2RpcmVjdGx5IG9uIHRoZSBuZGFycmF5IG9iamVjdCcpO1xuICAgICAgICByZXR1cm4gbmRhcnJheS5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zbGljZTFEID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBbYmVnaW5dLCBbc2l6ZV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlMUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTFESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2UyRCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlMkQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTJESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2UzRCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlM0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTNESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2U0RCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlNEQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTRESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29weTJEID0gZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlQmVnaW4sIHNvdXJjZVNpemUsIGRlc3QsIGRlc3RCZWdpbiwgZGVzdFNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc291cmNlQmVnaW5bMF0gKyBzb3VyY2VTaXplWzBdIDw9IHNvdXJjZS5zaGFwZVswXSAmJlxuICAgICAgICAgICAgc291cmNlQmVnaW5bMV0gKyBzb3VyY2VTaXplWzFdIDw9IHNvdXJjZS5zaGFwZVsxXSwgXCJFcnJvciBpbiBjb3B5MkQ6IHJlcXVlc3RlZCBzb3VyY2Ugc3RhcnQgcG9zaXRpb24gXCIgKyBzb3VyY2VCZWdpbiArIFwiIFwiICtcbiAgICAgICAgICAgIChcImFuZCBzb3VyY2Ugc2l6ZSBcIiArIHNvdXJjZVNpemUgKyBcIiB3b3VsZCBvdmVyZmxvdyBzb3VyY2UgTkRBcnJheVwiKSArXG4gICAgICAgICAgICAoXCJvZiBzaGFwZSBcIiArIHNvdXJjZS5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRlc3RCZWdpblswXSArIGRlc3RTaXplWzBdIDw9IGRlc3Quc2hhcGVbMF0gJiZcbiAgICAgICAgICAgIGRlc3RCZWdpblsxXSArIGRlc3RTaXplWzFdIDw9IGRlc3Quc2hhcGVbMV0sIFwiRXJyb3IgaW4gY29weTJEOiByZXF1ZXN0ZWQgZGVzdCBzdGFydCBwb3NpdGlvbiBcIiArIGRlc3RCZWdpbiArIFwiIFwiICtcbiAgICAgICAgICAgIChcImFuZCBzb3VyY2Ugc2l6ZSBcIiArIGRlc3RTaXplICsgXCIgd291bGQgb3ZlcmZsb3cgZGVzdCBOREFycmF5IG9mXCIpICtcbiAgICAgICAgICAgIChcInNoYXBlIFwiICsgZGVzdC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIGNvcHkyZF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemUsIGRlc3RTaXplKTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3AoJ2NvcHkyRCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvcHkyREludGVybmFsKHNvdXJjZSwgc291cmNlQmVnaW4sIHNvdXJjZVNpemUsIGRlc3QsIGRlc3RCZWdpbiwgZGVzdFNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDFEID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbmNhdDFEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29uY2F0MURJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29uY2F0MkQgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0MkQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQyREludGVybmFsKGEsIGIsIGF4aXMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQzRCA9IGZ1bmN0aW9uIChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKG5kYXJyYXkxLnNoYXBlLCBuZGFycmF5Mi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0M0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQzREludGVybmFsKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDREID0gZnVuY3Rpb24gKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMobmRhcnJheTEuc2hhcGUsIG5kYXJyYXkyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb25jYXQ0RCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbmNhdDRESW50ZXJuYWwobmRhcnJheTEsIG5kYXJyYXkyLCBheGlzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubG9nU3VtRXhwID0gZnVuY3Rpb24gKGlucHV0LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2xvZ1N1bUV4cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4TWF4ID0gX3RoaXMubWF4KGlucHV0LCBheGVzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBhID0gX3RoaXMuc3VidHJhY3QoaW5wdXQsIHhNYXgpO1xuICAgICAgICAgICAgdmFyIGIgPSBfdGhpcy5leHAoYSk7XG4gICAgICAgICAgICB2YXIgYyA9IF90aGlzLnN1bShiLCBheGVzKTtcbiAgICAgICAgICAgIHZhciBkID0gX3RoaXMubG9nKGMpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLmFkZCh4TWF4LnJlc2hhcGUoZC5zaGFwZSksIGQpO1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3N1bScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX3RoaXMudHJhbnNwb3NlKGlucHV0LCBwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuc3VtSW50ZXJuYWwoaW5wdXQsIGF4ZXMpO1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tZWFuID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHNoYXBlcyA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpO1xuICAgICAgICB2YXIgcmVkdWNlU2hhcGUgPSBzaGFwZXNbMV07XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtZWFuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNjb3BlKGZ1bmN0aW9uIChrZWVwLCB0cmFjaykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5kaXZpZGUoeCwgdHJhY2sobmRhcnJheV8xLlNjYWxhci5uZXcocmVkdWNlU2l6ZSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3VtKHJlcywgYXhpcywga2VlcERpbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRQZXJtdXRlZEF4ZXMoYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXJnTWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy50cmFuc3Bvc2UoaW5wdXQsIHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcmdNaW5JbnRlcm5hbChpbnB1dCwgYXhlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRQZXJtdXRlZEF4ZXMoYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXJnTWF4JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy50cmFuc3Bvc2UoaW5wdXQsIHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcmdNYXhJbnRlcm5hbChpbnB1dCwgYXhlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFyZ01heEVxdWFscyA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh4MS5zaGFwZSwgeDIuc2hhcGUsICdFcnJvciBpbiBhcmdNYXhFcXVhbHM6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FyZ01heEVxdWFscycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lcXVhbChfdGhpcy5hcmdNYXgoeDEpLCBfdGhpcy5hcmdNYXgoeDIpKTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdlcXVhbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmVxdWFsSW50ZXJuYWwoeCwgeSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh4LnNoYXBlLCB5LnNoYXBlLCAnRXJyb3IgaW4gZXF1YWxTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbCh4LCB5KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50b3BLID0gZnVuY3Rpb24gKG5kYXJyYXksIGspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoayA8PSBuZGFycmF5LnNpemUsIFwiRXJyb3IgaW4gdG9wSzogayB2YWx1ZSAoXCIgKyBrICsgXCIpIG11c3QgYmUgbGVzcyB0aGFuIHNpemUgb2YgaW5wdXQgXCIgK1xuICAgICAgICAgICAgKFwibmRhcnJheSwgZ290IHNoYXBlIFwiICsgbmRhcnJheS5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wKCd0b3BLJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gX3RoaXMudG9wS0ludGVybmFsKG5kYXJyYXksIGspO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrKHJlc3VsdC5pbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb3JpZ0F4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldFBlcm11dGVkQXhlcyhheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnRyYW5zcG9zZShpbnB1dCwgcGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLm1pbkludGVybmFsKGlucHV0LCBheGVzKTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGlucHV0LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9yaWdBeGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRQZXJtdXRlZEF4ZXMoYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWF4JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy50cmFuc3Bvc2UoaW5wdXQsIHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5tYXhJbnRlcm5hbChpbnB1dCwgYXhlcyk7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNvZnRtYXggPSBmdW5jdGlvbiAobG9naXRzLCBkaW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIGlmIChkaW0gPT09IC0xKSB7XG4gICAgICAgICAgICBkaW0gPSBsb2dpdHMucmFuayAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSAhPT0gbG9naXRzLnJhbmsgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gJyArXG4gICAgICAgICAgICAgICAgKFwiTG9naXRzIHdhcyByYW5rIFwiICsgbG9naXRzLnJhbmsgKyBcIiBhbmQgZGltIHdhcyBcIiArIGRpbSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc29mdG1heCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxzZSA9IF90aGlzLmxvZ1N1bUV4cChsb2dpdHMsIFtkaW1dLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9nUmVzdWx0ID0gX3RoaXMuc3VidHJhY3QobG9naXRzLCBsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHAobG9nUmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zd2l0Y2hEaW0gPSBmdW5jdGlvbiAoYSwgbmV3RGltKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9zZShhLCBuZXdEaW0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRpbGUgPSBmdW5jdGlvbiAoYSwgcmVwcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChhLnJhbmsgPT09IHJlcHMubGVuZ3RoLCBcIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIiArIGEucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggbGVuZ3RoIG9mIHJlcHMgXCIgKyByZXBzICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCd0aWxlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGlsZUludGVybmFsKGEsIHJlcHMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoYSwgcGVybSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocGVybSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwZXJtID0gYS5zaGFwZS5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIGk7IH0pLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChhLnJhbmsgPT09IHBlcm0ubGVuZ3RoLCBcIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIiArIGEucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIgKyBwZXJtICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCd0cmFuc3Bvc2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50cmFuc3Bvc2VJbnRlcm5hbChhLCBwZXJtKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyUGx1c0FycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhclBsdXNBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJNaW51c0FycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhck1pbnVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcnJheU1pbnVzU2NhbGFyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5TWludXNTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYSwgYyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCduZWcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5uZWdJbnRlcm5hbChhKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYWRkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWRkSW50ZXJuYWwoYSwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFkZFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGFkZFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3N1YnRyYWN0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3VidHJhY3RJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3ViU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gc3ViU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtdWx0aXBseScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm11bHRpcGx5SW50ZXJuYWwoYSwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVsZW1lbnRXaXNlTXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTdHJpY3QoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubXVsdGlwbHlTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtdWx0aXBseVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2RpdmlkZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRpdmlkZUludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXZpZGVTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBkaXZpZGVTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGUoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyRGl2aWRlZEJ5QXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyRGl2aWRlZEJ5QXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IE5EQXJyYXkgb2YgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcnJheURpdmlkZWRCeVNjYWxhciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IE5EQXJyYXkgb2YgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShhLCBjKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjZWlsJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2VpbEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZmxvb3InLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5mbG9vckludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2V4cCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV4cEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2xvZycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxvZ0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzcXJ0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3FydEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NxdWFyZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNxdWFyZUludGVybmFsKHgpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FicycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFic0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKG5kYXJyYXksIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KChtaW4gPD0gbWF4KSwgXCJFcnJvciBpbiBjbGlwOiBtaW4gKFwiICsgbWluICsgXCIpIG11c3QgYmVcIiArXG4gICAgICAgICAgICAoXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIiArIG1heCArIFwiKS5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NsaXAnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbGlwSW50ZXJuYWwobmRhcnJheSwgbWluLCBtYXgpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdyZWx1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVsdUludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbHUgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2VsdScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmVsdUludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAobmRhcnJheSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjI7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdsZWFreVJlbHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sZWFreVJlbHVJbnRlcm5hbChuZGFycmF5LCBhbHBoYSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NpZ21vaWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaWdtb2lkSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2luJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2luSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29zJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29zSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgndGFuJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGFuSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FzaW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hc2luSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2Fjb3MnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hY29zSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2F0YW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hdGFuSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNpbmggPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NpbmgnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaW5oSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2Nvc2gnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb3NoSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3RhbmgnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50YW5oSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAobmRhcnJheSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdGVwJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RlcEludGVybmFsKG5kYXJyYXksIGFscGhhKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGQgPSBmdW5jdGlvbiAoYzEsIGEsIGMyLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMxLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6IGZpcnN0IGFyZ3VtZW50IG11c3QgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcIiByYW5rIFwiICsgYzEucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMyLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcIk5EQXJyYXkgb2YgcmFuayBcIiArIGMyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2NhbGVkQXJyYXlBZGQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2FsZWRBcnJheUFkZEludGVybmFsKGMxLCBhLCBjMiwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhclRpbWVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbGVtZW50V2lzZU11bEJyb2FkY2FzdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gMiwgXCJFcnJvciBpbiBlbGVtZW50V2lzZU11bEJyb2FkY2FzdDogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIDIsIGJ1dCBnb3QgcmFuayBcIiArIGEucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGIucmFuayA9PT0gMiwgXCJFcnJvciBpbiBlbGVtZW50V2lzZU11bEJyb2FkY2FzdDogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgXCIgK1xuICAgICAgICAgICAgKFwicmFuayAyLCBidXQgZ290IHJhbmsgXCIgKyBiLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBiaWFzLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYyZDogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGJpYXMucmFuayA9PT0gMSwgXCJFcnJvciBpbiBjb252MmQ6IGJpYXMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAgICAgKGJpYXMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5zaGFwZVsyXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiICsgeC5zaGFwZVsyXSArIFwiKSBtdXN0IG1hdGNoICBcIiArXG4gICAgICAgICAgICAoXCJpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXIuc2hhcGVbM107XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2FbMF0sIHN0cmlkZVdpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb252MmQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252MmRJbnRlcm5hbCh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkQmFja1Byb3AgPSBmdW5jdGlvbiAoeCwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBkdyA9IHRoaXMuY29udjJkRGVyRmlsdGVyKHgsIGR5LCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciBkYiA9IHRoaXMuY29udjJkRGVyQmlhcyhkeSk7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuY29udjJkRGVySW5wdXQoeC5zaGFwZSwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgcmV0dXJuIHsgZGI6IGRiLCBkdzogZHcsIGR4OiBkeCB9O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGluU2hhcGUsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW5EZXB0aCA9IGluU2hhcGVbMl07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGR5LnNoYXBlWzJdO1xuICAgICAgICB1dGlsLmFzc2VydChpblNoYXBlLmxlbmd0aCA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChpblNoYXBlLmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayAzLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBkeS5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGZpbHRlci5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluRGVwdGggPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiICsgaW5EZXB0aCArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChvdXREZXB0aCA9PT0gZmlsdGVyLnNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiICsgb3V0RGVwdGggKyBcIikgbXVzdFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzNdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9hWzBdLCBzdHJpZGVXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oaW5TaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29udjJkRGVySW5wdXQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252MmREZXJJbnB1dEludGVybmFsKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkRGVyQmlhcyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmNvbnYyZERlckJpYXNJbnRlcm5hbChkeSkpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKHguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKGR5LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyU2l6ZS5sZW5ndGggPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaXplIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKGZpbHRlclNpemUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnNoYXBlWzJdID09PSBmaWx0ZXJTaXplWzJdLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgeCBcIiArIHguc2hhcGVbMl0gKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiICsgZmlsdGVyU2l6ZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnNoYXBlWzJdID09PSBmaWx0ZXJTaXplWzNdLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiICsgZHkuc2hhcGVbMl0gKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIgKyBmaWx0ZXJTaXplWzNdICsgXCIpLlwiKSk7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXJTaXplWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXJTaXplWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXJTaXplWzNdO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9hWzBdLCBzdHJpZGVXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuY29udjJkRGVyRmlsdGVySW50ZXJuYWwoeCwgZHksIGNvbnZJbmZvKSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252MmREZXJJbnB1dChvdXRwdXRTaGFwZSwgeCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIHJhdGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyYXRlcyA9PT0gdm9pZCAwKSB7IHJhdGVzID0gWzEsIDFdOyB9XG4gICAgICAgIHZhciBpbnB1dDREID0gaW5wdXQ7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlucHV0LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBpbnB1dDREID0gaW5wdXQuYXM0RCgxLCBpbnB1dC5zaGFwZVswXSwgaW5wdXQuc2hhcGVbMV0sIGlucHV0LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChpbnB1dDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJEOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgaW5wdXQ0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJEOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dDRELnNoYXBlWzNdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJEOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgaW5wdXQ0RC5zaGFwZVszXSArIFwiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBcIikgK1xuICAgICAgICAgICAgKFwiZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgcmF0ZXMgPSByYXRlcyB8fCBbMSwgMV07XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShyYXRlcyksIHJhdGVIZWlnaHQgPSBfYVswXSwgcmF0ZVdpZHRoID0gX2FbMV07XG4gICAgICAgIHV0aWwuYXNzZXJ0KHJhdGVIZWlnaHQgPT09IDEgJiYgcmF0ZVdpZHRoID09PSAxLCAnRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJEOiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCAnICtcbiAgICAgICAgICAgIChcInN1cHBvcnRlZC4gR290IHJhdGVzICdcIiArIHJhdGVzICsgXCInXCIpKTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVEZXB0aHdpc2VDb252MkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdkZXB0aHdpc2VDb252MkQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuZGVwdGh3aXNlQ29udjJESW50ZXJuYWwoaW5wdXQ0RCwgZmlsdGVyLCBjb252SW5mbyk7XG4gICAgICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIG1heFBvb2w6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oZmlsdGVyU2l6ZSksIGZpbHRlckhlaWdodCA9IF9hWzBdLCBmaWx0ZXJXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9iWzBdLCBzdHJpZGVXaWR0aCA9IF9iWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWF4UG9vbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1heFBvb2xJbnRlcm5hbCh4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21heFBvb2xCYWNrcHJvcCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1heFBvb2xCYWNrcHJvcEludGVybmFsKGR5LCB4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1pblBvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBtaW5Qb29sOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21pblBvb2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5taW5Qb29sSW50ZXJuYWwoeCwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhdmdQb29sJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXZnUG9vbEludGVybmFsKHgsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzRCA9IGZ1bmN0aW9uICh4LCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobmV3U2hhcGUyRC5sZW5ndGggPT09IDIsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXIzRDogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKG5ld1NoYXBlMkQgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3Jlc2l6ZUJpbGluZWFyM0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZXNpemVCaWxpbmVhcjNESW50ZXJuYWwoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uMkQgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDIgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBtZWFuIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSAyIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDIgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogc2NhbGUgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSAyIHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdiYXRjaE5vcm0yRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJhdGNoTm9ybWFsaXphdGlvbjJESW50ZXJuYWwoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjNEID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PT0gdm9pZCAwKSB7IHZhcmlhbmNlRXBzaWxvbiA9IC4wMDE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWVhbi5yYW5rID09PSAzIHx8IG1lYW4ucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgbWVhbi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFyaWFuY2UucmFuayA9PT0gMyB8fCB2YXJpYW5jZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgdmFyaWFuY2UucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChzY2FsZS5yYW5rID09PSAzIHx8IHNjYWxlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgc2NhbGUucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChvZmZzZXQucmFuayA9PT0gMyB8fCBvZmZzZXQucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgb2Zmc2V0LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYmF0Y2hOb3JtM0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5iYXRjaE5vcm1hbGl6YXRpb24zREludGVybmFsKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aVJOTkNlbGwgPSBmdW5jdGlvbiAobHN0bUNlbGxzLCBkYXRhLCBjLCBoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRhdGE7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdG1DZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBsc3RtQ2VsbHNbaV0oaW5wdXQsIGNbaV0sIGhbaV0pO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFswXSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzFdKTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG91dHB1dFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmV3QyA9IFtdO1xuICAgICAgICB2YXIgbmV3SCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbmV3Qy5wdXNoKHJlc1tpXSk7XG4gICAgICAgICAgICBuZXdILnB1c2gocmVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5iYXNpY0xTVE1DZWxsID0gZnVuY3Rpb24gKGZvcmdldEJpYXMsIGxzdG1LZXJuZWwsIGxzdG1CaWFzLCBkYXRhLCBjLCBoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZCA9IF90aGlzLmNvbmNhdDJEKGRhdGEsIGgsIDEpO1xuICAgICAgICAgICAgdmFyIHdlaWdodGVkID0gX3RoaXMubWF0TXVsKGNvbWJpbmVkLCBsc3RtS2VybmVsKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5hZGQod2VpZ2h0ZWQsIGxzdG1CaWFzKTtcbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSByZXMuc2hhcGVbMF07XG4gICAgICAgICAgICB2YXIgc2xpY2VDb2xzID0gcmVzLnNoYXBlWzFdIC8gNDtcbiAgICAgICAgICAgIHZhciBzbGljZVNpemUgPSBbYmF0Y2hTaXplLCBzbGljZUNvbHNdO1xuICAgICAgICAgICAgdmFyIGkgPSBfdGhpcy5zbGljZTJEKHJlcywgWzAsIDBdLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIGogPSBfdGhpcy5zbGljZTJEKHJlcywgWzAsIHNsaWNlQ29sc10sIHNsaWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgZiA9IF90aGlzLnNsaWNlMkQocmVzLCBbMCwgc2xpY2VDb2xzICogMl0sIHNsaWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgbyA9IF90aGlzLnNsaWNlMkQocmVzLCBbMCwgc2xpY2VDb2xzICogM10sIHNsaWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgbmV3QyA9IF90aGlzLmFkZFN0cmljdChfdGhpcy5tdWx0aXBseVN0cmljdChjLCBfdGhpcy5zaWdtb2lkKF90aGlzLnNjYWxhclBsdXNBcnJheShmb3JnZXRCaWFzLCBmKSkpLCBfdGhpcy5tdWx0aXBseVN0cmljdChfdGhpcy5zaWdtb2lkKGkpLCBfdGhpcy50YW5oKGopKSk7XG4gICAgICAgICAgICB2YXIgbmV3SCA9IF90aGlzLm11bHRpcGx5U3RyaWN0KF90aGlzLnRhbmgobmV3QyksIF90aGlzLnNpZ21vaWQobykpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbcmVzWzBdLCByZXNbMV1dO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpbm9taWFsID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG51bU91dGNvbWVzID0gcHJvYmFiaWxpdGllcy5zaXplO1xuICAgICAgICBpZiAobnVtT3V0Y29tZXMgPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAgICAgKG51bU91dGNvbWVzICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvYmFiaWxpdGllcy5yYW5rID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIgKyBwcm9iYWJpbGl0aWVzLnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHZhciBvcmlnUmFuayA9IHByb2JhYmlsaXRpZXMucmFuaztcbiAgICAgICAgaWYgKHByb2JhYmlsaXRpZXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcHJvYmFiaWxpdGllcyA9IHByb2JhYmlsaXRpZXMuYXMyRCgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtdWx0aW5vbWlhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5tdWx0aW5vbWlhbEludGVybmFsKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpO1xuICAgICAgICAgICAgaWYgKG9yaWdSYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5hczFEKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5vbmVIb3QgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvblZhbHVlID09PSB2b2lkIDApIHsgb25WYWx1ZSA9IDE7IH1cbiAgICAgICAgaWYgKG9mZlZhbHVlID09PSB2b2lkIDApIHsgb2ZmVmFsdWUgPSAwOyB9XG4gICAgICAgIGlmIChkZXB0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG9uZUhvdDogZGVwdGggbXVzdCBiZSA+PTIsIGJ1dCBpdCBpcyBcIiArIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ29uZUhvdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uZUhvdEludGVybmFsKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1vbWVudHMgPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVhbiA9IF90aGlzLm1lYW4oeCwgYXhlcywga2VlcERpbXMpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zU2hhcGUgPSBtZWFuLnNoYXBlO1xuICAgICAgICAgICAgaWYgKCFrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIGtlZXBEaW1zU2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obWVhbi5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGV2U3F1YXJlZCA9IF90aGlzLnNxdWFyZShfdGhpcy5zdWJ0cmFjdCh4LCBtZWFuLnJlc2hhcGUoa2VlcERpbXNTaGFwZSkpKTtcbiAgICAgICAgICAgIHZhciB2YXJpYW5jZSA9IF90aGlzLm1lYW4oZGV2U3F1YXJlZCwgYXhlcywga2VlcERpbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVhbjogbWVhbiwgdmFyaWFuY2U6IHZhcmlhbmNlIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoO1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGggPSBOREFycmF5TWF0aDtcbnZhciBNYXRyaXhPcmllbnRhdGlvbjtcbihmdW5jdGlvbiAoTWF0cml4T3JpZW50YXRpb24pIHtcbiAgICBNYXRyaXhPcmllbnRhdGlvbltNYXRyaXhPcmllbnRhdGlvbltcIlJFR1VMQVJcIl0gPSAwXSA9IFwiUkVHVUxBUlwiO1xuICAgIE1hdHJpeE9yaWVudGF0aW9uW01hdHJpeE9yaWVudGF0aW9uW1wiVFJBTlNQT1NFRFwiXSA9IDFdID0gXCJUUkFOU1BPU0VEXCI7XG59KShNYXRyaXhPcmllbnRhdGlvbiA9IGV4cG9ydHMuTWF0cml4T3JpZW50YXRpb24gfHwgKGV4cG9ydHMuTWF0cml4T3JpZW50YXRpb24gPSB7fSkpO1xuZnVuY3Rpb24gcGFyc2VUdXBsZVBhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgPyBbcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi9jb25jYXRfdXRpbFwiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9jb252X3V0aWxcIik7XG52YXIgY29weTJEX3V0aWwgPSByZXF1aXJlKFwiLi9jb3B5MmRfdXRpbFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgTkRBcnJheU1hdGhDUFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOREFycmF5TWF0aENQVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOREFycmF5TWF0aENQVShzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzYWZlTW9kZSkgfHwgdGhpcztcbiAgICB9XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNsb25lSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LmdldFZhbHVlcygpKSB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zbGljZTFESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBuZXdWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCkuc2xpY2UoYmVnaW4sIGJlZ2luICsgc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkxRC5uZXcobmV3VmFscyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2UyREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5MkQuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0Sik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWwsIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2UzREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV0sIHN0YXJ0SyA9IGJlZ2luWzJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXQuZ2V0KGkgKyBzdGFydEksIGogKyBzdGFydEosIGsgKyBzdGFydEspO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2U0REludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV0sIHN0YXJ0SyA9IGJlZ2luWzJdLCBzdGFydEwgPSBiZWdpblszXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzaXplWzNdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0SiwgayArIHN0YXJ0SywgbCArIHN0YXJ0TCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgaywgbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb3B5MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZUJlZ2luUm93Q29sLCBzb3VyY2VTaXplUm93Q29sLCBkZXN0LCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKSB7XG4gICAgICAgIGNvcHkyRF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemVSb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgICAgICAgdmFyIHNyY1ZhbHVlcyA9IHNvdXJjZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGRzdFZhbHVlcyA9IGRlc3QuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuID0gc291cmNlU2l6ZVJvd0NvbFswXSAqIHNvdXJjZVNpemVSb3dDb2xbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3JjUm93ID0gc291cmNlQmVnaW5Sb3dDb2xbMF0gKyBNYXRoLmZsb29yKGkgLyBzb3VyY2VTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBzcmNDb2wgPSBzb3VyY2VCZWdpblJvd0NvbFsxXSArIChpICUgc291cmNlU2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgICAgICB2YXIgc3JjT2ZmID0gc3JjUm93ICogc291cmNlLnNoYXBlWzFdICsgc3JjQ29sO1xuICAgICAgICAgICAgdmFyIGRzdFJvdyA9IGRlc3RCZWdpblJvd0NvbFswXSArIE1hdGguZmxvb3IoaSAvIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBkc3RDb2wgPSBkZXN0QmVnaW5Sb3dDb2xbMV0gKyAoaSAlIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBkc3RPZmYgPSBkc3RSb3cgKiBkZXN0LnNoYXBlWzFdICsgZHN0Q29sO1xuICAgICAgICAgICAgZHN0VmFsdWVzW2RzdE9mZl0gPSBzcmNWYWx1ZXNbc3JjT2ZmXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDFESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgMCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkxRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIHZhciBhVmFscyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDJESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkyRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRTaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gW2ksIGpdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCBhLnNoYXBlW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYS5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFtheGlzXSAtPSBhLnNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTIgPSBpbmRleFswXSwgajIgPSBpbmRleFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiLmdldChpMiwgajIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbHVlLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDNESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRTaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXRTaGFwZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtpLCBqLCBrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCBhLnNoYXBlW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGEuZ2V0KGksIGosIGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhbYXhpc10gLT0gYS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpMiA9IGluZGV4WzBdLCBqMiA9IGluZGV4WzFdLCBrMiA9IGluZGV4WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiLmdldChpMiwgajIsIGsyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbHVlLCBpLCBqLCBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb25jYXQ0REludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFWYWxzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFNoYXBlWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0U2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0U2hhcGVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG91dFNoYXBlWzNdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtpLCBqLCBrLCBsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFtheGlzXSA8IGEuc2hhcGVbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGEuZ2V0KGksIGosIGssIGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhbYXhpc10gLT0gYS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTIgPSBpbmRleFswXSwgajIgPSBpbmRleFsxXSwgazIgPSBpbmRleFsyXSwgbDIgPSBpbmRleFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGIuZ2V0KGkyLCBqMiwgazIsIGwyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGksIGosIGssIGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIGMxVmFsID0gYzEuZ2V0KCk7XG4gICAgICAgIHZhciBjMlZhbCA9IGMyLmdldCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdmbG9hdDMyJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjMVZhbCAqIGFWYWwgKyBjMlZhbCAqIGJWYWw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm5lZ0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyVGltZXNBcnJheShuZGFycmF5XzEuU2NhbGFyLk5FR19PTkUsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFkZEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbChuZGFycmF5XzEuU2NhbGFyLk9ORSwgYSwgbmRhcnJheV8xLlNjYWxhci5PTkUsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnN1YnRyYWN0SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZWRBcnJheUFkZEludGVybmFsKG5kYXJyYXlfMS5TY2FsYXIuT05FLCBhLCBuZGFycmF5XzEuU2NhbGFyLk5FR19PTkUsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1hdE11bEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChhT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBhT3JpZW50YXRpb24gPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYk9yaWVudGF0aW9uID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgdmFyIHNoYXJlZERpbSA9IChhT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMV0gOiBhLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbGVmdERpbSA9IChhT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMF0gOiBhLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcmlnaHREaW0gPSAoYk9yaWVudGF0aW9uID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiLnNoYXBlWzFdIDogYi5zaGFwZVswXTtcbiAgICAgICAgdmFyIG5vcm1hbEdldHRlciA9IGZ1bmN0aW9uIChtYXRyaXgsIGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXguZ2V0KGksIGopO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHJhbnNwb3NlZEdldHRlciA9IGZ1bmN0aW9uIChtYXRyaXgsIGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXguZ2V0KGosIGkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYUdldHRlciA9IChhT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICBub3JtYWxHZXR0ZXIgOlxuICAgICAgICAgICAgdHJhbnNwb3NlZEdldHRlcjtcbiAgICAgICAgdmFyIGJHZXR0ZXIgPSAoYk9yaWVudGF0aW9uID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgICAgIHRyYW5zcG9zZWRHZXR0ZXI7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGxlZnREaW0gKiByaWdodERpbSk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdERpbTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpZ2h0RGltOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXJlZERpbTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBhR2V0dGVyKGEsIGksIGspICogYkdldHRlcihiLCBrLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4KytdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoW2xlZnREaW0sIHJpZ2h0RGltXSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tdWx0aXBseUludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSkpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGFWYWx1ZXNbaSAlIGEuc2l6ZV0gKiBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmRpdmlkZUludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSkpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGFWYWx1ZXNbaSAlIGEuc2l6ZV0gLyBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0sICdmbG9hdDMyJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3VtSW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0RHR5cGUgPSBtYXRoXzEuU3VtVHlwZXNNYXBbaW5wdXQuZHR5cGVdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mob3V0U2hhcGUsIHJlc3VsdER0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBzdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hcmdNaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01pbicsIGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhvdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5JbmRleCA9IHV0aWwuTkFOX0lOVDMyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1pbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXJnTWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWF4ID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtYXhJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmVxdWFsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVZhbCA9PT0gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudG9wS0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGspIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YWx1ZXNBbmRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnB1c2goeyB2YWx1ZTogdmFsdWVzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3BrVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrKTtcbiAgICAgICAgdmFyIHRvcGtJbmRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShrKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgIHRvcGtWYWx1ZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLnZhbHVlO1xuICAgICAgICAgICAgdG9wa0luZGljZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlczogbmRhcnJheV8xLkFycmF5MUQubmV3KHRvcGtWYWx1ZXMpLCBpbmRpY2VzOiBuZGFycmF5XzEuQXJyYXkxRC5uZXcodG9wa0luZGljZXMpIH07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWluSW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtaW4nLCBheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mob3V0U2hhcGUsIGlucHV0LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1pbiA9IGFWYWxzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE51bWJlci5OYU47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heEludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWF4JywgYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG91dFNoYXBlLCBpbnB1dC5kdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtYXggPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE51bWJlci5OYU47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNlaWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguY2VpbCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZmxvb3JJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZmxvb3IodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmV4cEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5leHAodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmxvZ0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5sb2codmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3FydEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNxdWFyZUludGVybmFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gdmFsdWUgKiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnJlbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgcmVzID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3MoaW5wdXQuc2hhcGUsIGlucHV0LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBpblZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpblZhbHNbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWwsIGlucHV0LmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc1ZhbHNbaV0gPSB1dGlsLmdldE5hTihyZXMuZHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tpXSA9IE1hdGgubWF4KDAsIGluVmFsc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5lbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gKE1hdGguZXhwKHYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5sZWFreVJlbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5LCBhbHBoYSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IGFscGhhICogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNsaXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5LCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFic0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFicyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2lnbW9pZEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5zaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvc0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmNvcyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgudGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXNpbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYWNvc0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFjb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmF0YW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hdGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zaW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29zaEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmNvc2godmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRhbmhJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC50YW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zdGVwSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwOyB9XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdmFsdWUgPiAwID8gMSA6ICh2YWx1ZSA8IDAgPyBhbHBoYSA6IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbnYyZEludGVybmFsID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgYmlhcywgY29udkluZm8pIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgeFJvd3MgPSBfYVswXSwgeENvbHMgPSBfYVsxXSwgaW5wdXREZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyLnNoYXBlWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXIuc2hhcGVbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGZpbHRlci5zaGFwZVszXTtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHkgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhjb252SW5mby5vdXRTaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXREZXB0aDsgKytkMikge1xuICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IHkuc2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBjb252SW5mby5zdHJpZGVXaWR0aCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbih4Q29scywgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbnB1dERlcHRoOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldCh3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzVmFsID0gKGJpYXMgIT0gbnVsbCkgPyBiaWFzLmdldChkMikgOiAwO1xuICAgICAgICAgICAgICAgICAgICB5LnNldChkb3RQcm9kICsgYmlhc1ZhbCwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbnYyZERlcklucHV0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGluRGVwdGggPSBmaWx0ZXIuc2hhcGVbMl07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGZpbHRlci5zaGFwZVszXTtcbiAgICAgICAgdmFyIHlSb3dzID0gZHkuc2hhcGVbMF07XG4gICAgICAgIHZhciB5Q29scyA9IGR5LnNoYXBlWzFdO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyLnNoYXBlWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXIuc2hhcGVbMV07XG4gICAgICAgIHZhciB0b3BQYWQgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGR4ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoY29udkluZm8uaW5TaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbkRlcHRoOyArK2QxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgZHguc2hhcGVbMF07ICsreFIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB4UiAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhSQ29ybmVyIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4oeVJvd3MsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0gMDsgeEMgPCBkeC5zaGFwZVsxXTsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB4QyAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhDQ29ybmVyIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oeUNvbHMsIChmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB4Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHkuZ2V0KHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldChmaWx0ZXJIZWlnaHQgLSAxIC0gd1IsIGZpbHRlcldpZHRoIC0gMSAtIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXJJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBkWSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGlucHV0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgICAgICB2YXIgb3V0cHV0RGVwdGggPSBkWS5zaGFwZVsyXTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgd2VpZ2h0c1NoYXBlID0gY29udl91dGlsLmNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCk7XG4gICAgICAgIHZhciBkVyA9IG5kYXJyYXlfMS5BcnJheTRELnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgICAgIHZhciB5TnVtUm93cyA9IGRZLnNoYXBlWzBdO1xuICAgICAgICB2YXIgeU51bUNvbHMgPSBkWS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0geC5zaGFwZVswXTtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0geC5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGxlZnRQYWQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciB0b3BQYWQgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgdmFyIHlSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh0b3BQYWQgLSB3UikgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKHlOdW1Sb3dzLCAoeE51bVJvd3MgKyB0b3BQYWQgLSB3UikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZWZ0UGFkIC0gd0MpIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2YXIgeUNNYXggPSBNYXRoLm1pbih5TnVtQ29scywgKHhOdW1Db2xzICsgbGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5wdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0cHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geVJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB3UiArIHlSICogc3RyaWRlSGVpZ2h0IC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geUNNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDID0gd0MgKyB5QyAqIHN0cmlkZVdpZHRoIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4LmdldCh4UiwgeEMsIGQxKSAqIGRZLmdldCh5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkVy5zZXQoZG90UHJvZCwgd1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkVztcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmREZXJCaWFzSW50ZXJuYWwgPSBmdW5jdGlvbiAoZFkpIHtcbiAgICAgICAgdmFyIG91dHB1dERlcHRoID0gZFkuc2hhcGVbMl07XG4gICAgICAgIHZhciBudW1Sb3dzID0gZFkuc2hhcGVbMF07XG4gICAgICAgIHZhciBudW1Db2xzID0gZFkuc2hhcGVbMV07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dERlcHRoKTtcbiAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dHB1dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbnVtUm93czsgKytyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1Db2xzOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGRZLmdldChyLCBjLCBkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW2QyXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5MUQubmV3KHZhbHVlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8uaW5TaGFwZSwgbnVtQmF0Y2hlcyA9IF9hWzBdLCB4Um93cyA9IF9hWzFdLCB4Q29scyA9IF9hWzJdLCBpbkNoYW5uZWxzID0gX2FbM107XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgeVJvd3MgPSBjb252SW5mby5vdXRTaGFwZVsxXTtcbiAgICAgICAgdmFyIHlDb2xzID0gY29udkluZm8ub3V0U2hhcGVbMl07XG4gICAgICAgIHZhciBjaE11bCA9IGNvbnZJbmZvLmNoYW5uZWxNdWw7XG4gICAgICAgIHZhciB5ID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG51bUJhdGNoZXM7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgeVJvd3M7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBjb252SW5mby5zdHJpZGVIZWlnaHQgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCB5Q29sczsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBjb252SW5mby5zdHJpZGVXaWR0aCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY2hNdWw7ICsrcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbnB1dC5nZXQoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldCh3Uiwgd0MsIGQxLCBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCwgYiwgeVIsIHlDLCBkMSAqIGNoTXVsICsgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudGlsZUludGVybmFsID0gZnVuY3Rpb24gKGEsIHJlcHMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KGEucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0gYS5zaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlO1xuICAgICAgICBpZiAoYS5kdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICBkdHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICBkdHlwZSA9IEludDMyQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICBkdHlwZSA9IFVpbnQ4QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdHlwZSBcIiArIGEuZHR5cGUgKyBcIiBub3Qgc3VwcG9ydGVkIGZvciB0aWxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgZHR5cGUodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0sIGEuZHR5cGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMb2MgPSBuZXcgQXJyYXkoYS5yYW5rKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG9yaWdpbmFsTG9jLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExvY1tpXzFdID0gbmV3TG9jW2lfMV0gJSBhLnNoYXBlW2lfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IGEubG9jVG9JbmRleChvcmlnaW5hbExvYyk7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50cmFuc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBwZXJtKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IG5ldyBBcnJheShhLnJhbmspO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdTaGFwZVtpXSA9IGEuc2hhcGVbcGVybVtpXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gYS5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IG5ld0xvYy5sZW5ndGg7IGlfMisrKSB7XG4gICAgICAgICAgICAgICAgbmV3TG9jW2lfMl0gPSBsb2NbcGVybVtpXzJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IHJlc3VsdC5sb2NUb0luZGV4KG5ld0xvYyk7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbbmV3SW5kZXhdID0gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUucG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbywgcG9vbFR5cGUpIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgeFJvd3MgPSBfYVswXSwgeENvbHMgPSBfYVsxXSwgZGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgeSA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgeS5zaGFwZVswXTsgKyt5Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogc3RyaWRlV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heFZhbHVlID0gKHBvb2xUeXBlID09PSAnbWF4JyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXZnVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGl4ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmdWYWx1ZSA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocG9vbFR5cGUgPT09ICdtYXgnICYmIHBpeGVsID4gbWluTWF4VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb29sVHlwZSA9PT0gJ21pbicgJiYgcGl4ZWwgPCBtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlICs9IHBpeGVsIC8gKGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeS5zZXQocG9vbFR5cGUgPT09ICdhdmcnID8gYXZnVmFsdWUgOiBtaW5NYXhWYWx1ZSwgeVIsIHlDLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF4UG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdtYXgnKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhQb29sUG9zaXRpb25zID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIHhSb3dzID0gX2FbMF0sIHhDb2xzID0gX2FbMV0sIGRlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3Mob3V0cHV0U2hhcGUpO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IG91dHB1dFNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IG91dHB1dFNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogc3RyaWRlV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zaXRpb24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb24gPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5zZXQobWF4UG9zaXRpb24sIHlSLCB5QywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhQb3NpdGlvbnM7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wSW50ZXJuYWwgPSBmdW5jdGlvbiAoZHksIHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbnMgPSB0aGlzLm1heFBvb2xQb3NpdGlvbnMoeCwgY29udkluZm8pO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgX2EgPSBkeS5zaGFwZSwgZHlSb3dzID0gX2FbMF0sIGR5Q29scyA9IF9hWzFdLCBkZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgZHggPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyh4LnNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkeFIgPSAwOyBkeFIgPCBkeC5zaGFwZVswXTsgKytkeFIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBkeC5zaGFwZVsxXTsgKytkeEMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q0Nvcm5lciA9IGR4QyAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gZHlSb3dzIHx8IE1hdGguZmxvb3IoZHlSKSAhPT0gZHlSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBkeUNvbHMgfHwgTWF0aC5mbG9vcihkeUMpICE9PSBkeUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3MgPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbnMuZ2V0KGR5UiwgZHlDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyUG9zID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gbWF4UG9zID09PSBjdXJQb3MgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHkuZ2V0KGR5UiwgZHlDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogbWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHg7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWluUG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdtaW4nKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hdmdQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ2F2ZycpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyM0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKFtuZXdTaGFwZTJEWzBdLCBuZXdTaGFwZTJEWzFdLCB4LnNoYXBlWzJdXSk7XG4gICAgICAgIHZhciBlZmZlY3RpdmVJbnB1dFNpemUgPSBhbGlnbkNvcm5lcnMgPyBbeC5zaGFwZVswXSAtIDEsIHguc2hhcGVbMV0gLSAxLCB4LnNoYXBlWzJdXSA6IHguc2hhcGU7XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRwdXRTaXplID0gYWxpZ25Db3JuZXJzID9cbiAgICAgICAgICAgIFtvdXRwdXQuc2hhcGVbMF0gLSAxLCBvdXRwdXQuc2hhcGVbMV0gLSAxLCBvdXRwdXQuc2hhcGVbMl1dIDpcbiAgICAgICAgICAgIG91dHB1dC5zaGFwZTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBvdXRwdXQuc2hhcGVbMF07IHIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvdXRwdXQuc2hhcGVbMV07IGMrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgb3V0cHV0LnNoYXBlWzJdOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNSb3cgPSAoZWZmZWN0aXZlSW5wdXRTaXplWzBdKSAqIHIgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjQ29sID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlUm93Rmxvb3IgPSBNYXRoLmZsb29yKHNvdXJjZUZyYWNSb3cpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlUm93Q2VpbCA9IE1hdGgubWluKHguc2hhcGVbMF0gLSAxLCBNYXRoLmNlaWwoc291cmNlRnJhY1JvdykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sRmxvb3IgPSBNYXRoLmZsb29yKHNvdXJjZUZyYWNDb2wpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sQ2VpbCA9IE1hdGgubWluKHguc2hhcGVbMV0gLSAxLCBNYXRoLmNlaWwoc291cmNlRnJhY0NvbCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wTGVmdCA9IHguZ2V0KHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0geC5nZXQoc291cmNlUm93Q2VpbCwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wUmlnaHQgPSB4LmdldChzb3VyY2VSb3dGbG9vciwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21SaWdodCA9IHguZ2V0KHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbEZyYWMgPSBzb3VyY2VGcmFjQ29sIC0gc291cmNlQ29sRmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGNvbEZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b3BfMSArIChib3R0b20gLSB0b3BfMSkgKiByb3dGcmFjO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KG5ld1ZhbHVlLCByLCBjLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24yREludGVybmFsID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHhWYWx1ZXMgPSB4LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbWVhblZhbHVlcyA9IG1lYW4uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YXJpYW5jZVZhbHVlcyA9IHZhcmlhbmNlLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgc2NhbGVWYWx1ZXMgPSBzY2FsZSA/IHNjYWxlLmdldFZhbHVlcygpIDogbmV3IEZsb2F0MzJBcnJheShbMV0pO1xuICAgICAgICB2YXIgb2Zmc2V0VmFsdWVzID0gb2Zmc2V0ID8gb2Zmc2V0LmdldFZhbHVlcygpIDogbmV3IEZsb2F0MzJBcnJheShbMF0pO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4VmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0VmFsdWVzW2ldID0gb2Zmc2V0VmFsdWVzW2kgJSBvZmZzZXRWYWx1ZXMubGVuZ3RoXSArXG4gICAgICAgICAgICAgICAgKHhWYWx1ZXNbaV0gLSBtZWFuVmFsdWVzW2kgJSBtZWFuVmFsdWVzLmxlbmd0aF0pICpcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWYWx1ZXNbaSAlIHNjYWxlVmFsdWVzLmxlbmd0aF0gL1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQodmFyaWFuY2VWYWx1ZXNbaSAlIHZhcmlhbmNlVmFsdWVzLmxlbmd0aF0gKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoeC5zaGFwZSwgb3V0VmFsdWVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24zREludGVybmFsID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHhWYWx1ZXMgPSB4LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbWVhblZhbHVlcyA9IG1lYW4uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YXJpYW5jZVZhbHVlcyA9IHZhcmlhbmNlLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgc2NhbGVWYWx1ZXMgPSBzY2FsZSA/IHNjYWxlLmdldFZhbHVlcygpIDogbmV3IEZsb2F0MzJBcnJheShbMV0pO1xuICAgICAgICB2YXIgb2Zmc2V0VmFsdWVzID0gb2Zmc2V0ID8gb2Zmc2V0LmdldFZhbHVlcygpIDogbmV3IEZsb2F0MzJBcnJheShbMF0pO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4VmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0VmFsdWVzW2ldID0gb2Zmc2V0VmFsdWVzW2kgJSBvZmZzZXRWYWx1ZXMubGVuZ3RoXSArXG4gICAgICAgICAgICAgICAgKHhWYWx1ZXNbaV0gLSBtZWFuVmFsdWVzW2kgJSBtZWFuVmFsdWVzLmxlbmd0aF0pICpcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWYWx1ZXNbaSAlIHNjYWxlVmFsdWVzLmxlbmd0aF0gL1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQodmFyaWFuY2VWYWx1ZXNbaSAlIHZhcmlhbmNlVmFsdWVzLmxlbmd0aF0gKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkzRC5uZXcoeC5zaGFwZSwgb3V0VmFsdWVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tdWx0aW5vbWlhbEludGVybmFsID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JhYmlsaXRpZXMuc2hhcGVbMF07XG4gICAgICAgIHZhciBudW1FdmVudHMgPSBwcm9iYWJpbGl0aWVzLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcmVzID0gbmRhcnJheV8xLkFycmF5MkQuemVyb3MoW2JhdGNoU2l6ZSwgbnVtU2FtcGxlc10sICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVzVmFscyA9IHJlcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHByb2JWYWxzID0gcHJvYmFiaWxpdGllcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGIgKiBudW1FdmVudHM7XG4gICAgICAgICAgICB2YXIgY2RmID0gbmV3IEZsb2F0MzJBcnJheShudW1FdmVudHMgLSAxKTtcbiAgICAgICAgICAgIGNkZlswXSA9IHByb2JWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudF8xID0gMTsgZXZlbnRfMSA8IGNkZi5sZW5ndGg7ICsrZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgIGNkZltldmVudF8xXSA9IGNkZltldmVudF8xIC0gMV0gKyBwcm9iVmFsc1tvZmZzZXQgKyBldmVudF8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBvdXRPZmZzZXQgPSBiICogbnVtU2FtcGxlcztcbiAgICAgICAgICAgIGZvciAodmFyIHNhbXBsZUlkID0gMDsgc2FtcGxlSWQgPCBudW1TYW1wbGVzOyArK3NhbXBsZUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByYW5kb20oKTtcbiAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGNkZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMiA9IDA7IGV2ZW50XzIgPCBjZGYubGVuZ3RoOyBldmVudF8yKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCBjZGZbZXZlbnRfMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ZhbHNbb3V0T2Zmc2V0ICsgc2FtcGxlSWRdID0gZXZlbnRfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUub25lSG90SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMuc2l6ZSAqIGRlcHRoKTtcbiAgICAgICAgcmVzLmZpbGwob2ZmVmFsdWUpO1xuICAgICAgICBmb3IgKHZhciBldmVudF8zID0gMDsgZXZlbnRfMyA8IGluZGljZXMuc2l6ZTsgKytldmVudF8zKSB7XG4gICAgICAgICAgICByZXNbZXZlbnRfMyAqIGRlcHRoICsgaW5kaWNlcy5nZXQoZXZlbnRfMyldID0gb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5MkQubmV3KFtpbmRpY2VzLnNpemUsIGRlcHRoXSwgcmVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wID0gZnVuY3Rpb24gKGEsIGIsIGR0eXBlLCBvcCkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5ld1NoYXBlLCBkdHlwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYUJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGEuc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIGJCcm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhiLnNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBhTG9jID0gbG9jLnNsaWNlKC1hLnJhbmspO1xuICAgICAgICAgICAgYUJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYUxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGFJbmRleCA9IGEubG9jVG9JbmRleChhTG9jKTtcbiAgICAgICAgICAgIHZhciBiTG9jID0gbG9jLnNsaWNlKC1iLnJhbmspO1xuICAgICAgICAgICAgYkJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYkxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGJJbmRleCA9IGIubG9jVG9JbmRleChiTG9jKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IG9wKGFWYWx1ZXNbYUluZGV4XSwgYlZhbHVlc1tiSW5kZXhdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBOREFycmF5TWF0aENQVTtcbn0obWF0aF8xLk5EQXJyYXlNYXRoKSk7XG5leHBvcnRzLk5EQXJyYXlNYXRoQ1BVID0gTkRBcnJheU1hdGhDUFU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoX2NwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbnZhciBuZGFycmF5ID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIHJlZHVjZV91dGlsID0gcmVxdWlyZShcIi4vcmVkdWNlX3V0aWxcIik7XG52YXIgYWRkc2NhbGVkbWF0X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYWRkc2NhbGVkbWF0X2dwdVwiKTtcbnZhciBhcmdtaW5tYXhfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hcmdtaW5tYXhfZ3B1XCIpO1xudmFyIGJhdGNobm9ybV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JhdGNobm9ybV9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1ID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGJpbmFyeW9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGNsaXBfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jbGlwX2dwdVwiKTtcbnZhciBjb25jYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb25jYXRfZ3B1XCIpO1xudmFyIGNvbnZfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2JhY2twcm9wX2dwdVwiKTtcbnZhciBjb252X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9ncHVcIik7XG52YXIgY29udl9ncHVfZGVwdGh3aXNlXzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdV9kZXB0aHdpc2VcIik7XG52YXIgY29weV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvcHlfZ3B1XCIpO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X2NvbnRleHRcIik7XG52YXIgZ3BncHVfbWF0aCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X21hdGhcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG52YXIgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHVcIik7XG52YXIgbXVsbWF0X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbXVsbWF0X2dwdVwiKTtcbnZhciBtdWx0aW5vbWlhbF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bHRpbm9taWFsX2dwdVwiKTtcbnZhciBvbmVob3RfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9vbmVob3RfZ3B1XCIpO1xudmFyIHBvb2xfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9wb29sX2dwdVwiKTtcbnZhciByZWR1Y2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZWR1Y2VfZ3B1XCIpO1xudmFyIHJlc2l6ZV9iaWxpbmVhcl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHVcIik7XG52YXIgc2xpY2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9zbGljZV9ncHVcIik7XG52YXIgdGV4dHVyZV9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi93ZWJnbC90ZXh0dXJlX21hbmFnZXJcIik7XG52YXIgdGlsZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RpbGVfZ3B1XCIpO1xudmFyIHRyYW5zcG9zZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RyYW5zcG9zZV9ncHVcIik7XG52YXIgdW5hcnlfb3AgPSByZXF1aXJlKFwiLi93ZWJnbC91bmFyeW9wX2dwdVwiKTtcbnZhciB1bmFyeW9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdW5hcnlvcF9ncHVcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL3dlYmdsX3V0aWxcIik7XG52YXIgTkRBcnJheU1hdGhHUFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOREFycmF5TWF0aEdQVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOREFycmF5TWF0aEdQVShncGdwdSwgc2FmZU1vZGUpIHtcbiAgICAgICAgaWYgKHNhZmVNb2RlID09PSB2b2lkIDApIHsgc2FmZU1vZGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzYWZlTW9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmluYXJ5Q2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKGdwZ3B1ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IGdwZ3B1X3V0aWwuY3JlYXRlV2ViR0xDb250ZXh0KCk7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdSA9IG5ldyBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0KGdsKTtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuZ3BncHUgPSBncGdwdTtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyB0ZXh0dXJlX21hbmFnZXJfMS5UZXh0dXJlTWFuYWdlcihfdGhpcy5ncGdwdSk7XG4gICAgICAgIG5kYXJyYXkuaW5pdGlhbGl6ZUdQVShfdGhpcy5ncGdwdSwgX3RoaXMudGV4dHVyZU1hbmFnZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5nZXRHUEdQVUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdwZ3B1O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNsb25lSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgdGV4U2hhcGUgPSBhLmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhLmFzMkQodGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHRleFNoYXBlLCBhLmR0eXBlKTtcbiAgICAgICAgdGhpcy5jb3B5MkQoc291cmNlLCBbMCwgMF0sIHRleFNoYXBlLCBvdXRwdXQsIFswLCAwXSwgdGV4U2hhcGUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0LnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2xpY2UxREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oW3NpemVdKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoW2JlZ2luXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2lucHV0XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNsaWNlMkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKHNpemUpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhiZWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2lucHV0XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNsaWNlM0RJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKHNpemUpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhiZWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2lucHV0XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNsaWNlNERJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKHNpemUpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhiZWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2lucHV0XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvcHkyREludGVybmFsID0gZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlQmVnaW5Sb3dDb2wsIHNvdXJjZVNpemVSb3dDb2wsIGRlc3QsIGRlc3RCZWdpblJvd0NvbCwgZGVzdFNpemVSb3dDb2wpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29weV9ncHVfMS5Db3B5MkRQcm9ncmFtKHNvdXJjZVNpemVSb3dDb2xbMV0sIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoc291cmNlQmVnaW5Sb3dDb2wsIGRlc3RCZWdpblJvd0NvbCwgZGVzdFNpemVSb3dDb2wpO1xuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3NvdXJjZV0sIGRlc3QsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb25jYXQxREludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb25jYXQyREludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb25jYXQzREludGVybmFsID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4MSwgeDJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb25jYXQ0REludGVybmFsID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4MSwgeDJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zY2FsZWRBcnJheUFkZEludGVybmFsID0gZnVuY3Rpb24gKGMxLCBhLCBjMiwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBhZGRzY2FsZWRtYXRfZ3B1XzEuQWRkU2NhbGVkTWF0UHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYiwgYzEsIGMyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubmVnSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLk5FRyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYWtlT3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlU2hhcGVSQyA9IHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSh0aGlzLmdwZ3B1LmdsLCBzaGFwZSk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHNoYXBlLCB7IHRleHR1cmU6IHRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiB0ZXh0dXJlU2hhcGVSQyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29tcGlsZUFuZFJ1biA9IGZ1bmN0aW9uIChwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCwgY3VzdG9tU2V0dXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG91dHB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBncGdwdV9tYXRoLm1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgICAgICB2YXIgYmluYXJ5ID0gdGhpcy5nZXRBbmRTYXZlQmluYXJ5KGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdwZ3B1X21hdGguY29tcGlsZVByb2dyYW0oX3RoaXMuZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdwZ3B1X21hdGgucnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWF0TXVsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsbWF0X2dwdV8xLk1hdE11bFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubXVsdGlwbHlJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTVVMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjJESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW3gsIG1lYW4sIHZhcmlhbmNlXTtcbiAgICAgICAgdmFyIG9mZnNldFNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvZmZzZXRTaGFwZSA9IG9mZnNldC5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlU2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2NhbGVTaGFwZSA9IHNjYWxlLnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJhdGNobm9ybV9ncHVfMS5CYXRjaE5vcm1Qcm9ncmFtKHguc2hhcGUsIG1lYW4uc2hhcGUsIHZhcmlhbmNlLnNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW3gsIG1lYW4sIHZhcmlhbmNlXTtcbiAgICAgICAgdmFyIG9mZnNldFNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvZmZzZXRTaGFwZSA9IG9mZnNldC5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlU2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2NhbGVTaGFwZSA9IHNjYWxlLnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJhdGNobm9ybV9ncHVfMS5CYXRjaE5vcm1Qcm9ncmFtKHguc2hhcGUsIG1lYW4uc2hhcGUsIHZhcmlhbmNlLnNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRpbGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCByZXBzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHRpbGVfZ3B1XzEuVGlsZVByb2dyYW0oYS5zaGFwZSwgcmVwcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50cmFuc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBwZXJtKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHRyYW5zcG9zZV9ncHVfMS5UcmFuc3Bvc2VQcm9ncmFtKGEuc2hhcGUsIHBlcm0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGEsIHJlZHVjZVR5cGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBhLnNoYXBlWzBdO1xuICAgICAgICB2YXIgaW5TaXplID0gYS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKTtcbiAgICAgICAgdmFyIHJlZHVjZUluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSB9O1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZWR1Y2VfZ3B1XzEuUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKTtcbiAgICAgICAgdmFyIF9hID0gcHJvZ3JhbS5vdXRwdXRTaGFwZSwgcm93cyA9IF9hWzBdLCBjb2xzID0gX2FbMV07XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBkdHlwZSkuYXMyRChyb3dzLCBjb2xzKTtcbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSwgb3V0cHV0KTtcbiAgICAgICAgaWYgKG91dHB1dC5zaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2Uob3V0cHV0LCByZWR1Y2VUeXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXJnUmVkdWNlID0gZnVuY3Rpb24gKGEsIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSkge1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBID09PSB2b2lkIDApIHsgYmVzdEluZGljZXNBID0gbnVsbDsgfVxuICAgICAgICB2YXIgYmF0Y2hTaXplID0gYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IGEuc2hhcGVbMV07XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgIT0gbnVsbCkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gYmVzdEluZGljZXNBLnNoYXBlWzBdO1xuICAgICAgICAgICAgaW5TaXplID0gYmVzdEluZGljZXNBLnNoYXBlWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlX3V0aWwuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSk7XG4gICAgICAgIHZhciByZWR1Y2VJbmZvID0geyB3aW5kb3dTaXplOiB3aW5kb3dTaXplLCBpblNpemU6IGluU2l6ZSwgYmF0Y2hTaXplOiBiYXRjaFNpemUgfTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYXJnbWlubWF4X2dwdV8xLkFyZ01pbk1heFByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSwgYmVzdEluZGljZXNBID09IG51bGwpO1xuICAgICAgICB2YXIgX2EgPSBwcm9ncmFtLm91dHB1dFNoYXBlLCByb3dzID0gX2FbMF0sIGNvbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdpbnQzMicpLmFzMkQocm93cywgY29scyk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbYV07XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goYmVzdEluZGljZXNBKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgICAgICBpZiAob3V0cHV0LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhLCByZWR1Y2VUeXBlLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnN1bUludGVybmFsID0gZnVuY3Rpb24gKGEsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCBhLnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHZhciBvdXRwdXREVHlwZSA9IG1hdGhfMS5TdW1UeXBlc01hcFthLmR0eXBlXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ3N1bScsIG91dHB1dERUeXBlKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hcmdNaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgYS5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYS5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0gYS5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYTJELCAnbWluJykucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXJnTWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01heCcsIGF4ZXMsIGEucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKGEyRCwgJ21heCcpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmVxdWFsSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkVRVUFMLCB4LnNoYXBlLCB5LnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIHldLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRvcEtJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5LCBrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9wSyBHUFUgbm90IHlldCBpbXBsZW1lbnRlZCEnKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5taW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgYS5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYS5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0gYS5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnbWluJywgYTJELmR0eXBlKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWF4JywgYXhlcywgYS5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYS5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0gYS5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnbWF4JywgYTJELmR0eXBlKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5kaXZpZGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuRElWLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFkZEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5BREQsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3VidHJhY3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuU1VCLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNlaWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQ0VJTCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5mbG9vckludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5GTE9PUik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5leHBJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuRVhQKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmxvZ0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5MT0cpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3FydEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TUVJUKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNxdWFyZUludGVybmFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TUVVBUkUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUucmVsdUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5SRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmVsdUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5FTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubGVha3lSZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5MRUFLWV9SRUxVKGFscGhhKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jbGlwSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY2xpcF9ncHVfMS5DbGlwUHJvZ3JhbShhLnNoYXBlLCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hYnNJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQUJTKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNpZ21vaWRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU0lHTU9JRCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU0lOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvc0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5DT1MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlRBTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFTSU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYWNvc0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5BQ09TKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmF0YW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQVRBTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zaW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNJTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29zaEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5DT1NIKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRhbmhJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuVEFOSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zdGVwSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TVEVQKGFscGhhKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb252MmRJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1XzEuQ29udjJEUHJvZ3JhbShjb252SW5mbywgYmlhcyAhPSBudWxsKTtcbiAgICAgICAgdmFyIGlucHV0cyA9IGJpYXMgIT0gbnVsbCA/IFt4LCBmaWx0ZXIsIGJpYXNdIDogW3gsIGZpbHRlcl07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb252MmREZXJJbnB1dEludGVybmFsID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHksIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZERlckZpbHRlckludGVybmFsID0gZnVuY3Rpb24gKHgsIGRZLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlcldlaWdodHNQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgZFldKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb252MmREZXJCaWFzSW50ZXJuYWwgPSBmdW5jdGlvbiAoZFkpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJCaWFzUHJvZ3JhbShkWS5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2RZXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9ncHVfZGVwdGh3aXNlXzEuRGVwdGh3aXNlQ29udjJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2lucHV0LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWluUG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21pbicsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmF2Z1Bvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdhdmcnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3BJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBnZXRQb3NpdGlvbnMpO1xuICAgICAgICB2YXIgbWF4UG9vbFBvc2l0aW9ucyA9IHRoaXMuY29tcGlsZUFuZFJ1bihtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSwgW3hdKTtcbiAgICAgICAgdmFyIG1heFBvb2xCYWNrUHJvcFByb2dyYW0gPSBuZXcgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XzEuTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29tcGlsZUFuZFJ1bihtYXhQb29sQmFja1Byb3BQcm9ncmFtLCBbZHksIG1heFBvb2xQb3NpdGlvbnNdKTtcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzREludGVybmFsID0gZnVuY3Rpb24gKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXNpemVfYmlsaW5lYXJfZ3B1XzEuUmVzaXplQmlsaW5lYXIzRFByb2dyYW0oeC5zaGFwZSwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm11bHRpbm9taWFsSW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvYnMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtT3V0Y29tZXMgPSBwcm9icy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsdGlub21pYWxfZ3B1XzEuTXVsdGlub21pYWxQcm9ncmFtKGJhdGNoU2l6ZSwgbnVtT3V0Y29tZXMsIG51bVNhbXBsZXMpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKHNlZWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtwcm9ic10sIG91dHB1dCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm9uZUhvdEludGVybmFsID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBvbmVob3RfZ3B1XzEuT25lSG90UHJvZ3JhbShpbmRpY2VzLnNpemUsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2luZGljZXNdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5nZXRBbmRTYXZlQmluYXJ5ID0gZnVuY3Rpb24gKGtleSwgZ2V0QmluYXJ5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLmJpbmFyeUNhY2hlKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlDYWNoZVtrZXldID0gZ2V0QmluYXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5nZXRUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXI7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlUHJvZ3JhbSh0aGlzLmJpbmFyeUNhY2hlW2tleV0ud2ViR0xQcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOREFycmF5TWF0aEdQVTtcbn0obWF0aF8xLk5EQXJyYXlNYXRoKSk7XG5leHBvcnRzLk5EQXJyYXlNYXRoR1BVID0gTkRBcnJheU1hdGhHUFU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgdGV4X3V0aWxfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RleF91dGlsXCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbC93ZWJnbF91dGlsXCIpO1xuZXhwb3J0cy5HUEdQVSA9IG51bGw7XG5leHBvcnRzLlRFWFRVUkVfTUFOQUdFUiA9IG51bGw7XG52YXIgRFR5cGU7XG4oZnVuY3Rpb24gKERUeXBlKSB7XG4gICAgRFR5cGVbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgRFR5cGVbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBEVHlwZVtcImJvb2xcIl0gPSBcImJvb2xcIjtcbn0pKERUeXBlID0gZXhwb3J0cy5EVHlwZSB8fCAoZXhwb3J0cy5EVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBpbml0aWFsaXplR1BVKGdwZ3B1LCB0ZXh0dXJlTWFuYWdlcikge1xuICAgIGV4cG9ydHMuR1BHUFUgPSBncGdwdTtcbiAgICBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUiA9IHRleHR1cmVNYW5hZ2VyO1xufVxuZXhwb3J0cy5pbml0aWFsaXplR1BVID0gaW5pdGlhbGl6ZUdQVTtcbmZ1bmN0aW9uIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoZXhwb3J0cy5HUEdQVSA9PSBudWxsIHx8IGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHUFUgbm90IGludGlhbGl6ZWQuJyk7XG4gICAgfVxufVxudmFyIE5EQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXkoc2hhcGUsIGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRhdGEudmFsdWVzICE9IG51bGwgfHwgZGF0YS50ZXh0dXJlICE9IG51bGwsICdFaXRoZXIgYHZhbHVlc2Agb3IgYHRleHR1cmVgIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB1dGlsLmFzc2VydChkYXRhLnRleHR1cmUgPT0gbnVsbCB8fCAoZGF0YS50ZXh0dXJlU2hhcGVSQyAhPSBudWxsKSwgJ2B0ZXh0dXJlU2hhcGVgIG11c3QgYmUgZGVmaW5lZCB3aGVuIGB0ZXh0dXJlYCBpcyBkZWZpbmVkJyk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIGlmIChkYXRhLnZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IGRhdGEudmFsdWVzLmxlbmd0aCwgXCJDb25zdHJ1Y3RpbmcgbmRhcnJheSBvZiBzaGFwZSAoXCIgKyB0aGlzLnNpemUgKyBcIikgc2hvdWxkIG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHZhbHVlcyAoXCIgKyBkYXRhLnZhbHVlcy5sZW5ndGggKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgaWYgKGRhdGEudGV4dHVyZVR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS50ZXh0dXJlVHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlIHx8ICdmbG9hdDMyJztcbiAgICAgICAgdmFyIGRpbSA9IHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICBpZiAoZGltIDwgMikge1xuICAgICAgICAgICAgdGhpcy5zdHJpZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZXMgPSBuZXcgQXJyYXkoZGltIC0gMSk7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZXNbZGltIC0gMl0gPSB0aGlzLnNoYXBlW2RpbSAtIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRpbSAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpZGVzW2ldID0gdGhpcy5zdHJpZGVzW2kgKyAxXSAqIHRoaXMuc2hhcGVbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE5EQXJyYXkuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYWtlWmVyb3NUeXBlZEFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksIGR0eXBlKTtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5Lnplcm9zTGlrZSA9IGZ1bmN0aW9uIChhbm90aGVyKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKGFub3RoZXIuc2hhcGUsIGFub3RoZXIuZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5saWtlID0gZnVuY3Rpb24gKGFub3RoZXIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IGNvcHlUeXBlZEFycmF5KGFub3RoZXIuZ2V0VmFsdWVzKCksIGFub3RoZXIuZHR5cGUpO1xuICAgICAgICByZXR1cm4gTkRBcnJheS5tYWtlKGFub3RoZXIuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSwgYW5vdGhlci5kdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5Lm1ha2UgPSBmdW5jdGlvbiAoc2hhcGUsIGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkYXRhLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtYWtlIG5ldyBOREFycmF5IGZyb20gZGlzcG9zZWQgTkRBcnJheURhdGEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIoZGF0YSwgZHR5cGUpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkxRChkYXRhLCBkdHlwZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTJEKHNoYXBlLCBkYXRhLCBkdHlwZSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlLCBkYXRhLCBkdHlwZSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTREKHNoYXBlLCBkYXRhLCBkdHlwZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTkRBcnJheShzaGFwZSwgZGF0YSwgZHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5LmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IHZvaWQgMCkgeyBudW1DaGFubmVscyA9IDM7IH1cbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IE5EQXJyYXkgd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhcGUgPSBbcGl4ZWxzLmhlaWdodCwgcGl4ZWxzLndpZHRoLCBudW1DaGFubmVsc107XG4gICAgICAgIHZhciB0ZXh0dXJlU2hhcGVSQyA9IFtzaGFwZVswXSwgc2hhcGVbMV1dO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSLmFjcXVpcmVUZXh0dXJlKHRleHR1cmVTaGFwZVJDKTtcbiAgICAgICAgdmFyIHRleHR1cmVUeXBlID0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5SR0JBX0NPTE9SO1xuICAgICAgICBleHBvcnRzLkdQR1BVLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0ZXh0dXJlLCBwaXhlbHMpO1xuICAgICAgICByZXR1cm4gQXJyYXkzRC5tYWtlKHNoYXBlLCB7IHRleHR1cmU6IHRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiB0ZXh0dXJlU2hhcGVSQywgdGV4dHVyZVR5cGU6IHRleHR1cmVUeXBlIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uIChuZXdTaGFwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBuZXdTaGFwZSA9IHV0aWwuaW5mZXJGcm9tSW1wbGljaXRTaGFwZShuZXdTaGFwZSwgdGhpcy5zaXplKTtcbiAgICAgICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwodGhpcy5zaGFwZSwgbmV3U2hhcGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSksICduZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLicpO1xuICAgICAgICByZXR1cm4gTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB0aGlzLm5kYXJyYXlEYXRhLCB0aGlzLmR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQXJyYXkxRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXMxRCgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXNTY2FsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gMSwgJ1RoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW10pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXMxRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbdGhpcy5zaXplXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczJEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1uc10pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXMzRCA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zLCBkZXB0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zLCBkZXB0aF0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXM0RCA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zLCBkZXB0aCwgZGVwdGgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgbmV3RGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICBpZiAobmV3RGF0YS52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RGF0YSA9IHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkobmV3RGF0YS52YWx1ZXMsIGR0eXBlKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2UodGhpcy5zaGFwZSwgbmV3RGF0YSwgZHR5cGUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5EQXJyYXkucHJvdG90eXBlLCBcInJhbmtcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbaW5kZXhdO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuc2V0LmFwcGx5KHRoaXMsIFt0aGlzLmdldC5hcHBseSh0aGlzLCBsb2NzKSArIHZhbHVlXS5jb25jYXQobG9jcykpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFZhbHVlcygpW2luZGV4XSA9IHZhbHVlO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldC5hcHBseSh0aGlzLCBsb2NzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBsb2NzID0gbmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgbG9jc1tpXSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZXNbaV0pO1xuICAgICAgICAgICAgaW5kZXggLT0gbG9jc1tpXSAqIHRoaXMuc3RyaWRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBsb2NzW2xvY3MubGVuZ3RoIC0gMV0gPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIGxvY3M7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKCkuZmlsbCh2YWx1ZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5RGF0YTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVN5bmMoKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldFZhbHVlc0FzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIHF1ZXJ5Rm47XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMubmRhcnJheURhdGEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlVHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5uZGFycmF5RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZXhwb3J0cy5HUEdQVS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlQXN5bmModGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzBdLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzFdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnZhbHVlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5uZGFycmF5RGF0YS52YWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJykpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZGF0YVN5bmMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUZuID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHBvcnRzLkdQR1BVLnJ1blF1ZXJ5KHF1ZXJ5Rm4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmRhdGFTeW5jKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRhdGFTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS52YWx1ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudGV4dHVyZVR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IGV4cG9ydHMuR1BHUFUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUsIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMF0sIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gZXhwb3J0cy5HUEdQVS5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1swXSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1sxXSwgdGhpcy5zaGFwZVsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcyA9IGZsb2F0MzJUb1R5cGVkQXJyYXkodmFsdWVzLCB0aGlzLmR0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5RGF0YS52YWx1ZXM7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS51cGxvYWRUb0dQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkMgPVxuICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKGV4cG9ydHMuR1BHUFUuZ2wsIHRoaXMuc2hhcGUpO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUgPVxuICAgICAgICAgICAgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIuYWNxdWlyZVRleHR1cmUodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQ7XG4gICAgICAgIGV4cG9ydHMuR1BHUFUudXBsb2FkTWF0cml4VG9UZXh0dXJlKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1swXSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1sxXSwgdHlwZWRBcnJheVRvRmxvYXQzMih0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcywgdGhpcy5kdHlwZSkpO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcyA9IG51bGw7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkVG9HUFUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VGV4dHVyZVNoYXBlUkMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkVG9HUFUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQztcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRBcnJheSBpcyBkaXNwb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudmFsdWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kaXNwb3NlVGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgICAgIGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSLnJlbGVhc2VUZXh0dXJlKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkMgPSBudWxsO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVUeXBlID0gbnVsbDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmluR1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlICE9IG51bGw7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kdHlwZSA9PT0gdC5kdHlwZSAmJiB1dGlsLmFycmF5c0VxdWFsKHRoaXMuc2hhcGUsIHQuc2hhcGUpICYmXG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMuZ2V0VmFsdWVzKCksIHQuZ2V0VmFsdWVzKCkpO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYW5kRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHJhbmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheTtcbn0oKSk7XG5leHBvcnRzLk5EQXJyYXkgPSBOREFycmF5O1xudmFyIFNjYWxhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXIoZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRhdGEudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLnRleHR1cmVTaGFwZVJDID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgW10sIGRhdGEsIGR0eXBlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjYWxhci5uZXcgPSBmdW5jdGlvbiAodmFsdWUsIGR0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbdmFsdWVdO1xuICAgICAgICByZXR1cm4gbmV3IFNjYWxhcih7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVswXTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbMF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbMF0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc1R5cGUuY2FsbCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFNjYWxhci5aRVJPID0gU2NhbGFyLm5ldygwKTtcbiAgICBTY2FsYXIuT05FID0gU2NhbGFyLm5ldygxKTtcbiAgICBTY2FsYXIuVFdPID0gU2NhbGFyLm5ldygyKTtcbiAgICBTY2FsYXIuTkVHX09ORSA9IFNjYWxhci5uZXcoLTEpO1xuICAgIHJldHVybiBTY2FsYXI7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuU2NhbGFyID0gU2NhbGFyO1xudmFyIEFycmF5MUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5MUQoZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNoYXBlID0gKGRhdGEudmFsdWVzICE9IG51bGwpID9cbiAgICAgICAgICAgIFtkYXRhLnZhbHVlcy5sZW5ndGhdIDpcbiAgICAgICAgICAgIFt1dGlsLnNpemVGcm9tU2hhcGUoZGF0YS50ZXh0dXJlU2hhcGVSQyldO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlLCBkYXRhLCBkdHlwZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheTFELm5ldyA9IGZ1bmN0aW9uICh2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VvZlR5cGVkQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGluZmVycmVkU2hhcGUubGVuZ3RoID09PSAxLCBcIkVycm9yIGNvbnN0cnVjdGluZyBBcnJheTFELiBTaGFwZSBvZiB2YWx1ZXMgXCIgKyBpbmZlcnJlZFNoYXBlICsgXCIgaXMgXCIgK1xuICAgICAgICAgICAgICAgIFwibm90IDEgZGltZW5zaW9uYWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkxRCh7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW2ldO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbaV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQoaSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW2ldICs9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgICAgcmV0dXJuIGxvY1swXTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtpbmRleF07XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNUeXBlLmNhbGwodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkxRC56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MUQucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTFELnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXkxRC5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTFEO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5MUQgPSBBcnJheTFEO1xudmFyIEFycmF5MkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5MkQoc2hhcGUsIGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMiwgJ1NoYXBlIHNob3VsZCBiZSBvZiBsZW5ndGggMicpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlLCBkYXRhLCBkdHlwZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaWRlMCA9IF90aGlzLnN0cmlkZXNbMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXkyRC5uZXcgPSBmdW5jdGlvbiAoc2hhcGUsIHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZW9mVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGUsIGluZmVycmVkU2hhcGUsIFwiRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXkyRC4gU2hhcGUgb2YgdmFsdWVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluZmVycmVkU2hhcGUgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKHNoYXBlICsgXCIuIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTJEKHNoYXBlLCB7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaikge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdICs9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldChpLCBqKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgbG9jc1sxXTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKSwgaW5kZXggJSB0aGlzLnN0cmlkZTBdO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzVHlwZS5jYWxsKHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MkQuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTJELnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgQXJyYXkyRC5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MkQucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXkyRDtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5BcnJheTJEID0gQXJyYXkyRDtcbnZhciBBcnJheTNEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXkzRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheTNEKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDMsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDMnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZSwgZGF0YSwgZHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmlkZTAgPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICBfdGhpcy5zdHJpZGUxID0gX3RoaXMuc3RyaWRlc1sxXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheTNELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTNELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5M0Qoc2hhcGUsIHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGosIGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaykge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga10gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChpLCBqLCBrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQoaSwgaiwgayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaykge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga10gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyB0aGlzLnN0cmlkZTEgKiBsb2NzWzFdICsgbG9jc1syXTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKTtcbiAgICAgICAgaW5kZXggLT0gaSAqIHRoaXMuc3RyaWRlMDtcbiAgICAgICAgcmV0dXJuIFtpLCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUxKSwgaW5kZXggJSB0aGlzLnN0cmlkZTFdO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzVHlwZS5jYWxsKHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5M0QuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTNELnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgQXJyYXkzRC5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5M0QucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXkzRDtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5BcnJheTNEID0gQXJyYXkzRDtcbnZhciBBcnJheTREID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXk0RCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheTREKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDQsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDQnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZSwgZGF0YSwgZHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmlkZTAgPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICBfdGhpcy5zdHJpZGUxID0gX3RoaXMuc3RyaWRlc1sxXTtcbiAgICAgICAgX3RoaXMuc3RyaWRlMiA9IF90aGlzLnN0cmlkZXNbMl07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXk0RC5uZXcgPSBmdW5jdGlvbiAoc2hhcGUsIHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZW9mVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGUsIGluZmVycmVkU2hhcGUsIFwiRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXk0RC4gU2hhcGUgb2YgdmFsdWVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluZmVycmVkU2hhcGUgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKHNoYXBlICsgXCIuIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTREKHNoYXBlLCB7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqLCBrLCBsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqLCBrLCBsKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChpLCBqLCBrLCBsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQoaSwgaiwgaywgbCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaywgbCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdICs9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgdGhpcy5zdHJpZGUxICogbG9jc1sxXSArXG4gICAgICAgICAgICB0aGlzLnN0cmlkZTIgKiBsb2NzWzJdICsgbG9jc1szXTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKTtcbiAgICAgICAgaW5kZXggLT0gaSAqIHRoaXMuc3RyaWRlMDtcbiAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUxKTtcbiAgICAgICAgaW5kZXggLT0gaiAqIHRoaXMuc3RyaWRlMTtcbiAgICAgICAgcmV0dXJuIFtpLCBqLCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUyKSwgaW5kZXggJSB0aGlzLnN0cmlkZTJdO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzVHlwZS5jYWxsKHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5NEQuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTRELnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgQXJyYXk0RC5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5NEQucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXk0RDtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5BcnJheTREID0gQXJyYXk0RDtcbmZ1bmN0aW9uIGNvcHlUeXBlZEFycmF5KGFycmF5LCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PSBudWxsIHx8IGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhciBib29sID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWwsICdib29sJykpIHtcbiAgICAgICAgICAgICAgICBib29sW2ldID0gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIGJvb2xbaV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zdGFuY2VvZlR5cGVkQXJyYXkoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgICAgIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZnVuY3Rpb24gbm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmIGR0eXBlID09PSAnZmxvYXQzMicpIHx8XG4gICAgICAgIChhIGluc3RhbmNlb2YgSW50MzJBcnJheSAmJiBkdHlwZSA9PT0gJ2ludDMyJykgfHxcbiAgICAgICAgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGR0eXBlID09PSAnYm9vbCcpO1xufVxuZnVuY3Rpb24gdG9UeXBlZEFycmF5KGEsIGR0eXBlKSB7XG4gICAgaWYgKG5vQ29udmVyc2lvbk5lZWRlZChhLCBkdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGEgPSB1dGlsLmZsYXR0ZW4oYSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5VHlwZWRBcnJheShhLCBkdHlwZSk7XG59XG5mdW5jdGlvbiBtYWtlWmVyb3NUeXBlZEFycmF5KHNpemUsIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHR5cGVkQXJyYXlUb0Zsb2F0MzIoYSwgZHR5cGUpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhW2ldO1xuICAgICAgICAgICAgcmVzW2ldID0gdXRpbC5pc1ZhbE5hTih2YWwsIGR0eXBlKSA/IE5hTiA6IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsb2F0MzJUb1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicgfHwgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gKGR0eXBlID09PSAnaW50MzInKSA/IG5ldyBJbnQzMkFycmF5KGEubGVuZ3RoKSA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYVtpXTtcbiAgICAgICAgICAgIHZhbCA9IGlzTmFOKHZhbCkgPyB1dGlsLmdldE5hTihkdHlwZSkgOiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmRhcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFSQUxMRUxJWkVfVEhSRVNIT0xEID0gMzA7XG5mdW5jdGlvbiBjb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKSB7XG4gICAgaWYgKGluU2l6ZSA8PSBleHBvcnRzLlBBUkFMTEVMSVpFX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm4gaW5TaXplO1xuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdERpdmlzb3IoaW5TaXplLCBNYXRoLmZsb29yKE1hdGguc3FydChpblNpemUpKSk7XG59XG5leHBvcnRzLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZSA9IGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTtcbmZ1bmN0aW9uIG5lYXJlc3REaXZpc29yKHNpemUsIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgIGlmIChzaXplICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBiZWdpbi5sZW5ndGgsIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IExlbmd0aCBvZiBiZWdpbiBcIiArIGJlZ2luICsgXCIgbXVzdCBcIiArXG4gICAgICAgIChcIm1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIgKyBpbnB1dC5yYW5rICsgXCIpLlwiKSk7XG4gICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gc2l6ZS5sZW5ndGgsIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IExlbmd0aCBvZiBzaXplIFwiICsgc2l6ZSArIFwiIG11c3QgXCIgK1xuICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiICsgaW5wdXQucmFuayArIFwiKS5cIikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQucmFuazsgKytpKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGJlZ2luW2ldICsgc2l6ZVtpXSA8PSBpbnB1dC5zaGFwZVtpXSwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogYmVnaW5bXCIgKyBpICsgXCJdICsgc2l6ZVtcIiArIGkgKyBcIl0gXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgKGJlZ2luW2ldICsgc2l6ZVtpXSkgKyBcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIgKyBpICsgXCJdIChcIiArIGlucHV0LnNoYXBlW2ldICsgXCIpXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFBhcmFtc1ZhbGlkID0gYXNzZXJ0UGFyYW1zVmFsaWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIEFkZFNjYWxlZE1hdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkZFNjYWxlZE1hdFByb2dyYW0oYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InLCAnYzEnLCAnYzInXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPVxuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjMSA9IGdldEMxKCk7XFxuICAgICAgICBmbG9hdCBjMiA9IGdldEMyKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZG90KHZlYzIoYzEsIGMyKSwgdmVjMihhLCBiKSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBZGRTY2FsZWRNYXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQWRkU2NhbGVkTWF0UHJvZ3JhbSA9IEFkZFNjYWxlZE1hdFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRzY2FsZWRtYXRfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFyZ01pbk1heFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZ01pbk1heFByb2dyYW0ocmVkdWNlSW5mbywgb3AsIGZpcnN0UGFzcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgaWYgKCFmaXJzdFBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiZXN0SW5kaWNlc0EnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBjb21wT3AgPSAob3AgPT09ICdtYXgnKSA/ICc+JyA6ICc8JztcbiAgICAgICAgdmFyIGluZGV4U25pcHBldCA9IGZpcnN0UGFzcyA/XG4gICAgICAgICAgICAnaW5PZmZzZXQgKyBpOycgOlxuICAgICAgICAgICAgJ3JvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7JztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gMDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGluT2Zmc2V0KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplICsgXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIiArIGluZGV4U25pcHBldCArIFwiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChpc05hTihjYW5kaWRhdGUpKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGNhbmRpZGF0ZSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIgKyBjb21wT3AgKyBcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQXJnTWluTWF4UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkFyZ01pbk1heFByb2dyYW0gPSBBcmdNaW5NYXhQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWlubWF4X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBCYXRjaE5vcm1Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1Qcm9ncmFtKHhTaGFwZSwgbWVhblNoYXBlLCB2YXJpYW5jZVNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdtZWFuJywgJ3ZhcmlhbmNlJ107XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCB2YXJpYW5jZVNoYXBlKTtcbiAgICAgICAgdmFyIG9mZnNldFNuaXBwZXQgPSAnMC4wJztcbiAgICAgICAgaWYgKG9mZnNldFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgb2Zmc2V0U2hhcGUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ29mZnNldCcpO1xuICAgICAgICAgICAgb2Zmc2V0U25pcHBldCA9ICdnZXRPZmZzZXRBdE91dENvb3JkcygpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTbmlwcGV0ID0gJzEuMCc7XG4gICAgICAgIGlmIChzY2FsZVNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiICsgc2NhbGVTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1Qcm9ncmFtID0gQmF0Y2hOb3JtUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNobm9ybV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vYnJvYWRjYXN0X3V0aWxcIik7XG5leHBvcnRzLkFERCA9ICdyZXR1cm4gYSArIGI7JztcbmV4cG9ydHMuU1VCID0gJ3JldHVybiBhIC0gYjsnO1xuZXhwb3J0cy5NVUwgPSAncmV0dXJuIGEgKiBiOyc7XG5leHBvcnRzLkRJViA9ICdyZXR1cm4gYSAvIGI7JztcbmV4cG9ydHMuRVFVQUwgPSBcIlxcbiAgaWYgKGlzTmFOKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc05hTihiKSkgcmV0dXJuIGI7XFxuICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG5cIjtcbnZhciBCaW5hcnlPcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wUHJvZ3JhbShvcCwgYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPVxuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcGVyYXRpb24oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICAgICAgXCIgKyBvcCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBCaW5hcnlPcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlPcFByb2dyYW0gPSBCaW5hcnlPcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnlvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xpcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaXBQcm9ncmFtKGFTaGFwZSwgbWluLCBtYXgpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHZhciBtaW5GaXhlZCA9IG1pbi50b0ZpeGVkKDIwKTtcbiAgICAgICAgdmFyIG1heEZpeGVkID0gbWF4LnRvRml4ZWQoMjApO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIFwiICsgbWluRml4ZWQgKyBcIiwgXCIgKyBtYXhGaXhlZCArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENsaXBQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ2xpcFByb2dyYW0gPSBDbGlwUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaXBfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL2NvbmNhdF91dGlsXCIpO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIENvbmNhdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmNhdFByb2dyYW0oYVNoYXBlLCBiU2hhcGUsIGF4aXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgeUF4ZXMgPSBbJ3lSJywgJ3lDJywgJ3lEJywgJ3lXJ107XG4gICAgICAgIHZhciBjb25jYXRBeGlzID0geUF4ZXNbYXhpc107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYVNoYXBlLCBiU2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgZFR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIHVucGFja1NuaXBwZXQgPSBnZXRVbnBhY2soYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1wbGVDb29yZHMgPSBnZXRTYW1wbGVDb29yZHMoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZFR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiICsgdW5wYWNrU25pcHBldCArIFwiXFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgIGlmIChcIiArIGNvbmNhdEF4aXMgKyBcIiA8IFwiICsgYVNoYXBlW2F4aXNdICsgXCIpIHtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRBKFwiICsgc2FtcGxlQ29vcmRzICsgXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyBjb25jYXRBeGlzICsgXCIgLT0gXCIgKyBhU2hhcGVbYXhpc10gKyBcIjtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRCKFwiICsgc2FtcGxlQ29vcmRzICsgXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29uY2F0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbmNhdFByb2dyYW0gPSBDb25jYXRQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U2FtcGxlQ29vcmRzKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3lSJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ3lSLCB5Qyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICd5UiwgeUMsIHlEJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ3lSLCB5QywgeUQsIHlXJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ29uY2F0IGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFVucGFjayhyYW5rKSB7XG4gICAgdmFyIHJlcyA9IHJhbmsgPT09IDEgPyAnaW50IHlSID0gY29vcmRzOycgOiAnaW50IHlSID0gY29vcmRzLng7JztcbiAgICBpZiAocmFuayA+IDEpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeUMgPSBjb29yZHMueTsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDIpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeUQgPSBjb29yZHMuejsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDMpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeVcgPSBjb29yZHMudzsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDb25jYXQgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb252X3V0aWxcIik7XG52YXIgQ29udjJERGVyV2VpZ2h0c1Byb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlcldlaWdodHNQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICAgICAgICB2YXIgX2EgPSBjb252SW5mby5vdXRTaGFwZSwgeU51bVJvd3MgPSBfYVswXSwgeU51bUNvbHMgPSBfYVsxXSwgb3V0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIF9iID0gY29udkluZm8uaW5TaGFwZSwgeE51bVJvd3MgPSBfYlswXSwgeE51bUNvbHMgPSBfYlsxXSwgaW5EZXB0aCA9IF9iWzJdO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlV2VpZ2h0c1NoYXBlNEQoaW5EZXB0aCwgb3V0RGVwdGgsIGNvbnZJbmZvLmZpbHRlckhlaWdodCwgY29udkluZm8uZmlsdGVyV2lkdGgpO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIHlOdW1Sb3dzICsgXCI7IHlSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIgLSBcIiArIHBhZFRvcCArIFwiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIHlOdW1Db2xzICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIgKyBzdHJpZGVXaWR0aCArIFwiIC0gXCIgKyBwYWRMZWZ0ICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WCh4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkREZXJXZWlnaHRzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlcldlaWdodHNQcm9ncmFtID0gQ29udjJERGVyV2VpZ2h0c1Byb2dyYW07XG52YXIgQ29udjJERGVySW5wdXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gICAgICAgIHZhciBfYSA9IGNvbnZJbmZvLm91dFNoYXBlLCB5Um93cyA9IF9hWzBdLCB5Q29scyA9IF9hWzFdLCBvdXREZXB0aCA9IF9hWzJdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueHkgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIHlSb3dzICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIHlDb2xzICsgXCIuMCB8fCBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIgKyBmaWx0ZXJXaWR0aCArIFwiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIiArIG91dERlcHRoICsgXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVySW5wdXRQcm9ncmFtID0gQ29udjJERGVySW5wdXRQcm9ncmFtO1xudmFyIENvbnYyRERlckJpYXNQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJCaWFzUHJvZ3JhbSh5U2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeSddO1xuICAgICAgICB2YXIgeU51bVJvd3MgPSB5U2hhcGVbMF0sIHlOdW1Db2xzID0geVNoYXBlWzFdLCBvdXRwdXREZXB0aCA9IHlTaGFwZVsyXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRwdXREZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGludCBkMiA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgZmxvYXQgZGVyQmlhcyA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIHlOdW1Sb3dzICsgXCI7IHlSKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiICsgeU51bUNvbHMgKyBcIjsgeUMrKykge1xcbiAgICAgICAgICAgIGRlckJpYXMgKz0gZ2V0RHkoeVIsIHlDLCBkMik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkZXJCaWFzKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyQmlhc1Byb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJCaWFzUHJvZ3JhbSA9IENvbnYyRERlckJpYXNQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29udjJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJEUHJvZ3JhbShjb252SW5mbywgaGFzQmlhcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICAgICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBiaWFzU25pcHBldCA9IGhhc0JpYXMgPyAnZG90UHJvZCArPSBnZXRCaWFzKGQyKTsnIDogJyc7XG4gICAgICAgIHZhciBfYSA9IGNvbnZJbmZvLmluU2hhcGUsIHhOdW1Sb3dzID0gX2FbMF0sIHhOdW1Db2xzID0gX2FbMV0sIGlucHV0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihpbnB1dERlcHRoIC8gNCkgKiA0O1xuICAgICAgICB2YXIgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBpbnB1dERlcHRoICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnh5ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpICpcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSlcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXCIgKyBiaWFzU25pcHBldCArIFwiXFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkRQcm9ncmFtID0gQ29udjJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERlcHRod2lzZUNvbnYyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSBjb252SW5mby5pblNoYXBlWzFdO1xuICAgICAgICB2YXIgeE51bUNvbHMgPSBjb252SW5mby5pblNoYXBlWzJdO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBjaGFubmVsTXVsID0gY29udkluZm8uY2hhbm5lbE11bDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyIC8gXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiBcIiArIGNoYW5uZWxNdWwgKyBcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkRlcHRod2lzZUNvbnYyRFByb2dyYW0gPSBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9ncHVfZGVwdGh3aXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvcHkyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvcHkyRFByb2dyYW0oc3JjTnVtQ29scywgZGVzdE51bUNvbHMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydzb3VyY2UnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gaXZlYzIgc291cmNlU3RhcnQ7XFxuICAgICAgdW5pZm9ybSBpdmVjMiBkZXN0U3RhcnQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgZGVzdENvb3JkcyA9IGdldE91dHB1dENvb3JkcygpIC0gZGVzdFN0YXJ0O1xcbiAgICAgICAgaW50IGluZGV4ID0gZGVzdENvb3Jkcy54ICogXCIgKyBkZXN0TnVtQ29scyArIFwiICsgZGVzdENvb3Jkcy55O1xcbiAgICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3JjTnVtQ29scyArIFwiO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ29vcmRzID0gc291cmNlU3RhcnQgKyBpdmVjMihyLCBpbmRleCAtIHIgKiBcIiArIHNyY051bUNvbHMgKyBcIik7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKHNvdXJjZUNvb3Jkcy54LCBzb3VyY2VDb29yZHMueSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIENvcHkyRFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzb3VyY2VTdGFydCwgZGVzdFN0YXJ0LCBkZXN0U2l6ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGdwZ3B1LnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uKGRlc3RTdGFydFswXSwgZGVzdFNpemVbMF0sIGRlc3RTdGFydFsxXSwgZGVzdFNpemVbMV0pO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVN0YXJ0Q1JMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc291cmNlU3RhcnQnKTtcbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShzb3VyY2VTdGFydENSTG9jLCBzb3VyY2VTdGFydFswXSwgc291cmNlU3RhcnRbMV0pO1xuICAgICAgICAgICAgdmFyIGRlc3RTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ2Rlc3RTdGFydCcpO1xuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpKGRlc3RTdGFydENSTG9jLCBkZXN0U3RhcnRbMF0sIGRlc3RTdGFydFsxXSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29weTJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvcHkyRFByb2dyYW0gPSBDb3B5MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncGdwdV91dGlsID0gcmVxdWlyZShcIi4vZ3BncHVfdXRpbFwiKTtcbnZhciB0ZXhfdXRpbCA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbF91dGlsXCIpO1xudmFyIEdQR1BVQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR1BHUFVDb250ZXh0KGdsKSB7XG4gICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdwZ3B1X3V0aWwuY3JlYXRlV2ViR0xDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24gPVxuICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdwZ3B1X3V0aWwuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IHdlYmdsX3V0aWwuY3JlYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfVxuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4nICtcbiAgICAgICAgICAgICAgICAnIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCAnICtcbiAgICAgICAgICAgICAgICAnR1BHUFVDb250ZXh0LmRlbGV0ZVByb2dyYW0gYmVmb3JlIGRpc3Bvc2luZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCAnICtcbiAgICAgICAgICAgICAgICAndGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCAnICtcbiAgICAgICAgICAgICAgICAnbWF0cml4IHRleHR1cmUgd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlTWF0cml4VGV4dHVyZSBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgJ2Rpc3Bvc2luZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZmluaXNoKCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVGcmFtZWJ1ZmZlcihfdGhpcy5mcmFtZWJ1ZmZlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUJ1ZmZlcihfdGhpcy52ZXJ0ZXhCdWZmZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUJ1ZmZlcihfdGhpcy5pbmRleEJ1ZmZlcik7IH0pO1xuICAgICAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5lbmFibGVBdXRvbWF0aWNEZWJ1Z1ZhbGlkYXRpb24gPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZW5hYmxlZDtcbiAgICAgICAgd2ViZ2xfdXRpbC5lbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZU1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgZ3BncHVfdXRpbC51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcGl4ZWxzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlbGV0ZU1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIG51bUNoYW5uZWxzID0gMTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlQXN5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkb3dubG9hZCBtYXRyaXggZnJvbSBvdXRwdXQgdGV4dHVyZSBhc3luY2hyb25vdXNseSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJXRUJHTF9nZXRfYnVmZmVyX3N1Yl9kYXRhX2FzeW5jIGlzIG5vdCBlbmFibGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyQXN5bmModGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMoX3RoaXMuZ2wsIF90aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiwgcm93cywgY29sdW1ucyk7IH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB3ZWJnbF91dGlsLmNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gd2ViZ2xfdXRpbC5jcmVhdGVQcm9ncmFtKGdsKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIGlmICgodGhpcy5wcm9ncmFtICE9IG51bGwpICYmIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyh0aGlzLmdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKHByb2dyYW0sIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cgPSBmdW5jdGlvbiAocHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRNYXRyaXhUZXh0dXJlLCBjb2x1bW5zLCByb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihzdGFydENvbHVtbiwgc3RhcnRSb3csIG51bUNvbHVtbnMsIG51bVJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtID0gZnVuY3Rpb24gKGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ3BncHVfdXRpbC5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhCdWZmZXIsIGF0dHJpYkxvY2F0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5maW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5Rm4pIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMihxdWVyeUZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMShxdWVyeUZuKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnlXZWJHTDIgPSBmdW5jdGlvbiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHQgPSB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5nbC5jcmVhdGVRdWVyeSgpO1xuICAgICAgICB0aGlzLmdsLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgYmVuY2htYXJrKCk7XG4gICAgICAgIHRoaXMuZ2wuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBfdGhpcy5nbFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIF90aGlzLmdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IF90aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFRpbWVFbGFwc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gX3RoaXMuZ2xcbiAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBfdGhpcy5nbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNqb2ludCBxdWVyeSB0aW1lciBuZXZlciBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShxdWVyeUdQVSkudGhlbihnZXRUaW1lRWxhcHNlZCkuY2F0Y2gocmVzb2x2ZVdpdGhXYXJuaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5V2ViR0wxID0gZnVuY3Rpb24gKGJlbmNobWFyaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXh0ID0gd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gZXh0LmNyZWF0ZVF1ZXJ5RVhUKCk7XG4gICAgICAgIGV4dC5iZWdpblF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhULCBxdWVyeSk7XG4gICAgICAgIGJlbmNobWFyaygpO1xuICAgICAgICBleHQuZW5kUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2pvaW50ID0gX3RoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICFkaXNqb2ludDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VGltZUVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzam9pbnQgcXVlcnkgdGltZXIgbmV2ZXIgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHV0aWwucmVwZWF0ZWRUcnkocXVlcnlHUFUpLnRoZW4oZ2V0VGltZUVsYXBzZWQpLmNhdGNoKHJlc29sdmVXaXRoV2FybmluZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0ZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5vdXRwdXRUZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwKHRleHR1cmUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZG93bmxvYWRBbmREZWNvZGUoKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyQXN5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZG93bmxvYWRBbmREZWNvZGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlciA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHUEdQVUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBHUEdQVUNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV9jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHNoYWRlcl9jb21waWxlciA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBBVFRSSUJVVEVfTkFNRVMgPSBbJ3V2JywgJ2NsaXBTcGFjZVBvcyddO1xudmFyIE5BTl9VTklGT1JNX05BTUUgPSAnTmFOJztcbmZ1bmN0aW9uIHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSB7XG4gICAgcmV0dXJuICFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xufVxuZnVuY3Rpb24gY29tcGlsZVByb2dyYW0oZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIgaW5wdXRJbmZvcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUluZm8gPSB7XG4gICAgICAgICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LnNoYXBlLFxuICAgICAgICAgICAgdGV4U2hhcGU6IGlucHV0LmdldFRleHR1cmVTaGFwZVJDKCksXG4gICAgICAgICAgICB0ZXh0dXJlVHlwZTogaW5wdXQuZ2V0RGF0YSgpLnRleHR1cmVUeXBlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHByb2dyYW0udmFyaWFibGVOYW1lc1tpXSwgc2hhcGVJbmZvOiBzaGFwZUluZm8gfTtcbiAgICB9KTtcbiAgICB2YXIgaW5TaGFwZUluZm9zID0gaW5wdXRJbmZvcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGVJbmZvOyB9KTtcbiAgICB2YXIgb3V0U2hhcGVJbmZvID0ge1xuICAgICAgICBsb2dpY2FsU2hhcGU6IG91dHB1dC5zaGFwZSxcbiAgICAgICAgdGV4U2hhcGU6IG91dHB1dC5nZXRUZXh0dXJlU2hhcGVSQygpLFxuICAgICAgICB0ZXh0dXJlVHlwZTogb3V0cHV0LmdldERhdGEoKS50ZXh0dXJlVHlwZVxuICAgIH07XG4gICAgdmFyIHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKGlucHV0SW5mb3MsIG91dFNoYXBlSW5mbywgdXNlckNvZGUsIHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpO1xuICAgIHZhciB3ZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW0udmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybU5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9XG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgIEFUVFJJQlVURV9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0QXR0cmlidXRlTG9jYXRpb24od2ViR0xQcm9ncmFtLCBhdHRyaWJ1dGUpO1xuICAgIH0pO1xuICAgIGlmIChzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSA9XG4gICAgICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBOQU5fVU5JRk9STV9OQU1FKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHdlYkdMUHJvZ3JhbTogd2ViR0xQcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgICAgZ3BncHU6IGdwZ3B1LFxuICAgICAgICBpblNoYXBlSW5mb3M6IGluU2hhcGVJbmZvcyxcbiAgICAgICAgb3V0U2hhcGVJbmZvOiBvdXRTaGFwZUluZm9cbiAgICB9O1xufVxuZXhwb3J0cy5jb21waWxlUHJvZ3JhbSA9IGNvbXBpbGVQcm9ncmFtO1xuZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKHNoYXBlSW5mb3MsIGlucHV0cykge1xuICAgIGlmIChzaGFwZUluZm9zLmxlbmd0aCAhPT0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIiArIHNoYXBlSW5mb3MubGVuZ3RoICsgXCIgaW5wdXRzLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwid2FzIGV4ZWN1dGVkIHdpdGggXCIgKyBpbnB1dHMubGVuZ3RoICsgXCIgaW5wdXRzXCIpKTtcbiAgICB9XG4gICAgc2hhcGVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUEgPSBzLmxvZ2ljYWxTaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQSA9IHMudGV4U2hhcGU7XG4gICAgICAgIHZhciBzaGFwZUIgPSBpbnB1dHNbaV0uc2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUIgPSBpbnB1dHNbaV0uZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVcIiArXG4gICAgICAgICAgICAgICAgKFwiIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIgKyB0ZXhTaGFwZUEgKyBcIiBhbmQgXCIgKyB0ZXhTaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShiaW5hcnkuaW5TaGFwZUluZm9zLCBpbnB1dHMpO1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShbYmluYXJ5Lm91dFNoYXBlSW5mb10sIFtvdXRwdXRdKTtcbiAgICB2YXIgb3V0VGV4ID0gb3V0cHV0LmdldFRleHR1cmUoKTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICB2YXIgZ3BncHUgPSBiaW5hcnkuZ3BncHU7XG4gICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gICAgZ3BncHUuc2V0UHJvZ3JhbShiaW5hcnkud2ViR0xQcm9ncmFtKTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHRleCA9IGlucHV0LmdldFRleHR1cmUoKTtcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IGJpbmFyeS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciB2YXJpYWJsZVVuaWZvcm1Mb2NhdGlvbiA9IGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh0ZXgsIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uLCBpKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSwgTmFOKTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgY3VzdG9tU2V0dXAoZ3BncHUsIGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIH1cbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbShiaW5hcnkuYXR0cmlidXRlTG9jYXRpb25zKTtcbn1cbmV4cG9ydHMucnVuUHJvZ3JhbSA9IHJ1blByb2dyYW07XG5mdW5jdGlvbiBtYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIGtleUlucHV0cyA9ICcnO1xuICAgIGlucHV0cy5jb25jYXQob3V0cHV0KS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGtleUlucHV0cyArPSB4LnNoYXBlICsgXCJfXCIgKyB4LmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgfSk7XG4gICAgdmFyIGtleVVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIga2V5QnJvYWRjYXN0ID0gKHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtleSA9IHByb2dyYW0uY29uc3RydWN0b3IubmFtZTtcbiAgICBrZXkgKz0gJ18nICsga2V5QnJvYWRjYXN0ICsgJ18nICsga2V5SW5wdXRzICsgJ18nICsga2V5VXNlckNvZGU7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlcktleSA9IG1ha2VTaGFkZXJLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV9tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0ZXhfdXRpbCA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWVcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChjYW52YXMpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICB2YXIgZ2w7XG4gICAgaWYgKGNhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuQkxFTkQpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ESVRIRVIpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU0FNUExFX0NPVkVSQUdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jdWxsRmFjZShnbC5CQUNLKTsgfSk7XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTENvbnRleHQgPSBjcmVhdGVXZWJHTENvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4U2hhZGVyU291cmNlID0gXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBhdHRyaWJ1dGUgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCI7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMCwgMCwgMSwgLTEsIC0xLCAwLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAxLCAtMSwgMCwgMSwgMF0pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgdmVydGV4QXJyYXkpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBjcmVhdGVWZXJ0ZXhCdWZmZXI7XG5mdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB0cmlhbmdsZVZlcnRleEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzKTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5kZXhCdWZmZXIgPSBjcmVhdGVJbmRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SMzJGO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2wuUkVEO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVUeXBlKGdsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuRkxPQVQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscykge1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHRleHR1cmUgPSB3ZWJnbF91dGlsLmNyZWF0ZVRleHR1cmUoZ2wpO1xuICAgIHZhciB0ZXgyZCA9IGdsLlRFWFRVUkVfMkQ7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgdmFyIGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUodGV4MmQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKHRleDJkLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIG51bGwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlTWF0cml4VGV4dHVyZSA9IGNyZWF0ZU1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZSA9IGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyhnbCwgcHJvZ3JhbSwgdmVydGV4QnVmZmVyLCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgcG9zT2Zmc2V0ID0gMDtcbiAgICB2YXIgdXZPZmZzZXQgPSAzICogNDtcbiAgICB2YXIgc3RyaWRlID0gKDMgKiA0KSArICgyICogNCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sICdjbGlwU3BhY2VQb3MnLCB2ZXJ0ZXhCdWZmZXIsIDMsIHN0cmlkZSwgcG9zT2Zmc2V0LCBhdHRyaWJMb2NhdGlvbnMpO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0LCBhdHRyaWJMb2NhdGlvbnMpO1xufVxuZXhwb3J0cy5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMgPSBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXM7XG5mdW5jdGlvbiB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHBpeGVscykge1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmV4cG9ydHMudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlID0gdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlO1xuZnVuY3Rpb24gdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgZGF0YSwgbnVtQ2hhbm5lbHMpIHtcbiAgICB2YXIgdGV4dHVyZUZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB3ZWJnbF91dGlsLnZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUZvcm1hdCwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBkYXRhKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvVGV4dHVyZShnbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4LCBudW1DaGFubmVscykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciB1bnBhY2tlZEFycmF5O1xuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHZhciBjaGFubmVsc1BlclRleHR1cmUgPSBudW1DaGFubmVscyA9PT0gMSA/IHdlYmdsX3V0aWwuZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCkgOiBudW1DaGFubmVscztcbiAgICAgICAgaWYgKGNoYW5uZWxzUGVyVGV4dHVyZSA9PT0gMSkge1xuICAgICAgICAgICAgdW5wYWNrZWRBcnJheSA9IG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVucGFja2VkQXJyYXkgPVxuICAgICAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXgubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICAgICAgICAgIHRleF91dGlsLmVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShtYXRyaXgsIHVucGFja2VkQXJyYXksIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVucGFja2VkQXJyYXkgPSB0ZXhfdXRpbC5lbmNvZGVGbG9hdEFycmF5KG1hdHJpeCk7XG4gICAgfVxuICAgIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHcsIGgsIHVucGFja2VkQXJyYXksIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMudXBsb2FkTWF0cml4VG9UZXh0dXJlID0gdXBsb2FkTWF0cml4VG9UZXh0dXJlO1xuZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKGdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykpO1xuICAgIHRleF91dGlsLmVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgcGFja2VkUkdCQSwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUgPSB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmU7XG5mdW5jdGlvbiBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciBpc0Zsb2F0VGV4dHVyZSA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0O1xuICAgIGlmIChpc0Zsb2F0VGV4dHVyZSkge1xuICAgICAgICBkb3dubG9hZFRhcmdldCA9XG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUocm93cyAqIGNvbHVtbnMsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG93bmxvYWRUYXJnZXQgPSBuZXcgVWludDhBcnJheShyb3dzICogY29sdW1ucyAqIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBkb3dubG9hZFRhcmdldDtcbn1cbmZ1bmN0aW9uIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpIHtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIGlmIChpc0Zsb2F0VGV4dHVyZSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gICAgICAgIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KGRvd25sb2FkVGFyZ2V0LCBtYXRyaXgsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleF91dGlsLmRlY29kZVRvRmxvYXRBcnJheShkb3dubG9hZFRhcmdldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jKGdsLCBnZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24sIHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbDIsIGNoYW5uZWxzUGVyUGl4ZWwsIGRvd25sb2FkVGFyZ2V0LCBidWZmZXJTaXplQnl0ZXMsIGJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgZ2wyID0gZ2w7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzUGVyUGl4ZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldCA9IGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclNpemVCeXRlcyA9IGRvd25sb2FkVGFyZ2V0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0Lmxlbmd0aCAqIDQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlclNpemVCeXRlcywgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnbDIucmVhZFBpeGVscygwLCAwLCBjb2x1bW5zLCByb3dzLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBnZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24uZ2V0QnVmZmVyU3ViRGF0YUFzeW5jKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgMCwgZG93bmxvYWRUYXJnZXQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMgPSBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmM7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIGNoYW5uZWxzUGVyUGl4ZWwgPSA0O1xuICAgIHZhciBkb3dubG9hZFRhcmdldCA9IGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBkb3dubG9hZFRhcmdldCk7IH0pO1xuICAgIHJldHVybiBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmU7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscykge1xuICAgIHZhciBzaXplID0gcm93cyAqIGNvbHVtbnMgKiA0O1xuICAgIHZhciBkb3dubG9hZFRhcmdldCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIGNvbHVtbnMsIHJvd3MsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG93bmxvYWRUYXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFja2VkUkdCQVtpXSA9IGRvd25sb2FkVGFyZ2V0W2ldO1xuICAgIH1cbiAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyAqIGNoYW5uZWxzKTtcbiAgICB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheShwYWNrZWRSR0JBLCBtYXRyaXgsIGNoYW5uZWxzKTtcbiAgICByZXR1cm4gbWF0cml4O1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgcGFja2VkUkdCQSk7IH0pO1xuICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICByZXR1cm4gdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnbWF4UG9zJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZHlSb3dzID0gY29udkluZm8ub3V0U2hhcGVbMF07XG4gICAgICAgIHZhciBkeUNvbHMgPSBjb252SW5mby5vdXRTaGFwZVsxXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoIC0gMTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBkID0gY29vcmRzLno7XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnh5IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBkeVJvd3MgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBkeUNvbHMgKyBcIi4wIHx8IGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShpZHlSLCBpZHlDLCBkKTtcXG4gICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIiArIGxhc3RJbmRleCArIFwiIC0gaW50KGdldE1heFBvcyhpZHlSLCBpZHlDLCBkKSk7XFxuXFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqIFwiICsgZmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXhfcG9vbF9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4uL21hdGhcIik7XG52YXIgTWF0TXVsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TXVsUHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgYU9yaWVudCwgYk9yaWVudCkge1xuICAgICAgICBpZiAoYU9yaWVudCA9PT0gdm9pZCAwKSB7IGFPcmllbnQgPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudCA9PT0gdm9pZCAwKSB7IGJPcmllbnQgPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ21hdHJpeEEnLCAnbWF0cml4QiddO1xuICAgICAgICB2YXIgb3V0ZXJTaGFwZUEgPSAoYU9yaWVudCA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYVNoYXBlWzBdIDogYVNoYXBlWzFdO1xuICAgICAgICB2YXIgb3V0ZXJTaGFwZUIgPSAoYk9yaWVudCA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYlNoYXBlWzFdIDogYlNoYXBlWzBdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW291dGVyU2hhcGVBLCBvdXRlclNoYXBlQl07XG4gICAgICAgIHZhciBzaGFyZWREaW0gPSAoYU9yaWVudCA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIgPyBhU2hhcGVbMV0gOiBhU2hhcGVbMF0pO1xuICAgICAgICB2YXIgYVNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICAgICAgXCJhUm93LCBcIiArIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgOlxuICAgICAgICAgICAgICAgIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgKyBcIiwgYVJvd1wiO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYlNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGJPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICAgICAgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCArIFwiLCBiQ29sXCIgOlxuICAgICAgICAgICAgICAgIFwiYkNvbCwgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2hhcmVkRGltTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHNoYXJlZERpbSAvIDQpICogNDtcbiAgICAgICAgdmFyIHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPSBzaGFyZWREaW0gJSA0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCIgZmxvYXQgZG90QVJvd0JDb2woaW50IGFSb3csIGludCBiQ29sKSB7XFxuICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyBzaGFyZWREaW1OZWFyZXN0VmVjNCArIFwiOyBpICs9IDQpIHtcXG4gICAgICAgIHZlYzQgYSA9IHZlYzQoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDIsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMywgJ2knKSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzQgYiA9IHZlYzQoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDIsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMywgJ2knKSArIFwiKVxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIHJlc3VsdCArPSBkb3QoYSwgYik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICByZXN1bHQgKz0gZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIikgKlxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgIHZlYzIgYSA9IHZlYzIoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzIgYiA9IHZlYzIoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJlc3VsdCArPSBkb3QoYSwgYik7XFxuICAgICAgfSBlbHNlIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICB2ZWMzIGEgPSB2ZWMzKFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMiwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjMyBiID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDIsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJlc3VsdCArPSBkb3QoYSwgYik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWMyIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGRvdEFSb3dCQ29sKHJlc1JDLngsIHJlc1JDLnkpKTtcXG4gICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdE11bFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NYXRNdWxQcm9ncmFtID0gTWF0TXVsUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bG1hdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTXVsdGlub21pYWxQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aW5vbWlhbFByb2dyYW0oYmF0Y2hTaXplLCBudW1PdXRjb21lcywgbnVtU2FtcGxlcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3Byb2JzJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBudW1TYW1wbGVzXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyAobnVtT3V0Y29tZXMgLSAxKSArIFwiOyBpKyspIHtcXG4gICAgICAgICAgY2RmICs9IGdldFByb2JzKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyAobnVtT3V0Y29tZXMgLSAxKSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgTXVsdGlub21pYWxQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZWVkTG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWVkTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NlZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5zZWVkTG9jLCBzZWVkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aW5vbWlhbFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NdWx0aW5vbWlhbFByb2dyYW0gPSBNdWx0aW5vbWlhbFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aW5vbWlhbF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT25lSG90UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT25lSG90UHJvZ3JhbShudW1JbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydpbmRpY2VzJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbbnVtSW5kaWNlcywgZGVwdGhdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzLngpKTtcXG4gICAgICAgIHNldE91dHB1dChtaXgoZmxvYXQoXCIgKyBvZmZWYWx1ZSArIFwiKSwgZmxvYXQoXCIgKyBvblZhbHVlICsgXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdChpbmRleCA9PSBjb29yZHMueSkpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBPbmVIb3RQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZWVkTG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWVkTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NlZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5zZWVkTG9jLCBzZWVkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPbmVIb3RQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuT25lSG90UHJvZ3JhbSA9IE9uZUhvdFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVob3RfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBvb2wyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvb2wyRFByb2dyYW0oY29udkluZm8sIHBvb2xUeXBlLCBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnICYmIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSBjb252SW5mby5pblNoYXBlWzBdO1xuICAgICAgICB2YXIgeE51bUNvbHMgPSBjb252SW5mby5pblNoYXBlWzFdO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBpc0F2Z1Bvb2wgPSBwb29sVHlwZSA9PT0gJ2F2Zyc7XG4gICAgICAgIHZhciBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICAgIGlmICghaXNBdmdQb29sKSB7XG4gICAgICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdtaW4nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcxLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICctMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVPcF8xID0gcG9vbFR5cGUgPT09ICdtaW4nID8gJzw9JyA6ICc+PSc7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBkID0gY29vcmRzLno7XFxuXFxuICAgICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy54eSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG4gICAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WCh4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAvLyBJZiBhIG1pbiAvIG1heCB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB1c2UgaXQuIElmIG5vdCxcXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICB2YWx1ZSwgbWluTWF4VmFsdWUsIG1pbk1heFZhbHVlRm91bmQpO1xcbiAgICAgICAgICAgICAgaWYgKHZhbHVlIFwiICsgY29tcGFyZU9wXzEgKyBcIiBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3UiAqIFwiICsgZmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyZU9wID0gcG9vbFR5cGUgPT09ICdtaW4nID8gJ21pbicgOiAnbWF4JztcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgKyBwb29sVHlwZSArIFwiKFwiICtcbiAgICAgICAgICAgICdtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKSc7XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJhdmdWYWx1ZSAvIFwiICsgZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggKyBcIi4wXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGZpbHRlcldpZHRoIC8gNCkgKiA0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID0gZmlsdGVyV2lkdGggJSA0O1xuICAgICAgICB2YXIgdXBkYXRlU25pcHBldCA9IFwiXFxuICAgICAgaWYgKGhhc05hTih2YWx1ZXMpKSB7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0TmFOKHZhbHVlcykpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBpZiAoXCIgKyBpc0F2Z1Bvb2wgKyBcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIgKyBjb21wYXJlT3AgKyBcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBnZXRYKHhSLCB4QywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy54eSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiKTtcXG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ICsgXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMywgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgICAgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUG9vbDJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBvb2wyRFByb2dyYW0gPSBQb29sMkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9vbF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVkdWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplO1xuICAgICAgICB2YXIgaW5TaXplID0gcmVkdWNlSW5mby5pblNpemU7XG4gICAgICAgIHZhciBvdXRTaXplID0gTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBpc1JlZHVjZVN1bSA9IHJlZHVjZVR5cGUgPT09ICdzdW0nO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzUmVkdWNlU3VtKSB7XG4gICAgICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSByZWR1Y2VUeXBlID09PSAnbWluJyA/ICdtaW4nIDogJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJzdW1WYWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dTaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHdpbmRvd1NpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciB3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9IHdpbmRvd1NpemUgJSA0O1xuICAgICAgICB2YXIgdXBkYXRlU25pcHBldCA9IFwiXFxuICAgICAgaWYgKFwiICsgaXNSZWR1Y2VTdW0gKyBcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChoYXNOYU4odmFsdWVzKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0TmFOKHZhbHVlcykpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja091dE9mQm91bmRzID0gXCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIgKyBpblNpemUgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIiArIGNoZWNrT3V0T2ZCb3VuZHMgKyBcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlZHVjZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VQcm9ncmFtID0gUmVkdWNlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRSZW5kZXJSR0JTaGFkZXIoZ3BncHUsIGRlc3RpbmF0aW9uV2lkdGgpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHNvdXJjZTtcXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICBjb25zdCBmbG9hdCBkZXN0aW5hdGlvbldpZHRoID0gXCIgKyBkZXN0aW5hdGlvbldpZHRoICsgXCIuMDtcXG4gICAgY29uc3QgZmxvYXQgYSA9IDEuMDtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGZsb2F0IHhyID0gZmxvb3IocmVzdWx0VVYucyAqIGRlc3RpbmF0aW9uV2lkdGgpICogMy4wO1xcbiAgICAgIHZlYzMgeCA9IHhyICsgdmVjMygwLCAxLCAyKTtcXG5cXG4gICAgICBmbG9hdCBzb3VyY2VXaWR0aCA9IGRlc3RpbmF0aW9uV2lkdGggKiAzLjA7XFxuICAgICAgdmVjMyB1ID0gKHggKyAwLjUpIC8gc291cmNlV2lkdGg7XFxuICAgICAgZmxvYXQgdiA9IDEuMCAtIHJlc3VsdFVWLnQ7XFxuXFxuICAgICAgZmxvYXQgciA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVswXSwgdikpLnI7XFxuICAgICAgZmxvYXQgZyA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVsxXSwgdikpLnI7XFxuICAgICAgZmxvYXQgYiA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVsyXSwgdikpLnI7XFxuXFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyLCBnLCBiLCBhKTtcXG4gICAgfVwiO1xuICAgIHJldHVybiBncGdwdS5jcmVhdGVQcm9ncmFtKGZyYWdtZW50U2hhZGVyU291cmNlKTtcbn1cbmV4cG9ydHMuZ2V0UmVuZGVyUkdCU2hhZGVyID0gZ2V0UmVuZGVyUkdCU2hhZGVyO1xuZnVuY3Rpb24gcmVuZGVyVG9DYW52YXMoZ3BncHUsIHJlbmRlclNoYWRlciwgc291cmNlVGV4KSB7XG4gICAgd2ViZ2xfdXRpbC5iaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihncGdwdS5nbCk7XG4gICAgcmVuZGVyVG9GcmFtZWJ1ZmZlcihncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpO1xufVxuZXhwb3J0cy5yZW5kZXJUb0NhbnZhcyA9IHJlbmRlclRvQ2FudmFzO1xuZnVuY3Rpb24gcmVuZGVyVG9GcmFtZWJ1ZmZlcihncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpIHtcbiAgICBncGdwdS5zZXRQcm9ncmFtKHJlbmRlclNoYWRlcik7XG4gICAgdmFyIHNvdXJjZVNhbXBsZXJMb2NhdGlvbiA9IHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZ3BncHUuZ2wsIHJlbmRlclNoYWRlciwgJ3NvdXJjZScpO1xuICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShzb3VyY2VUZXgsIHNvdXJjZVNhbXBsZXJMb2NhdGlvbiwgMCk7XG4gICAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbmV4cG9ydHMucmVuZGVyVG9GcmFtZWJ1ZmZlciA9IHJlbmRlclRvRnJhbWVidWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXJfbmRhcnJheV9ncHVfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXNpemVCaWxpbmVhcjNEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplQmlsaW5lYXIzRFByb2dyYW0oaW5wdXRTaGFwZSwgb3V0cHV0RGltZW5zaW9uc1Jvd0NvbCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciBkZXB0aCA9IGlucHV0U2hhcGVbMl07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPVxuICAgICAgICAgICAgW291dHB1dERpbWVuc2lvbnNSb3dDb2xbMF0sIG91dHB1dERpbWVuc2lvbnNSb3dDb2xbMV0sIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2hhcGUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICAgICAgW2lucHV0U2hhcGVbMF0gLSAxLCBpbnB1dFNoYXBlWzFdIC0gMSwgZGVwdGhdIDpcbiAgICAgICAgICAgIGlucHV0U2hhcGU7XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRwdXRTaGFwZSA9IGFsaWduQ29ybmVycyA/XG4gICAgICAgICAgICBbdGhpcy5vdXRwdXRTaGFwZVswXSAtIDEsIHRoaXMub3V0cHV0U2hhcGVbMV0gLSAxLCBkZXB0aF0gOlxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJbnB1dFNoYXBlWzBdIC8gZWZmZWN0aXZlT3V0cHV0U2hhcGVbMF0gKyBcIixcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJbnB1dFNoYXBlWzFdIC8gZWZmZWN0aXZlT3V0cHV0U2hhcGVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiICsgaW5wdXRTaGFwZVswXSArIFwiLjAsIFwiICsgaW5wdXRTaGFwZVsxXSArIFwiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnh5O1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVCaWxpbmVhcjNEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtID0gUmVzaXplQmlsaW5lYXIzRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemVfYmlsaW5lYXJfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgdGV4X3V0aWxfMSA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xuZnVuY3Rpb24gbWFrZVNoYWRlcihpbnB1dHNJbmZvLCBvdXRwdXRTaGFwZSwgdXNlckNvZGUsIGJyb2FkY2FzdCkge1xuICAgIHZhciBzYW1wbGVTbmlwcGV0ID0gZ2V0U2FtcGxlU25pcHBldCgpO1xuICAgIHZhciBzZXRPdXRwdXRTbmlwcGV0ID0gZ2V0U2V0T3V0cHV0U25pcHBldCgpO1xuICAgIHZhciBpbnB1dFByZWZpeFNuaXBwZXQgPSBpbnB1dHNJbmZvLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gXCJ1bmlmb3JtIHNhbXBsZXIyRCBcIiArIHgubmFtZSArIFwiO1wiOyB9KS5qb2luKCdcXG4nKTtcbiAgICB2YXIgaW5wdXRTYW1wbGluZ1NuaXBwZXQgPSBpbnB1dHNJbmZvLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoeCwgb3V0cHV0U2hhcGUsIGJyb2FkY2FzdCk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXRTaGFwZS50ZXhTaGFwZTtcbiAgICB2YXIgb3V0cHV0U2FtcGxpbmdTbmlwcGV0ID0gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dFNoYXBlLmxvZ2ljYWxTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgIHZhciBzb3VyY2UgPSBbXG4gICAgICAgIFNIQURFUl9QUkVGSVgsIHNhbXBsZVNuaXBwZXQsIHNldE91dHB1dFNuaXBwZXQsIGlucHV0UHJlZml4U25pcHBldCxcbiAgICAgICAgb3V0cHV0U2FtcGxpbmdTbmlwcGV0LCBpbnB1dFNhbXBsaW5nU25pcHBldCwgdXNlckNvZGVcbiAgICBdLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBzb3VyY2U7XG59XG5leHBvcnRzLm1ha2VTaGFkZXIgPSBtYWtlU2hhZGVyO1xuZnVuY3Rpb24gZ2V0U2FtcGxlU25pcHBldCgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSA/XG4gICAgICAgIEZMT0FUX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgOlxuICAgICAgICBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQ7XG59XG5mdW5jdGlvbiBnZXRTZXRPdXRwdXRTbmlwcGV0KCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpID9cbiAgICAgICAgRkxPQVRfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA6XG4gICAgICAgIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVDtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGcm9tSW5JbmZvKGluSW5mbykge1xuICAgIHZhciBzaGFwZSA9IGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyU2NhbGFyKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyMUQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIyRChpbkluZm8pO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjNEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyNEQoaW5JbmZvKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzaGFwZS5sZW5ndGggKyBcIi1EIGlucHV0IHNhbXBsaW5nXCIgK1xuICAgICAgICAgICAgICAgIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KGluSW5mbywgb3V0U2hhcGVJbmZvLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgcmVzID0gZ2V0U2FtcGxlckZsYXQoaW5JbmZvKTtcbiAgICByZXMgKz0gZ2V0U2FtcGxlckZyb21JbkluZm8oaW5JbmZvKTtcbiAgICBpZiAoYnJvYWRjYXN0IHx8XG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoaW5JbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpKSB7XG4gICAgICAgIHJlcyArPSBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5JbmZvLCBvdXRTaGFwZUluZm8sIGJyb2FkY2FzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0U2hhcGUsIG91dFRleFNoYXBlKSB7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0MURDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDJEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQzRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0NERDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdXRTaGFwZS5sZW5ndGggKyBcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG52YXIgU0FNUExFXzFEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8yRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IG51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCBpbmRleCA9IHJvdyAqIG51bUMgKyBjb2w7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfM0RfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzREX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tNEQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCBzdHJpZGUyLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgIGludCBkZXB0aDIpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGggKiBzdHJpZGUyICsgZGVwdGgyO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgVU5TSUdORURfQllURV9URVhUVVJFX1NBTVBMRV9TTklQUEVUID0gXCJcXG4gIHVuaWZvcm0gZmxvYXQgTmFOO1xcblxcbiAgY29uc3QgdmVjNCBmbG9hdERlbHRhcyA9IHZlYzQoXFxuICAgICAgMS4wLFxcbiAgICAgIDEuMCAvIDI1NS4wLFxcbiAgICAgIDEuMCAvICgyNTUuMCAqIDI1NS4wKSxcXG4gICAgICAxLjAgLyAoMjU1LjAgKiAyNTUuMCAqIDI1NS4wKVxcbiAgKTtcXG4gIGNvbnN0IGZsb2F0IG1pblZhbHVlID0gXCIgKyB0ZXhfdXRpbC5GTE9BVF9NSU4gKyBcIi4wO1xcbiAgY29uc3QgZmxvYXQgbWF4VmFsdWUgPSBcIiArIHRleF91dGlsLkZMT0FUX01BWCArIFwiLjA7XFxuICBjb25zdCBmbG9hdCByYW5nZSA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIDI1NS4wO1xcbiAgY29uc3QgdmVjMiBkb3RSYW5nZSA9IHZlYzIoMS4wLCByYW5nZSk7XFxuXFxuICBmbG9hdCBzYW1wbGUoc2FtcGxlcjJEIHRleHR1cmUsIHZlYzIgdXYpIHtcXG4gICAgdmVjNCBzYW1wbGVWYWx1ZSA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dik7XFxuICAgIGlmIChhbGwoZXF1YWwoc2FtcGxlVmFsdWUsIHZlYzQoXCIgKyB0ZXhfdXRpbC5CWVRFX05BTl9WQUxVRSArIFwiKSkpKSB7XFxuICAgICAgcmV0dXJuIE5hTjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IGVuY1ZhbHVlID0gZmxvb3Ioc2FtcGxlVmFsdWUgKiAyNTUuMCArIDAuNSk7XFxuICAgIGZsb2F0IGRlY29kZWRWYWx1ZSA9IGRvdChlbmNWYWx1ZSwgZmxvYXREZWx0YXMpO1xcbiAgICByZXR1cm4gZG90KHZlYzIobWluVmFsdWUsIGRlY29kZWRWYWx1ZSksIGRvdFJhbmdlKTtcXG4gIH1cXG5cIjtcbnZhciBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgPSBcIlxcbiAgY29uc3QgdmVjNCBmbG9hdFBvd2VycyA9IHZlYzQoXFxuICAgIDEuMCxcXG4gICAgMjU1LjAsXFxuICAgIDI1NS4wICogMjU1LjAsXFxuICAgIDI1NS4wICogMjU1LjAgKiAyNTUuMFxcbiAgKTtcXG4gIGNvbnN0IHZlYzIgcmVjaXBSYW5nZSA9IHZlYzIoMS4wL3JhbmdlKTtcXG4gIGNvbnN0IHZlYzIgcmVjaXBSYW5nZTI1NSA9IHZlYzIoMS4wLyhtYXhWYWx1ZSAtIG1pblZhbHVlKSk7XFxuXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCBkZWNvZGVkVmFsdWUpIHtcXG4gICAgaWYgKGlzTmFOKGRlY29kZWRWYWx1ZSkpIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KFwiICsgdGV4X3V0aWwuQllURV9OQU5fVkFMVUUgKyBcIik7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGEgPSBkb3QodmVjMihkZWNvZGVkVmFsdWUsIC1taW5WYWx1ZSksIHJlY2lwUmFuZ2UpO1xcbiAgICBmbG9hdCBiID0gZnJhY3QoYSkgKiAyNTUuMDtcXG4gICAgZmxvYXQgYyA9IGZyYWN0KGIpICogMjU1LjA7XFxuICAgIGZsb2F0IGQgPSBmcmFjdChjKSAqIDI1NS4wO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBmbG9vcih2ZWM0KGEsIGIsIGMsIGQpKSAvIDI1NS4wO1xcblxcbiAgICAvLyBUT0RPKGRzbWlsa292KTogVmVyc2lvbiBhYm92ZSBnZXRzIGJldHRlciBhY2N1cmFjeSBidXQgcHJvYmFibHkgc2xvd2VyXFxuICAgIC8vIHRoYW4gdGhlIHZlcnNpb24gYmVsb3cuIEJlbmNobWFyayB0byBkZXRlcm1pbmUgaWYgdGhlIGFjY3VyYWN5IGlzIHdvcnRoXFxuICAgIC8vIHRoZSBjb3N0LlxcblxcbiAgICAvLyBmbG9hdCBub3JtVmFsdWUgPSBkb3QodmVjMihkZWNvZGVkVmFsdWUsIC1taW5WYWx1ZSksIHJlY2lwUmFuZ2UyNTUpO1xcbiAgICAvLyB2ZWM0IGYgPSBub3JtVmFsdWUgKiBmbG9hdFBvd2VycztcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gZmxvb3IoZnJhY3QoZikgKiAyNTUuMCkgLyAyNTUuMDtcXG4gIH1cXG5cIjtcbnZhciBGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVUID0gXCJcXG4gIGZsb2F0IHNhbXBsZShzYW1wbGVyMkQgdGV4dHVyZSwgdmVjMiB1dikge1xcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xcbiAgfVxcblwiO1xudmFyIEZMT0FUX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgPSBcIlxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gIH1cXG5cIjtcbnZhciBTSEFERVJfUFJFRklYID0gXCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgcmV0dXJuIHZhbCA9PSB2YWwgPyBmYWxzZSA6IHRydWU7XFxuICB9XFxuXFxuICBib29sIGhhc05hTih2ZWM0IHZhbHVlcykge1xcbiAgICByZXR1cm4gYW55KG5vdEVxdWFsKHZhbHVlcywgdmFsdWVzKSk7XFxuICB9XFxuXFxuICBmbG9hdCBnZXROYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGRvdCh2ZWM0KDEpLCB2YWx1ZXMpO1xcbiAgfVxcblxcbiAgaW50IHJvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gIH1cXG5cXG4gIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgfVxcblxcbiAgY29uc3QgdmVjMiByYW5kb21Db25zdCA9IHZlYzIoXFxuICAgIDIzLjE0MDY5MjYzMjc3OTI2LCAvLyBlXnBpIChHZWxmb25kJ3MgY29uc3RhbnQpXFxuICAgICAyLjY2NTE0NDE0MjY5MDIyNSAvLyAyXnNxcnQoMikgKEdlbGZvbmRcXHUyMDEzU2NobmVpZGVyIGNvbnN0YW50KVxcbiAgKTtcXG5cXG4gIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKSB7XFxuICAgICAgcmV0dXJuIGZyYWN0KGNvcyhkb3QocmVzdWx0VVYgKiBzZWVkLCByYW5kb21Db25zdCkpICogMTIzNDUuNjc4OSk7XFxuICB9XFxuXFxuICBmbG9hdCBzYW1wbGVVVkFuZERlcHRoKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2LCBpbnQgZGVwdGgpIHtcXG4gICAgZmxvYXQgdmFsdWU7XFxuICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgdmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLnI7XFxuICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5nO1xcbiAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICB2YWx1ZSA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dikuYjtcXG4gICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgdmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLmE7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgfVxcblxcbiAgXCIgKyBTQU1QTEVfMURfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8yRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzNEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfNERfU05JUFBFVCArIFwiXFxuXCI7XG5mdW5jdGlvbiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0MURDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIiArIHRleFNoYXBlWzBdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDNEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW50IGQgPSBpbmRleCAtIGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0NERDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbmRleCAtPSByICogXCIgKyBzdHJpZGUwICsgXCI7XFxuXFxuICAgICAgaW50IGMgPSBpbmRleCAvIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIGluZGV4IC09IGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG5cXG4gICAgICBpbnQgZCA9IGluZGV4IC8gXCIgKyBzdHJpZGUyICsgXCI7XFxuICAgICAgaW50IGQyID0gaW5kZXggLSBkICogXCIgKyBzdHJpZGUyICsgXCI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQyRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgaGFsZkNSKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMUQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIkZsYXQoaW5kZXgpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIyRChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIHZhciBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0ZXhOdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIHZlYzIgdXYgPSBVVmZyb20yRChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc2hhcGVbMV0gKyBcIiwgcm93LCBjb2wpO1xcbiAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICB9XFxuXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyM0QoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHZhciB0ZXhUeXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXh0dXJlVHlwZTtcbiAgICBpZiAodGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICAgICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICAgICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIHNxdWVlemVkU2hhcGUpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCddO1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTApIHtcbiAgICAgICAgaWYgKHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgICBpbnQgdGV4QyA9IGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICsgZGVwdGg7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLlJHQkFfQ09MT1IpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVVWQW5kRGVwdGgoXCIgKyB0ZXhOYW1lICsgXCIsIHV2LCBkZXB0aCk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFRleHR1cmVUeXBlIFwiICsgdGV4VHlwZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMSAmJiB0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICBpbnQgdGV4QyA9IGRlcHRoO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgdmVjMiB1diA9IFVWZnJvbTNEKFxcbiAgICAgICAgICAgIFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLCByb3csIGNvbCwgZGVwdGgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLlJHQkFfQ09MT1IpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgdmVjMiB1diA9IFVWZnJvbTJEKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzaGFwZVsxXSArIFwiLCByb3csIGNvbCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVVZBbmREZXB0aChcIiArIHRleE5hbWUgKyBcIiwgdXYsIGRlcHRoKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBUZXh0dXJlVHlwZSBcIiArIHRleFR5cGUgKyBcIi5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjREKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMiddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aCAqIFwiICsgc3RyaWRlMiArIFwiICsgZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTIpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IHRleFIgPSByb3cgKiBcIiArIHNoYXBlWzFdICogc2hhcGVbMl0gKyBcIiArIGNvbCAqIFwiICsgc2hhcGVbMl0gKyBcIiArIGRlcHRoO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDI7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTREKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLFxcbiAgICAgICAgICBcIiArIHN0cmlkZTIgKyBcIiwgcm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyRmxhdChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKSArICdGbGF0JztcbiAgICB2YXIgdE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHROdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb20xRChcIiArIHROdW1SICsgXCIsIFwiICsgdE51bUMgKyBcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCB0ZXhGdW5jU25pcHBldCwgZnVuY05hbWUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBvdXRSYW5rID0gb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIHR5cGUgPSAnaW50JztcbiAgICBpZiAob3V0UmFuayA9PT0gMikge1xuICAgICAgICB0eXBlID0gJ2l2ZWMyJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA9PT0gMykge1xuICAgICAgICB0eXBlID0gJ2l2ZWMzJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA9PT0gNCkge1xuICAgICAgICB0eXBlID0gJ2l2ZWM0JztcbiAgICB9XG4gICAgdmFyIGJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKTtcbiAgICB2YXIgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICAgIHZhciBjb29yZHNTbmlwcGV0O1xuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9XG4gICAgICAgICAgICBicm9hZGNhc3REaW1zLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJjb29yZHNbXCIgKyAoZCArIHJhbmtEaWZmKSArIFwiXSA9IDA7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICB2YXIgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gXCJjb29yZHNbXCIgKyAoaSArIHJhbmtEaWZmKSArIFwiXVwiOyB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIgKyBjb29yZHNTbmlwcGV0ICsgXCJcXG4gICAgICByZXR1cm4gZ2V0XCIgKyB0ZXhGdW5jU25pcHBldCArIFwiKFwiICsgdW5wYWNrZWRDb29yZHNTbmlwcGV0ICsgXCIpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgc3VwcG9ydHNCcm9hZGNhc3RpbmcpIHtcbiAgICB2YXIgaW5UZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgaXNSR0JBQ29sb3JUZXh0dXJlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXh0dXJlVHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5SR0JBX0NPTE9SO1xuICAgIHZhciB0ZXhGdW5jU25pcHBldCA9IHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4RnVuY1NuaXBwZXQgKyAnQXRPdXRDb29yZHMnO1xuICAgIHZhciBicm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBkb0Jyb2FkY2FzdCA9IHN1cHBvcnRzQnJvYWRjYXN0aW5nICYmICgob3V0UmFuayA+IGluUmFuaykgfHwgYnJvYWRjYXN0RGltcy5sZW5ndGggPiAwKTtcbiAgICB2YXIgYnJvYWRjYXN0T3Zlck91dGVyID0gYnJvYWRjYXN0X3V0aWwuYnJvYWRjYXN0RGltc0FyZU91dGVyKGJyb2FkY2FzdERpbXMpO1xuICAgIGlmIChkb0Jyb2FkY2FzdCAmJiAhYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCB0ZXhGdW5jU25pcHBldCwgZnVuY05hbWUpO1xuICAgIH1cbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRTaGFwZUluZm8udGV4U2hhcGU7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpICYmICFpc1JHQkFDb2xvclRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBpblRleEV4cGFuZGVkU2hhcGUgPSBpc1JHQkFDb2xvclRleHR1cmUgP1xuICAgICAgICBbaW5UZXhTaGFwZVswXSwgaW5UZXhTaGFwZVsxXSAqIGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlWzJdXSA6XG4gICAgICAgIGluVGV4U2hhcGU7XG4gICAgdmFyIHNhbXBsZVNuaXBwZXQgPSBcInJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcIjtcbiAgICB2YXIgcmdiYUNvbG9yU25pcHBldCA9ICcnO1xuICAgIGlmIChpc1JHQkFDb2xvclRleHR1cmUpIHtcbiAgICAgICAgcmdiYUNvbG9yU25pcHBldCA9IFwiXFxuICAgICAgaW50IGNvbCA9IHRleEMgLyBcIiArIGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlWzJdICsgXCI7XFxuICAgICAgaW50IHRleEQgPSB0ZXhDIC0gY29sICogXCIgKyBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVsyXSArIFwiO1xcbiAgICAgIHRleEMgPSBjb2w7XFxuICAgIFwiO1xuICAgICAgICBzYW1wbGVTbmlwcGV0ID0gXCJyZXR1cm4gc2FtcGxlVVZBbmREZXB0aChcIiArIHRleE5hbWUgKyBcIiwgdXYsIHRleEQpO1wiO1xuICAgIH1cbiAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGluVGV4RXhwYW5kZWRTaGFwZSk7XG4gICAgdmFyIGJyb2FkY2FzdFNuaXBwZXQgPSAnJztcbiAgICBpZiAoZG9Ccm9hZGNhc3QgJiYgYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIGJyb2FkY2FzdFNuaXBwZXQgPSBcIlxcbiAgICAgICAgaW50IG1haW5QYXJ0ID0gaW5kZXggLyBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgICAgaW5kZXggLT0gbWFpblBhcnQgKiBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIG91dFRleFNoYXBlWzBdICsgXCIsIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIG91dFRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiICsgYnJvYWRjYXN0U25pcHBldCArIFwiXFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiICsgaW5UZXhFeHBhbmRlZFNoYXBlWzFdICsgXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIiArIGluVGV4RXhwYW5kZWRTaGFwZVsxXSArIFwiO1xcblxcbiAgICAgIFwiICsgcmdiYUNvbG9yU25pcHBldCArIFwiXFxuXFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgaW5UZXhTaGFwZVsxXSArIFwiLjAsIFwiICsgaW5UZXhTaGFwZVswXSArIFwiLjApO1xcblxcbiAgICAgIFwiICsgc2FtcGxlU25pcHBldCArIFwiXFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0Q29vcmRzRGF0YVR5cGUocmFuaykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ2l2ZWMyJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2l2ZWMzJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ2l2ZWM0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiR1BVIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZTtcbmZ1bmN0aW9uIHNxdWVlemVJbnB1dEluZm8oaW5JbmZvLCBzcXVlZXplZFNoYXBlKSB7XG4gICAgdmFyIG5ld0lucHV0SW5mbyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5JbmZvKSk7XG4gICAgbmV3SW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUgPSBzcXVlZXplZFNoYXBlO1xuICAgIHJldHVybiBuZXdJbnB1dEluZm87XG59XG5mdW5jdGlvbiBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSB7XG4gICAgcmV0dXJuIGtlcHREaW1zLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyYW1zW2RdOyB9KS5qb2luKCcsICcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyX2NvbXBpbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFNsaWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VQcm9ncmFtKGRlc3RTaXplKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBkZXN0U2l6ZTtcbiAgICAgICAgdGhpcy5yYW5rID0gZGVzdFNpemUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMucmFuayk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gXCIgKyBkdHlwZSArIFwiIHN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2MgPSBzdGFydCArIGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgU2xpY2VQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gdGhpcy5yYW5rKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIiArIHRoaXMucmFuayArIFwiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHN0YXJ0IChcIiArIHN0YXJ0Lmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtM2koX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm00aShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSwgc3RhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgX3RoaXMucmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlNsaWNlUHJvZ3JhbSA9IFNsaWNlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnonO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueiwgc291cmNlTG9jLncnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZXh0dXJlVHlwZTtcbihmdW5jdGlvbiAoVGV4dHVyZVR5cGUpIHtcbiAgICBUZXh0dXJlVHlwZVtUZXh0dXJlVHlwZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgIFRleHR1cmVUeXBlW1RleHR1cmVUeXBlW1wiUkdCQV9DT0xPUlwiXSA9IDFdID0gXCJSR0JBX0NPTE9SXCI7XG59KShUZXh0dXJlVHlwZSA9IGV4cG9ydHMuVGV4dHVyZVR5cGUgfHwgKGV4cG9ydHMuVGV4dHVyZVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtjb2x1bW5zLCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeFNpemUsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHJldHVybiBtYXRyaXhTaXplICogY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuZXhwb3J0cy5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplID0gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZTtcbmZ1bmN0aW9uIGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucyAqIDQsIHJvd3NdO1xufVxuZXhwb3J0cy5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUodW5wYWNrZWRTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICBpZiAodW5wYWNrZWRTaXplICUgY2hhbm5lbHNQZXJUZXh0dXJlICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucGFja2VkU2l6ZSAoXCIgKyB1bnBhY2tlZFNpemUgKyBcIikgbXVzdCBiZSBhIG11bHRpcGxlIG9mIFwiICtcbiAgICAgICAgICAgIChcIlwiICsgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiB1bnBhY2tlZFNpemUgLyBjaGFubmVsc1BlclRleHR1cmU7XG59XG5leHBvcnRzLmdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplO1xuZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAodW5wYWNrZWRBcnJheS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRBcnJheSBsZW5ndGggKFwiICsgdW5wYWNrZWRBcnJheS5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArXG4gICAgICAgICAgICAoXCJcIiArIHJlcXVpcmVkU2l6ZSkpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCBtYXRyaXgubGVuZ3RoOyArK3NyYykge1xuICAgICAgICB1bnBhY2tlZEFycmF5W2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgZHN0ICs9IGNoYW5uZWxzUGVyVGV4dHVyZTtcbiAgICB9XG59XG5leHBvcnRzLmVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheSA9IGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheTtcbmV4cG9ydHMuRkxPQVRfTUFYID0gMjAwMDA7XG5leHBvcnRzLkZMT0FUX01JTiA9IC1leHBvcnRzLkZMT0FUX01BWDtcbnZhciBGTE9BVF9SQU5HRSA9IChleHBvcnRzLkZMT0FUX01BWCAtIGV4cG9ydHMuRkxPQVRfTUlOKSAvIDI1NTtcbnZhciBGTE9BVF9ERUxUQVMgPSBbMSwgMSAvIDI1NSwgMSAvICgyNTUgKiAyNTUpLCAxIC8gKDI1NSAqIDI1NSAqIDI1NSldO1xudmFyIEZMT0FUX1BPV0VSUyA9IFsxLCAyNTUsIDI1NSAqIDI1NV07XG5leHBvcnRzLkJZVEVfTkFOX1ZBTFVFID0gMDtcbmZ1bmN0aW9uIGVuY29kZUZsb2F0QXJyYXkoZmxvYXRBcnJheSkge1xuICAgIHZhciB1aW50QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdEFycmF5Lmxlbmd0aCAqIDQpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZmxvYXRBcnJheVtpIC8gNF07XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDFdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMl0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAzXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSAodmFsdWUgLSBleHBvcnRzLkZMT0FUX01JTikgLyBGTE9BVF9SQU5HRTtcbiAgICAgICAgdmFyIGVuYyA9IEZMT0FUX1BPV0VSUy5tYXAoZnVuY3Rpb24gKHBvdykgeyByZXR1cm4gcG93ICogbm9ybWFsaXplZFZhbHVlOyB9KTtcbiAgICAgICAgdmFyIGJ1Y2tldHMgPSBlbmMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTWF0aC5mbG9vcigodmFsdWUgJSAxKSAqIDI1NSk7IH0pO1xuICAgICAgICB1aW50QXJyYXlbaV0gPSBNYXRoLmZsb29yKG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIHVpbnRBcnJheVtpICsgMV0gPSBidWNrZXRzWzBdO1xuICAgICAgICB1aW50QXJyYXlbaSArIDJdID0gYnVja2V0c1sxXTtcbiAgICAgICAgdWludEFycmF5W2kgKyAzXSA9IGJ1Y2tldHNbMl07XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnRBcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdWludEFycmF5O1xufVxuZXhwb3J0cy5lbmNvZGVGbG9hdEFycmF5ID0gZW5jb2RlRmxvYXRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZVRvRmxvYXRBcnJheSh1aW50QXJyYXkpIHtcbiAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodWludEFycmF5Lmxlbmd0aCAvIDQpO1xuICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKHVpbnRBcnJheVtpXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAxXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAyXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAzXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSkge1xuICAgICAgICAgICAgZmxvYXRBcnJheVtpIC8gNF0gPSBOYU47XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb3QgPSAwO1xuICAgICAgICBGTE9BVF9ERUxUQVMuZm9yRWFjaChmdW5jdGlvbiAoZGVsdGEsIGopIHtcbiAgICAgICAgICAgIGRvdCArPSBkZWx0YSAqIHVpbnRBcnJheVtpICsgal07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmFsdWUgPSBkb3QgKiBGTE9BVF9SQU5HRSArIGV4cG9ydHMuRkxPQVRfTUlOO1xuICAgICAgICBmbG9hdEFycmF5W2kgLyA0XSA9IHZhbHVlO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50QXJyYXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgX2xvb3BfMihpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsb2F0QXJyYXk7XG59XG5leHBvcnRzLmRlY29kZVRvRmxvYXRBcnJheSA9IGRlY29kZVRvRmxvYXRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KHVucGFja2VkQXJyYXksIG1hdHJpeCwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUodW5wYWNrZWRBcnJheS5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB1bnBhY2tlZEFycmF5Lmxlbmd0aDsgc3JjICs9IGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgICAgICBtYXRyaXhbZHN0KytdID0gdW5wYWNrZWRBcnJheVtzcmNdO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkgPSBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5KHVucGFja2VkQXJyYXksIG1hdHJpeCwgY2hhbm5lbHMpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gdW5wYWNrZWRBcnJheS5sZW5ndGggKiBjaGFubmVscyAvIDQ7XG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB1bnBhY2tlZEFycmF5Lmxlbmd0aDsgc3JjICs9IDQpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gdW5wYWNrZWRBcnJheVtzcmMgKyBjXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkgPSBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheTtcbmZ1bmN0aW9uIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW01hdGguY2VpbChjb2x1bW5zIC8gMiksIE1hdGguY2VpbChyb3dzIC8gMildO1xufVxuZXhwb3J0cy5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHJldHVybiB3ICogaCAqIDQ7XG59XG5leHBvcnRzLmdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUgPSBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlO1xuZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpO1xuICAgIGlmIChwYWNrZWRSR0JBLmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWNrZWRSR0JBIGxlbmd0aCAoXCIgKyBwYWNrZWRSR0JBLmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHRleHR1cmVXaWR0aCA9IF9hWzBdLCB0ZXh0dXJlSGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgICB2YXIgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgICB2YXIgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgICB2YXIgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gICAge1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gKG9kZFdpZHRoID8gNCA6IDApO1xuICAgICAgICB2YXIgb25lUm93ID0gY29sdW1ucztcbiAgICAgICAgdmFyIGRzdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXhTcmNSb3cgPSAoYmxvY2tZICogMiAqIGNvbHVtbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeFNyY0NvbCA9IGJsb2NrWCAqIDI7XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IG1hdHJpeFNyY1JvdyArIG1hdHJpeFNyY0NvbDtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDFdID0gbWF0cml4W3NyYyArIDFdO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMl0gPSBtYXRyaXhbc3JjICsgb25lUm93XTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDNdID0gbWF0cml4W3NyYyArIG9uZVJvdyArIDFdO1xuICAgICAgICAgICAgICAgIGRzdCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGgpIHtcbiAgICAgICAgdmFyIHNyYyA9IGNvbHVtbnMgLSAxO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIGNvbHVtbnNdO1xuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZEhlaWdodCkge1xuICAgICAgICB2YXIgc3JjID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCsrXSA9IG1hdHJpeFtzcmMrK107XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCsrXSA9IG1hdHJpeFtzcmMrK107XG4gICAgICAgICAgICBkc3QgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGggJiYgb2RkSGVpZ2h0KSB7XG4gICAgICAgIHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XSA9IG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBwYWNrZWRSR0JBO1xufVxuZXhwb3J0cy5lbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEgPSBlbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkE7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gcm93cyAqIGNvbHVtbnM7XG4gICAgaWYgKHJlcXVpcmVkU2l6ZSA8IG1hdHJpeC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICAgIHZhciBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICAgIHZhciB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICAgIHZhciBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdGV4dHVyZVdpZHRoID0gX2FbMF0sIHRleHR1cmVIZWlnaHQgPSBfYVsxXTtcbiAgICB7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSBvZGRXaWR0aCA/IDQgOiAwO1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gY29sdW1ucyArIChvZGRXaWR0aCA/IDEgOiAwKTtcbiAgICAgICAgdmFyIHNyYyA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cxID0gMDtcbiAgICAgICAgdmFyIGRzdFJvdzIgPSBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzEgKz0gZHN0U3RyaWRlO1xuICAgICAgICAgICAgZHN0Um93MiArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgICAgICB2YXIgZHN0ID0gY29sdW1ucyAtIDE7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gMiAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3RdID0gcGFja2VkUkdCQVtzcmNdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCArIGNvbHVtbnNdID0gcGFja2VkUkdCQVtzcmMgKyAyXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0ID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgc3JjICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdID0gcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQSA9IGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4dHVyZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKGdwZ3B1KSB7XG4gICAgICAgIHRoaXMuZ3BncHUgPSBncGdwdTtcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzID0ge307XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnQgPSB7fTtcbiAgICB9XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlID0gZnVuY3Rpb24gKHNoYXBlUkMpIHtcbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJDKTtcbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLnVzZWRUZXh0dXJlQ291bnQpKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldKys7XG4gICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdwZ3B1LmNyZWF0ZU1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUucmVsZWFzZVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgc2hhcGUpIHtcbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZSk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnB1c2godGV4dHVyZSk7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzKys7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzLS07XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0tLTtcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5udW1GcmVlVGV4dHVyZXMgKyB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyZWUvVXNlZCcsIHRoaXMubnVtRnJlZVRleHR1cmVzICsgXCIgLyBcIiArIHRoaXMubnVtVXNlZFRleHR1cmVzLCBcIihcIiArIHRvdGFsICsgXCIpXCIpO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bUZyZWVUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHNoYXBlIGluIHRoaXMuZnJlZVRleHR1cmVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXMuaGFzT3duUHJvcGVydHkoc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dHVyZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5UZXh0dXJlTWFuYWdlciA9IFRleHR1cmVNYW5hZ2VyO1xuZnVuY3Rpb24gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJvd3NDb2wpIHtcbiAgICByZXR1cm4gc2hhcGVSb3dzQ29sWzBdICsgXCJfXCIgKyBzaGFwZVJvd3NDb2xbMV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlX21hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVGlsZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQcm9ncmFtKGFTaGFwZSwgcmVwcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMoYVNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVGlsZVByb2dyYW0gPSBUaWxlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhhU2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiaW1vZChyZXNSQywgXCIgKyBhU2hhcGVbMF0gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDb29yZHMgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICB2YXIgc291cmNlQ29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJpbW9kKFwiICsgY3VycmVudENvb3Jkc1tpXSArIFwiLCBcIiArIGFTaGFwZVtpXSArIFwiKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUNvb3Jkcy5qb2luKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBUcmFuc3Bvc2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3Bvc2VQcm9ncmFtKGFTaGFwZSwgbmV3RGltKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2ldID0gYVNoYXBlW25ld0RpbVtpXV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzd2l0Y2hlZCA9IGdldFN3aXRjaGVkQ29vcmRzKG5ld0RpbSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzd2l0Y2hlZCArIFwiKSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3Bvc2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNwb3NlUHJvZ3JhbSA9IFRyYW5zcG9zZVByb2dyYW07XG5mdW5jdGlvbiBnZXRTd2l0Y2hlZENvb3JkcyhuZXdEaW0pIHtcbiAgICB2YXIgcmFuayA9IG5ld0RpbS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVHJhbnNwb3NlIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWxPcmRlciA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzd2l0Y2hlZENvb3JkcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RpbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2hlZENvb3Jkc1tuZXdEaW1baV1dID0gb3JpZ2luYWxPcmRlcltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXRjaGVkQ29vcmRzLmpvaW4oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVW5hcnlPcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuYXJ5T3BQcm9ncmFtKGFTaGFwZSwgb3BTbmlwcGV0KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIiArIG9wU25pcHBldCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlPcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5VbmFyeU9wUHJvZ3JhbSA9IFVuYXJ5T3BQcm9ncmFtO1xuZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCA9IFwiXFxuICBpZiAoaXNOYU4oeCkpIHtcXG4gICAgcmV0dXJuIHg7XFxuICB9XFxuXCI7XG5leHBvcnRzLkFCUyA9IFwiXFxuICByZXR1cm4gYWJzKHgpO1xcblwiO1xuZXhwb3J0cy5SRUxVID0gXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xcblwiO1xuZXhwb3J0cy5FTFUgPSBcIlxcbiAgcmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XFxuXCI7XG5mdW5jdGlvbiBMRUFLWV9SRUxVKGFscGhhKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIHJldHVybiAoeCA+PSAwLjApID8geCA6IFwiICsgYWxwaGEgKyBcIiAqIHg7XFxuICBcIjtcbn1cbmV4cG9ydHMuTEVBS1lfUkVMVSA9IExFQUtZX1JFTFU7XG5mdW5jdGlvbiBTVEVQKGFscGhhKSB7XG4gICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICByZXR1cm4gXCJcXG4gICAgcmV0dXJuICh4ID09IHgpID8gKHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIiArIGFscGhhICsgXCIpKSA6IHg7XFxuICBcIjtcbn1cbmV4cG9ydHMuU1RFUCA9IFNURVA7XG5leHBvcnRzLk5FRyA9IFwiXFxuICByZXR1cm4gLXg7XFxuXCI7XG5leHBvcnRzLkNFSUwgPSBcIlxcbiAgcmV0dXJuIGNlaWwoeCk7XFxuXCI7XG5leHBvcnRzLkZMT09SID0gXCJcXG4gIHJldHVybiBmbG9vcih4KTtcXG5cIjtcbmV4cG9ydHMuRVhQID0gXCJcXG4gIHJldHVybiBleHAoeCk7XFxuXCI7XG5leHBvcnRzLkxPRyA9IFwiXFxuICByZXR1cm4gbG9nKHgpO1xcblwiO1xuZXhwb3J0cy5TUVJUID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gc3FydCh4KTtcXG5cIjtcbmV4cG9ydHMuU0lHTU9JRCA9IFwiXFxuICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1xcblwiO1xuZXhwb3J0cy5TSU4gPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCI7XG5leHBvcnRzLkNPUyA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGNvcyh4KTtcXG5cIjtcbmV4cG9ydHMuVEFOID0gXCJcXG4gIHJldHVybiB0YW4oeCk7XFxuXCI7XG5leHBvcnRzLkFTSU4gPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhc2luKHgpO1xcblwiO1xuZXhwb3J0cy5BQ09TID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYWNvcyh4KTtcXG5cIjtcbmV4cG9ydHMuQVRBTiA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCI7XG5leHBvcnRzLlNJTkggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xuZXhwb3J0cy5DT1NIID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG5leHBvcnRzLlRBTkggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiO1xuZXhwb3J0cy5TUVVBUkUgPSBcIlxcbiAgcmV0dXJuIHggKiB4O1xcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5hcnlvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTUFYX1RFWFRVUkVfU0laRSA9IG51bGw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcykge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGdsO1xuICAgIHZhciB3ZWJnbFZlcnNpb24gPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJnbFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDAgfHwgZ2wgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLicpO1xuICAgIH1cbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzO1xuZnVuY3Rpb24gY2FsbEFuZENoZWNrKGdsLCBmdW5jKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZnVuYygpO1xuICAgIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZXhwb3J0cy5jYWxsQW5kQ2hlY2sgPSBjYWxsQW5kQ2hlY2s7XG52YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKSB7XG4gICAgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZW5hYmxlZDtcbn1cbmV4cG9ydHMuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcgPSBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZztcbmZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihnbCkge1xuICAgIGlmICh3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBFcnJvcjogJyArIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1dlYkdMRXJyb3IgPSBjaGVja1dlYkdMRXJyb3I7XG5mdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5OT19FUlJPUjpcbiAgICAgICAgICAgIHJldHVybiAnTk9fRVJST1InO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9FTlVNJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX1ZBTFVFJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICAgIHJldHVybiAnT1VUX09GX01FTU9SWSc7XG4gICAgICAgIGNhc2UgZ2wuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgICAgcmV0dXJuICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVW5rbm93biBlcnJvciBjb2RlIFwiICsgc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0V2ViR0xFcnJvck1lc3NhZ2UgPSBnZXRXZWJHTEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbk9yVGhyb3coZ2wsIGV4dGVuc2lvbk5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTsgfSwgJ0V4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpO1xufVxuZXhwb3J0cy5nZXRFeHRlbnNpb25PclRocm93ID0gZ2V0RXh0ZW5zaW9uT3JUaHJvdztcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKGZyYWdtZW50U2hhZGVyU291cmNlLCBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXI7XG52YXIgbGluZU51bWJlclJlZ2V4ID0gL0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7XG5mdW5jdGlvbiBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKHNoYWRlclNvdXJjZSwgc2hhZGVySW5mb0xvZykge1xuICAgIHZhciBsaW5lTnVtYmVyUmVnZXhSZXN1bHQgPSBsaW5lTnVtYmVyUmVnZXguZXhlYyhzaGFkZXJJbmZvTG9nKTtcbiAgICBpZiAobGluZU51bWJlclJlZ2V4UmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIgKyBzaGFkZXJJbmZvTG9nKTtcbiAgICAgICAgY29uc29sZS5sb2coc2hhZGVyU291cmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGluZU51bWJlciA9ICtsaW5lTnVtYmVyUmVnZXhSZXN1bHRbMV07XG4gICAgdmFyIHNoYWRlckxpbmVzID0gc2hhZGVyU291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgcGFkID0gc2hhZGVyTGluZXMubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoICsgMjtcbiAgICB2YXIgbGluZXNXaXRoTGluZU51bWJlcnMgPSBzaGFkZXJMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwucmlnaHRQYWQoKGxpbmVOdW1iZXIgKyAxKS50b1N0cmluZygpLCBwYWQpICsgbGluZTtcbiAgICB9KTtcbiAgICB2YXIgbWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc1dpdGhMaW5lTnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZXNXaXRoTGluZU51bWJlcnNbaV0ubGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGJlZm9yZUVycm9yTGluZXMgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZSgwLCBsaW5lTnVtYmVyIC0gMSk7XG4gICAgdmFyIGVycm9yTGluZSA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIgLSAxLCBsaW5lTnVtYmVyKTtcbiAgICB2YXIgYWZ0ZXJFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UobGluZU51bWJlcik7XG4gICAgY29uc29sZS5sb2coYmVmb3JlRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgY29uc29sZS5sb2coc2hhZGVySW5mb0xvZy5zcGxpdCgnXFxuJylbMF0pO1xuICAgIGNvbnNvbGUubG9nKFwiJWMgXCIgKyB1dGlsLnJpZ2h0UGFkKGVycm9yTGluZVswXSwgbWF4TGluZUxlbmd0aCksICdib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3Jyk7XG4gICAgY29uc29sZS5sb2coYWZ0ZXJFcnJvckxpbmVzLmpvaW4oJ1xcbicpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVByb2dyYW0oKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLicpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gY3JlYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMubGlua1Byb2dyYW0gPSBsaW5rUHJvZ3JhbTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmFsaWRhdGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb2dyYW0gPSB2YWxpZGF0ZVByb2dyYW07XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyID0gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyID0gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXI7XG5mdW5jdGlvbiBxdWVyeU1heFRleHR1cmVTaXplKGdsKSB7XG4gICAgaWYgKE1BWF9URVhUVVJFX1NJWkUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbiAgICB9XG4gICAgTUFYX1RFWFRVUkVfU0laRSA9XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpOyB9KTtcbiAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbn1cbmV4cG9ydHMucXVlcnlNYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemU7XG5mdW5jdGlvbiBnZXRDaGFubmVsc1BlclRleHR1cmUoKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiA0O1xufVxuZXhwb3J0cy5nZXRDaGFubmVsc1BlclRleHR1cmUgPSBnZXRDaGFubmVsc1BlclRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVUZXh0dXJlKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG5mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIG1heFRleHR1cmVTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gICAgaWYgKCh3aWR0aCA8PSAwKSB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWQgPSBcIltcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgfVxuICAgIGlmICgod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSkgfHwgKGhlaWdodCA+IG1heFRleHR1cmVTaXplKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHZhciBtYXggPSBcIltcIiArIG1heFRleHR1cmVTaXplICsgXCJ4XCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB0ZXh0dXJlIHNpemUgJyArIHJlcXVlc3RlZCArXG4gICAgICAgICAgICAnIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSAnICsgbWF4ICsgJy4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVGV4dHVyZVNpemUgPSB2YWxpZGF0ZVRleHR1cmVTaXplO1xuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuJyk7XG59XG5leHBvcnRzLmNyZWF0ZUZyYW1lYnVmZmVyID0gY3JlYXRlRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGUsIGJ1ZmZlciwgYXJyYXlFbnRyaWVzUGVySXRlbSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzLCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgbG9jID0gLTE7XG4gICAgaWYgKChhdHRyaWJMb2NhdGlvbnMgIT0gbnVsbCkgJiYgKGF0dHJpYnV0ZSBpbiBhdHRyaWJMb2NhdGlvbnMpKSB7XG4gICAgICAgIGxvYyA9IGF0dHJpYkxvY2F0aW9uc1thdHRyaWJ1dGVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICB9XG4gICAgaWYgKGxvYyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCBhcnJheUVudHJpZXNQZXJJdGVtLCBnbC5GTE9BVCwgZmFsc2UsIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcyk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKTsgfSk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUgPSBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlO1xuZnVuY3Rpb24gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVVuaXQgPSBiaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiB1bmJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kVGV4dHVyZVVuaXQgPSB1bmJpbmRUZXh0dXJlVW5pdDtcbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTsgfSwgJ3VuaWZvcm0gXCInICsgdW5pZm9ybU5hbWUgKyAnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3cgPSBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdztcbmZ1bmN0aW9uIGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIoZ2wsIHByb2dyYW0sIHRleHR1cmUsIHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC51bmlmb3JtMWkodW5pZm9ybVNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlciA9IGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI7XG5mdW5jdGlvbiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihnbCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG59XG5leHBvcnRzLmJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyID0gYmluZENhbnZhc1RvRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgdGV4dHVyZSwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlciA9IGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKGdsLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBudWxsLCAwKTsgfSk7XG59XG5leHBvcnRzLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlciA9IHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIHZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICB2YXIgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gICAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiAnICsgZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVGcmFtZWJ1ZmZlciA9IHZhbGlkYXRlRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd24gZXJyb3IgXCIgKyBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZSA9IGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlO1xuZnVuY3Rpb24gdGhyb3dJZk51bGwoZ2wsIHJldHVyblRPck51bGwsIGZhaWx1cmVNZXNzYWdlKSB7XG4gICAgdmFyIHRPck51bGwgPSBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblRPck51bGwoKTsgfSk7XG4gICAgaWYgKHRPck51bGwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbHVyZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdE9yTnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFyIG1heFRleHR1cmVVbml0ID0gZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgLSAxO1xuICAgIHZhciBnbFRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXQgKyBnbC5URVhUVVJFMDtcbiAgICBpZiAoZ2xUZXh0dXJlVW5pdCA8IGdsLlRFWFRVUkUwIHx8IGdsVGV4dHVyZVVuaXQgPiBtYXhUZXh0dXJlVW5pdCkge1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXRSYW5nZSA9IFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIgKyBtYXhUZXh0dXJlVW5pdCArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlVW5pdCBtdXN0IGJlIGluIFwiICsgdGV4dHVyZVVuaXRSYW5nZSArIFwiLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKGdsLCBsb2dTaGFwZSkge1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdmFyIHNxdWVlemVSZXN1bHQgPSB1dGlsLnNxdWVlemVTaGFwZShsb2dTaGFwZSk7XG4gICAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG4gICAgdmFyIG1heFRleFNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShsb2dTaGFwZSk7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW3NpemUsIDFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDIgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBsb2dTaGFwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM10gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUgPSBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2xfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBtYXRoX2NwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoX2NwdVwiKTtcbnZhciBtYXRoX2dwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoX2dwdVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuVEVTVF9FUFNJTE9OID0gMWUtMjtcbmZ1bmN0aW9uIG1lYW4odmFsdWVzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAvIHZhbHVlcy5sZW5ndGg7XG59XG5leHBvcnRzLm1lYW4gPSBtZWFuO1xuZnVuY3Rpb24gc3RhbmRhcmREZXZpYXRpb24odmFsdWVzLCBtZWFuKSB7XG4gICAgdmFyIHNxdWFyZURpZmZTdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaWZmID0gdmFsdWVzW2ldIC0gbWVhbjtcbiAgICAgICAgc3F1YXJlRGlmZlN1bSArPSBkaWZmICogZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVEaWZmU3VtIC8gdmFsdWVzLmxlbmd0aCk7XG59XG5leHBvcnRzLnN0YW5kYXJkRGV2aWF0aW9uID0gc3RhbmRhcmREZXZpYXRpb247XG5mdW5jdGlvbiBrdXJ0b3Npcyh2YWx1ZXMpIHtcbiAgICB2YXIgdmFsdWVzTWVhbiA9IG1lYW4odmFsdWVzKTtcbiAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHN1bTIgPSAwO1xuICAgIHZhciBzdW00ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXSAtIHZhbHVlc01lYW47XG4gICAgICAgIHN1bTIgKz0gTWF0aC5wb3codiwgMik7XG4gICAgICAgIHN1bTQgKz0gTWF0aC5wb3codiwgNCk7XG4gICAgfVxuICAgIHJldHVybiAoMSAvIG4pICogc3VtNCAvIE1hdGgucG93KCgxIC8gbikgKiBzdW0yLCAyKSAtIDM7XG59XG5leHBvcnRzLmt1cnRvc2lzID0ga3VydG9zaXM7XG5mdW5jdGlvbiBza2V3bmVzcyh2YWx1ZXMpIHtcbiAgICB2YXIgdmFsdWVzTWVhbiA9IG1lYW4odmFsdWVzKTtcbiAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHN1bTIgPSAwO1xuICAgIHZhciBzdW0zID0gMDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVzW2ldIC0gdmFsdWVzTWVhbjtcbiAgICAgICAgc3VtMiArPSBNYXRoLnBvdyh2LCAyKTtcbiAgICAgICAgc3VtMyArPSBNYXRoLnBvdyh2LCAzKTtcbiAgICB9XG4gICAgcmV0dXJuICgxIC8gbikgKiBzdW0zIC8gTWF0aC5wb3coKDEgLyAobiAtIDEpKSAqIHN1bTIsIDMgLyAyKTtcbn1cbmV4cG9ydHMuc2tld25lc3MgPSBza2V3bmVzcztcbmZ1bmN0aW9uIGphcnF1ZUJlcmFOb3JtYWxpdHlUZXN0KHZhbHVlcykge1xuICAgIHZhciBzID0gc2tld25lc3ModmFsdWVzKTtcbiAgICB2YXIgayA9IGt1cnRvc2lzKHZhbHVlcyk7XG4gICAgdmFyIGpiID0gdmFsdWVzLmxlbmd0aCAqICgoTWF0aC5wb3cocywgMikgLyA2KSArIChNYXRoLnBvdyhrLCAyKSAvIDI0KSk7XG4gICAgdmFyIENISV9TUVVBUkVfMkRFRyA9IDUuOTkxO1xuICAgIGlmIChqYiA+IENISV9TUVVBUkVfMkRFRykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHAtdmFsdWUgZm9yIEpCOiBcIiArIGpiKTtcbiAgICB9XG59XG5leHBvcnRzLmphcnF1ZUJlcmFOb3JtYWxpdHlUZXN0ID0gamFycXVlQmVyYU5vcm1hbGl0eVRlc3Q7XG5mdW5jdGlvbiBleHBlY3RBcnJheUluTWVhblN0ZFJhbmdlKGFjdHVhbCwgZXhwZWN0ZWRNZWFuLCBleHBlY3RlZFN0ZERldiwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgdmFyIGFjdHVhbE1lYW4gPSBtZWFuKGFjdHVhbCk7XG4gICAgZXhwZWN0TnVtYmVyc0Nsb3NlKGFjdHVhbE1lYW4sIGV4cGVjdGVkTWVhbiwgZXBzaWxvbik7XG4gICAgZXhwZWN0TnVtYmVyc0Nsb3NlKHN0YW5kYXJkRGV2aWF0aW9uKGFjdHVhbCwgYWN0dWFsTWVhbiksIGV4cGVjdGVkU3RkRGV2LCBlcHNpbG9uKTtcbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlJbk1lYW5TdGRSYW5nZSA9IGV4cGVjdEFycmF5SW5NZWFuU3RkUmFuZ2U7XG5mdW5jdGlvbiBleHBlY3RBcnJheXNDbG9zZShhY3R1YWwsIGV4cGVjdGVkLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICB2YXIgYVR5cGUgPSBhY3R1YWwuY29uc3RydWN0b3IubmFtZTtcbiAgICB2YXIgYlR5cGUgPSBleHBlY3RlZC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZSBcIiArIGFUeXBlICsgXCIgdnMgXCIgKyBiVHlwZSk7XG4gICAgfVxuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0cmljZXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyAoXCIgKyBhY3R1YWwubGVuZ3RoICsgXCIgdnMgXCIgK1xuICAgICAgICAgICAgKGV4cGVjdGVkLmxlbmd0aCArIFwiKS5cIikpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhID0gYWN0dWFsW2ldO1xuICAgICAgICB2YXIgZSA9IGV4cGVjdGVkW2ldO1xuICAgICAgICBpZiAoIWFyZUNsb3NlKGEsIGUsIGVwc2lsb24pKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsU3RyID0gXCJhY3R1YWxbXCIgKyBpICsgXCJdID09PSBcIiArIGE7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRTdHIgPSBcImV4cGVjdGVkW1wiICsgaSArIFwiXSA9PT0gXCIgKyBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgZGlmZmVyOiAnICsgYWN0dWFsU3RyICsgJywgJyArIGV4cGVjdGVkU3RyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzQ2xvc2UgPSBleHBlY3RBcnJheXNDbG9zZTtcbmZ1bmN0aW9uIGV4cGVjdE51bWJlcnNDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICBpZiAoIWFyZUNsb3NlKGEsIGUsIGVwc2lsb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiICsgYSArIFwiLCBleHBlY3RlZCA9PT0gXCIgKyBlKTtcbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdE51bWJlcnNDbG9zZSA9IGV4cGVjdE51bWJlcnNDbG9zZTtcbmZ1bmN0aW9uIGFyZUNsb3NlKGEsIGUsIGVwc2lsb24pIHtcbiAgICBpZiAoaXNOYU4oYSkgJiYgaXNOYU4oZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc05hTihhKSB8fCBpc05hTihlKSB8fCBNYXRoLmFicyhhIC0gZSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBleHBlY3RWYWx1ZXNJblJhbmdlKGFjdHVhbCwgbG93LCBoaWdoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFjdHVhbFtpXSA8IGxvdyB8fCBhY3R1YWxbaV0gPiBoaWdoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2U6XCIgKyBhY3R1YWxbaV0gKyBcIiBsb3c6IFwiICsgbG93ICsgXCIsIGhpZ2g6IFwiICsgaGlnaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdFZhbHVlc0luUmFuZ2UgPSBleHBlY3RWYWx1ZXNJblJhbmdlO1xuZnVuY3Rpb24gcmFuZG9tQXJyYXlJblJhbmdlKG4sIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIHZhciB2ID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICB2YXIgcmFuZ2UgPSBtYXhWYWx1ZSAtIG1pblZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZbaV0gPSAoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSArIG1pblZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmV4cG9ydHMucmFuZG9tQXJyYXlJblJhbmdlID0gcmFuZG9tQXJyYXlJblJhbmdlO1xuZnVuY3Rpb24gbWFrZUlkZW50aXR5KG4pIHtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG4pO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGlbKGogKiBuKSArIGpdID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5leHBvcnRzLm1ha2VJZGVudGl0eSA9IG1ha2VJZGVudGl0eTtcbmZ1bmN0aW9uIGNwdU11bHRpcGx5TWF0cml4KGEsIGFSb3csIGFDb2wsIGIsIGJSb3csIGJDb2wpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhUm93ICogYkNvbCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBhUm93OyArK3IpIHtcbiAgICAgICAgdmFyIGFPZmZzZXQgPSAociAqIGFDb2wpO1xuICAgICAgICB2YXIgY09mZnNldCA9IChyICogYkNvbCk7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYkNvbDsgKytjKSB7XG4gICAgICAgICAgICB2YXIgZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFDb2w7ICsraykge1xuICAgICAgICAgICAgICAgIGQgKz0gYVthT2Zmc2V0ICsga10gKiBiWyhrICogYkNvbCkgKyBjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjT2Zmc2V0ICsgY10gPSBkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNwdU11bHRpcGx5TWF0cml4ID0gY3B1TXVsdGlwbHlNYXRyaXg7XG5mdW5jdGlvbiBjcHVEb3RQcm9kdWN0KGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3B1RG90UHJvZHVjdDogaW5jb21wYXRpYmxlIHZlY3RvcnMuJyk7XG4gICAgfVxuICAgIHZhciBkID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZCArPSBhW2ldICogYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59XG5leHBvcnRzLmNwdURvdFByb2R1Y3QgPSBjcHVEb3RQcm9kdWN0O1xuZnVuY3Rpb24gZGVzY3JpYmVNYXRoQ1BVKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QpIHtcbiAgICB2YXIgdGVzdE5hbWVCYXNlID0gJ21hdGhfY3B1LicgKyBuYW1lO1xuICAgIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cywgZnVuY3Rpb24gKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpIHsgcmV0dXJuIGV4ZWN1dGVNYXRoVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgbWF0aF9jcHVfMS5OREFycmF5TWF0aENQVSgpOyB9LCBmZWF0dXJlcyk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlTWF0aENQVSA9IGRlc2NyaWJlTWF0aENQVTtcbmZ1bmN0aW9uIGRlc2NyaWJlTWF0aEdQVShuYW1lLCB0ZXN0cywgZmVhdHVyZXNMaXN0KSB7XG4gICAgdmFyIHRlc3ROYW1lQmFzZSA9ICdtYXRoX2dwdS4nICsgbmFtZTtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGZ1bmN0aW9uICh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKSB7IHJldHVybiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IG1hdGhfZ3B1XzEuTkRBcnJheU1hdGhHUFUoKTsgfSwgZmVhdHVyZXMpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZU1hdGhHUFUgPSBkZXNjcmliZU1hdGhHUFU7XG5mdW5jdGlvbiBkZXNjcmliZUN1c3RvbShuYW1lLCB0ZXN0cywgZmVhdHVyZXNMaXN0LCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gpIHtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKG5hbWUsIFt0ZXN0c10sIGZ1bmN0aW9uICh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKSB7IHJldHVybiBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcywgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoKTsgfSwgZmVhdHVyZXNMaXN0KTtcbn1cbmV4cG9ydHMuZGVzY3JpYmVDdXN0b20gPSBkZXNjcmliZUN1c3RvbTtcbmZ1bmN0aW9uIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cywgZXhlY3V0b3IsIGZlYXR1cmVzTGlzdCkge1xuICAgIGlmIChmZWF0dXJlc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICBmZWF0dXJlc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciB0ZXN0TmFtZSA9IHRlc3ROYW1lQmFzZSArICcgJyArIEpTT04uc3RyaW5naWZ5KGZlYXR1cmVzKTtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMpO1xuICAgIH1cbn1cbnZhciBQUk9NSVNFX0lUID0gZnVuY3Rpb24gKG5hbWUsIHRlc3RGdW5jKSB7XG4gICAgaXQobmFtZSwgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRlc3RGdW5jKCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihkb25lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGZhaWwoZSk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5mdW5jdGlvbiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgbWF0aEZhY3RvcnksIGZlYXR1cmVzKSB7XG4gICAgdmFyIG1hdGg7XG4gICAgdmFyIGN1c3RvbUJlZm9yZUVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hdGggPSBtYXRoRmFjdG9yeSgpO1xuICAgICAgICBtYXRoLnN0YXJ0U2NvcGUoKTtcbiAgICB9O1xuICAgIHZhciBjdXN0b21BZnRlckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hdGguZW5kU2NvcGUobnVsbCk7XG4gICAgICAgIG1hdGguZGlzcG9zZSgpO1xuICAgIH07XG4gICAgdmFyIGN1c3RvbUl0ID0gZnVuY3Rpb24gKG5hbWUsIHRlc3RGdW5jKSB7XG4gICAgICAgIFBST01JU0VfSVQobmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVzdEZ1bmMobWF0aCk7IH0pO1xuICAgIH07XG4gICAgZXhlY3V0ZVRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCwgY3VzdG9tSXQpO1xufVxuZXhwb3J0cy5leGVjdXRlTWF0aFRlc3RzID0gZXhlY3V0ZU1hdGhUZXN0cztcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gsIGN1c3RvbUl0KSB7XG4gICAgaWYgKGN1c3RvbUl0ID09PSB2b2lkIDApIHsgY3VzdG9tSXQgPSBQUk9NSVNFX0lUOyB9XG4gICAgZGVzY3JpYmUodGVzdE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LnNldEVudmlyb25tZW50KG5ldyBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50KGZlYXR1cmVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VzdG9tQmVmb3JlRWFjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQmVmb3JlRWFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjdXN0b21BZnRlckVhY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFmdGVyRWFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5zZXRFbnZpcm9ubWVudChuZXcgZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QpIHsgcmV0dXJuIHRlc3QoY3VzdG9tSXQpOyB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZXhlY3V0ZVRlc3RzID0gZXhlY3V0ZVRlc3RzO1xuZnVuY3Rpb24gYXNzZXJ0SXNOYW4odmFsLCBkdHlwZSkge1xuICAgIGlmICghdXRpbC5pc1ZhbE5hTih2YWwsIGR0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBcIiArIHZhbCArIFwiIGRvZXMgbm90IHJlcHJlc2VudCBOYU4gZm9yIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0SXNOYW4gPSBhc3NlcnRJc05hbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgICB2YXIgY291bnRlciA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGVtcCA9IDA7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoY291bnRlciA+IDApIHtcbiAgICAgICAgaW5kZXggPSAoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpIHwgMDtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgICB0ZW1wID0gYXJyYXlbY291bnRlcl07XG4gICAgICAgIGFycmF5W2NvdW50ZXJdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB0ZW1wO1xuICAgIH1cbn1cbmV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG5mdW5jdGlvbiBjbGFtcChtaW4sIHgsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHgsIG1heCkpO1xufVxuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZnVuY3Rpb24gcmFuZFVuaWZvcm0oYSwgYikge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKGIgLSBhKSArIGE7XG59XG5leHBvcnRzLnJhbmRVbmlmb3JtID0gcmFuZFVuaWZvcm07XG5mdW5jdGlvbiByYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVuY2F0ZWQpIHtcbiAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICBpZiAodHJ1bmNhdGVkID09PSB2b2lkIDApIHsgdHJ1bmNhdGVkID0gZmFsc2U7IH1cbiAgICB2YXIgdjEsIHYyLCBzO1xuICAgIGRvIHtcbiAgICAgICAgdjEgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gICAgICAgIHYyID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICAgICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgfSB3aGlsZSAocyA+IDEpO1xuICAgIHZhciByZXN1bHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpICogdjE7XG4gICAgaWYgKHRydW5jYXRlZCAmJiBNYXRoLmFicyhyZXN1bHQpID4gMikge1xuICAgICAgICByZXR1cm4gcmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBtZWFuICsgc3RkRGV2ICogcmVzdWx0O1xufVxuZXhwb3J0cy5yYW5kR2F1c3MgPSByYW5kR2F1c3M7XG5mdW5jdGlvbiBkaXN0U3F1YXJlZChhLCBiKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaWZmID0gTnVtYmVyKGFbaV0pIC0gTnVtYmVyKGJbaV0pO1xuICAgICAgICByZXN1bHQgKz0gZGlmZiAqIGRpZmY7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRpc3RTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG5mdW5jdGlvbiBhc3NlcnQoZXhwciwgbXNnKSB7XG4gICAgaWYgKCFleHByKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZnVuY3Rpb24gYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGVBLCBzaGFwZUIsIGVycm9yTWVzc2FnZVByZWZpeCkge1xuICAgIGlmIChlcnJvck1lc3NhZ2VQcmVmaXggPT09IHZvaWQgMCkgeyBlcnJvck1lc3NhZ2VQcmVmaXggPSAnJzsgfVxuICAgIGFzc2VydChhcnJheXNFcXVhbChzaGFwZUEsIHNoYXBlQiksIGVycm9yTWVzc2FnZVByZWZpeCArIChcIlNoYXBlcyBcIiArIHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xufVxuZXhwb3J0cy5hc3NlcnRTaGFwZXNNYXRjaCA9IGFzc2VydFNoYXBlc01hdGNoO1xuZnVuY3Rpb24gZmxhdHRlbihhcnIsIHJldCkge1xuICAgIGlmIChyZXQgPT09IHZvaWQgMCkgeyByZXQgPSBbXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oYXJyW2ldLCByZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXQucHVzaChhcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGluZmVyU2hhcGUoYXJyKSB7XG4gICAgdmFyIHNoYXBlID0gW107XG4gICAgd2hpbGUgKGFyciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHNoYXBlLnB1c2goYXJyLmxlbmd0aCk7XG4gICAgICAgIGFyciA9IGFyclswXTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xufVxuZXhwb3J0cy5pbmZlclNoYXBlID0gaW5mZXJTaGFwZTtcbmZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHNoYXBlWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5leHBvcnRzLnNpemVGcm9tU2hhcGUgPSBzaXplRnJvbVNoYXBlO1xuZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzU2NhbGFyU2hhcGUgPSBpc1NjYWxhclNoYXBlO1xuZnVuY3Rpb24gYXJyYXlzRXF1YWwobjEsIG4yKSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmFycmF5c0VxdWFsID0gYXJyYXlzRXF1YWw7XG5mdW5jdGlvbiBpc0ludChhKSB7XG4gICAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgaWYgKE1hdGgudGFuaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRhbmgoeCk7XG4gICAgfVxuICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlMnggPSBNYXRoLmV4cCgyICogeCk7XG4gICAgICAgIHJldHVybiAoZTJ4IC0gMSkgLyAoZTJ4ICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy50YW5oID0gdGFuaDtcbmZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSkge1xuICAgIGZvciAodmFyIGEgPSBNYXRoLmZsb29yKE1hdGguc3FydChzaXplKSk7IGEgPiAxOyAtLWEpIHtcbiAgICAgICAgaWYgKHNpemUgJSBhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2EsIHNpemUgLyBhXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWzEsIHNpemVdO1xufVxuZXhwb3J0cy5zaXplVG9TcXVhcmlzaFNoYXBlID0gc2l6ZVRvU3F1YXJpc2hTaGFwZTtcbmZ1bmN0aW9uIGNyZWF0ZVNodWZmbGVkSW5kaWNlcyhuKSB7XG4gICAgdmFyIHNodWZmbGVkSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzaHVmZmxlZEluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICBzaHVmZmxlKHNodWZmbGVkSW5kaWNlcyk7XG4gICAgcmV0dXJuIHNodWZmbGVkSW5kaWNlcztcbn1cbmV4cG9ydHMuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzID0gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzO1xuZnVuY3Rpb24gcmlnaHRQYWQoYSwgc2l6ZSkge1xuICAgIGlmIChzaXplIDw9IGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICByZXR1cm4gYSArICcgJy5yZXBlYXQoc2l6ZSAtIGEubGVuZ3RoKTtcbn1cbmV4cG9ydHMucmlnaHRQYWQgPSByaWdodFBhZDtcbmZ1bmN0aW9uIHJlcGVhdGVkVHJ5KGNoZWNrRm4sIGRlbGF5Rm4sIG1heENvdW50ZXIpIHtcbiAgICBpZiAoZGVsYXlGbiA9PT0gdm9pZCAwKSB7IGRlbGF5Rm4gPSBmdW5jdGlvbiAoY291bnRlcikgeyByZXR1cm4gMDsgfTsgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0cnlDb3VudCA9IDA7XG4gICAgICAgIHZhciB0cnlGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0ZuKCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5Q291bnQrKztcbiAgICAgICAgICAgIHZhciBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuICAgICAgICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCh0cnlGbiwgbmV4dEJhY2tvZmYpO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHRyeUZuLCAwKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVwZWF0ZWRUcnkgPSByZXBlYXRlZFRyeTtcbmZ1bmN0aW9uIGdldFF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHF1ZXJ5U3RyaW5nLnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciB0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVBhcmFtKHBhcmFtcywgdFswXSwgdFsxXSk7XG4gICAgICAgIHJldHVybiB0LmpvaW4oJz0nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZXhwb3J0cy5nZXRRdWVyeVBhcmFtcyA9IGdldFF1ZXJ5UGFyYW1zO1xuZnVuY3Rpb24gZGVjb2RlUGFyYW0ocGFyYW1zLCBuYW1lLCB2YWx1ZSkge1xuICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQobmFtZSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8ICcnKTtcbn1cbmZ1bmN0aW9uIGluZmVyRnJvbUltcGxpY2l0U2hhcGUoc2hhcGUsIHNpemUpIHtcbiAgICB2YXIgc2hhcGVQcm9kID0gMTtcbiAgICB2YXIgaW1wbGljaXRJZHggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDApIHtcbiAgICAgICAgICAgIHNoYXBlUHJvZCAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZVtpXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJGb3VuZCAtMSBhdCBkaW0gXCIgKyBpbXBsaWNpdElkeCArIFwiIGFuZCBkaW0gXCIgKyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbXBsaWNpdElkeCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVbaV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8PSAwLiBGb3VuZCBcIiArIHNoYXBlW2ldICsgXCIgYXQgZGltIFwiICsgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltcGxpY2l0SWR4ID09PSAtMSkge1xuICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSAhPT0gc2hhcGVQcm9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNpemUgKFwiICsgc2l6ZSArIFwiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiICsgc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG4gICAgaWYgKHNpemUgJSBzaGFwZVByb2QgIT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gXCIgK1xuICAgICAgICAgICAgKFwiR290IFwiICsgc2l6ZSArIFwiIC8gXCIgKyBzaGFwZVByb2QpKTtcbiAgICB9XG4gICAgdmFyIG5ld1NoYXBlID0gc2hhcGUuc2xpY2UoKTtcbiAgICBuZXdTaGFwZVtpbXBsaWNpdElkeF0gPSBzaXplIC8gc2hhcGVQcm9kO1xuICAgIHJldHVybiBuZXdTaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJGcm9tSW1wbGljaXRTaGFwZSA9IGluZmVyRnJvbUltcGxpY2l0U2hhcGU7XG5leHBvcnRzLk5BTl9JTlQzMiA9IDEgPDwgMzE7XG5leHBvcnRzLk5BTl9CT09MID0gMjU1O1xuZXhwb3J0cy5OQU5fRkxPQVQzMiA9IE5hTjtcbmZ1bmN0aW9uIGdldE5hTihkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5BTl9GTE9BVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5OQU5fSU5UMzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTkFOX0JPT0w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0TmFOID0gZ2V0TmFOO1xuZnVuY3Rpb24gaXNWYWxOYU4odmFsLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBpc05hTih2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gdmFsID09PSBleHBvcnRzLk5BTl9JTlQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gdmFsID09PSBleHBvcnRzLk5BTl9CT09MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsTmFOID0gaXNWYWxOYU47XG5mdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGUpIHtcbiAgICB2YXIgbmV3U2hhcGUgPSBbXTtcbiAgICB2YXIga2VwdERpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDEpIHtcbiAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBuZXdTaGFwZTogbmV3U2hhcGUsIGtlcHREaW1zOiBrZXB0RGltcyB9O1xufVxuZXhwb3J0cy5zcXVlZXplU2hhcGUgPSBzcXVlZXplU2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlcnNpb24gPSAnMC4zLjExJztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIi8vIEEgbGlicmFyeSBvZiBzZWVkYWJsZSBSTkdzIGltcGxlbWVudGVkIGluIEphdmFzY3JpcHQuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG4vLyB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbSgxKTsgLy8gb3IgYW55IHNlZWQuXG4vLyB2YXIgeCA9IHJhbmRvbSgpOyAgICAgICAvLyAwIDw9IHggPCAxLiAgRXZlcnkgYml0IGlzIHJhbmRvbS5cbi8vIHZhciB4ID0gcmFuZG9tLnF1aWNrKCk7IC8vIDAgPD0geCA8IDEuICAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXG5cbi8vIGFsZWEsIGEgNTMtYml0IG11bHRpcGx5LXdpdGgtY2FycnkgZ2VuZXJhdG9yIGJ5IEpvaGFubmVzIEJhYWfDuGUuXG4vLyBQZXJpb2Q6IH4yXjExNlxuLy8gUmVwb3J0ZWQgdG8gcGFzcyBhbGwgQmlnQ3J1c2ggdGVzdHMuXG52YXIgYWxlYSA9IHJlcXVpcmUoJy4vbGliL2FsZWEnKTtcblxuLy8geG9yMTI4LCBhIHB1cmUgeG9yLXNoaWZ0IGdlbmVyYXRvciBieSBHZW9yZ2UgTWFyc2FnbGlhLlxuLy8gUGVyaW9kOiAyXjEyOC0xLlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogTWF0cml4UmFuayBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3IxMjggPSByZXF1aXJlKCcuL2xpYi94b3IxMjgnKTtcblxuLy8geG9yd293LCBHZW9yZ2UgTWFyc2FnbGlhJ3MgMTYwLWJpdCB4b3Itc2hpZnQgY29tYmluZWQgcGx1cyB3ZXlsLlxuLy8gUGVyaW9kOiAyXjE5Mi0yXjMyXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBDb2xsaXNpb25PdmVyLCBTaW1wUG9rZXIsIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcndvdyA9IHJlcXVpcmUoJy4vbGliL3hvcndvdycpO1xuXG4vLyB4b3JzaGlmdDcsIGJ5IEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyLCB0YWtlc1xuLy8gYSBkaWZmZXJlbnQgYXBwcm9hY2g6IGl0IGFkZHMgcm9idXN0bmVzcyBieSBhbGxvd2luZyBtb3JlIHNoaWZ0c1xuLy8gdGhhbiBNYXJzYWdsaWEncyBvcmlnaW5hbCB0aHJlZS4gIEl0IGlzIGEgNy1zaGlmdCBnZW5lcmF0b3Jcbi8vIHdpdGggMjU2IGJpdHMsIHRoYXQgcGFzc2VzIEJpZ0NydXNoIHdpdGggbm8gc3lzdG1hdGljIGZhaWx1cmVzLlxuLy8gUGVyaW9kIDJeMjU2LTEuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcnNoaWZ0NyA9IHJlcXVpcmUoJy4vbGliL3hvcnNoaWZ0NycpO1xuXG4vLyB4b3I0MDk2LCBieSBSaWNoYXJkIEJyZW50LCBpcyBhIDQwOTYtYml0IHhvci1zaGlmdCB3aXRoIGFcbi8vIHZlcnkgbG9uZyBwZXJpb2QgdGhhdCBhbHNvIGFkZHMgYSBXZXlsIGdlbmVyYXRvci4gSXQgYWxzbyBwYXNzZXNcbi8vIEJpZ0NydXNoIHdpdGggbm8gc3lzdGVtYXRpYyBmYWlsdXJlcy4gIEl0cyBsb25nIHBlcmlvZCBtYXlcbi8vIGJlIHVzZWZ1bCBpZiB5b3UgaGF2ZSBtYW55IGdlbmVyYXRvcnMgYW5kIG5lZWQgdG8gYXZvaWRcbi8vIGNvbGxpc2lvbnMuXG4vLyBQZXJpb2Q6IDJeNDEyOC0yXjMyLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3I0MDk2ID0gcmVxdWlyZSgnLi9saWIveG9yNDA5NicpO1xuXG4vLyBUeWNoZS1pLCBieSBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8sIGlzIGEgYml0LXNoaWZ0aW5nIHJhbmRvbVxuLy8gbnVtYmVyIGdlbmVyYXRvciBkZXJpdmVkIGZyb20gQ2hhQ2hhLCBhIG1vZGVybiBzdHJlYW0gY2lwaGVyLlxuLy8gaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcbi8vIFBlcmlvZDogfjJeMTI3XG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHR5Y2hlaSA9IHJlcXVpcmUoJy4vbGliL3R5Y2hlaScpO1xuXG4vLyBUaGUgb3JpZ2luYWwgQVJDNC1iYXNlZCBwcm5nIGluY2x1ZGVkIGluIHRoaXMgbGlicmFyeS5cbi8vIFBlcmlvZDogfjJeMTYwMFxudmFyIHNyID0gcmVxdWlyZSgnLi9zZWVkcmFuZG9tJyk7XG5cbnNyLmFsZWEgPSBhbGVhO1xuc3IueG9yMTI4ID0geG9yMTI4O1xuc3IueG9yd293ID0geG9yd293O1xuc3IueG9yc2hpZnQ3ID0geG9yc2hpZnQ3O1xuc3IueG9yNDA5NiA9IHhvcjQwOTY7XG5zci50eWNoZWkgPSB0eWNoZWk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3I7XG4iLCIvLyBBIHBvcnQgb2YgYW4gYWxnb3JpdGhtIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuLy8gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25xdWlubGFuL2JldHRlci1yYW5kb20tbnVtYmVycy1mb3ItamF2YXNjcmlwdC1taXJyb3Jcbi8vIE9yaWdpbmFsIHdvcmsgaXMgdW5kZXIgTUlUIGxpY2Vuc2UgLVxuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLypcbkNvcHlyaWdodCAyMDE0IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChwb29sLCBtYXRoKSB7XG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cbnZhciBnbG9iYWwgPSB0aGlzLFxuICAgIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcbiAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5mdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgb3B0aW9ucyA9IChvcHRpb25zID09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICBvcHRpb25zLmVudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcbiAgICAoc2VlZCA9PSBudWxsKSA/IGF1dG9zZWVkKCkgOiBzZWVkLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cbiAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLCAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH1cbiAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH1cbiAgcHJuZy5kb3VibGUgPSBwcm5nO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcblxuICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cbiAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykgeyBjb3B5KHN0YXRlLCBhcmM0KTsgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKFxuICBwcm5nLFxuICBzaG9ydHNlZWQsXG4gICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxuICBvcHRpb25zLnN0YXRlKTtcbn1cbm1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59XG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufSkoXG4gIFtdLCAgICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxuICBNYXRoICAgIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cbik7XG4iXX0=
